# 1 "bad.h"
# 1 "<built-in>"
# 1 "<command-line>"
extern "C" {
#include <stdc-predef.h>
}
# 1 "bad.h"


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/user.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/select_compiler_config.hpp" 1
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/compiler/gcc.hpp" 1
# 165 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/compiler/gcc.hpp"
#include <cstddef>
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/select_stdlib_config.hpp" 1
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/stdlib/libstdcpp3.hpp" 1
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/stdlib/libstdcpp3.hpp"
extern "C" {
#include <unistd.h>
}
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/select_platform_config.hpp" 1
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/platform/linux.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/platform/linux.hpp"
#include <cstdlib>
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/platform/linux.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/posix_features.hpp" 1
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/platform/linux.hpp" 2
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp" 1
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp"
       
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp" 3
# 484 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}



namespace boost{

   __extension__ typedef __int128 int128_type;
   __extension__ typedef unsigned __int128 uint128_type;




}
# 543 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp" 3
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/helper_macros.hpp" 1 3
# 544 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/detail/suffix.hpp" 2 3
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config.hpp" 2


       
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp" 2

          






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/workaround.hpp" 1







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/workaround.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/workaround.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp"
extern "C" {
#include <assert.h>
}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_traits.hpp" 1
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_traits.hpp"
#include <iterator>


# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_traits.hpp"
namespace boost {
namespace iterators {






template <class Iterator>
struct iterator_value
{
    typedef typename std::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename std::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename std::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename std::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename std::iterator_traits<Iterator>::iterator_category type;
};

}

using iterators::iterator_value;
using iterators::iterator_reference;
using iterators::iterator_pointer;
using iterators::iterator_difference;
using iterators::iterator_category;

}
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 1
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/adl_barrier.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/adl_barrier.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/msvc.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/intel.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/gcc.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/workaround.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/adl.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/adl_barrier.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/adl_barrier.hpp"
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool_fwd.hpp" 2

namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_tag.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_tag.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/static_constant.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_tag.hpp" 2

namespace mpl_ {
struct integral_c_tag { 
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_tag.hpp" 3
                       static const 
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_tag.hpp"
                       int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp" 2


namespace mpl_ {

template< bool C_ > struct bool_
{
    
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp" 3
   static const 
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp"
   bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp" 3
   constexpr 
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bool.hpp"
                   operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 2





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/nested_type_wknd.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/nested_type_wknd.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/void_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/void_fwd.hpp"
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_fwd.hpp"
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/ctps.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na.hpp" 2

namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na.hpp"
}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/lambda.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/lambda.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/ttp.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/lambda.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int_fwd.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/nttp_decl.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/nttp_decl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/nttp.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/nttp_decl.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int_fwd.hpp" 2

namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/static_cast.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/cat.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/cat.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/config/config.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/cat.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< int N >
struct int_
{
    
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
   int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   constexpr 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
                   operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/int.hpp" 2
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/lambda_arity_param.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/template_arity_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/template_arity_fwd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda_fwd.hpp" 2

namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arity.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arity.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/dtp.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arity.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/preprocessor.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comma_if.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comma_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/if.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/iif.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/bool.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/if.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/empty.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comma_if.hpp" 2
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repeat.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repeat.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/debug/error.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/eat.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat.hpp" 2
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repeat.hpp" 2
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/inc.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/inc.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/inc.hpp" 2
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/enum.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/limits/arity.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/and.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/and.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/bitand.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/and.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/identity.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/identity.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/identity.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/identity.hpp" 2
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/empty.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/add.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/add.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/add.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp" 2
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_left.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_left.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/expr_iif.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_left.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/adt.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/adt.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/is_binary.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/is_binary.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/check.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/is_binary.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/adt.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/compl.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/adt.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_left.hpp" 2
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_left.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_right.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_right.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_right.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_right.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/reverse.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/detail/fold_right.hpp" 2
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/list/fold_right.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 2
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/detail/while.hpp" 1
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/while.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/add.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/expand.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/overload.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/overload.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/variadic/size.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/facilities/overload.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/rem.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/rem.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/detail/is_single_return.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/rem.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/variadic/elem.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/tuple/elem.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/add.hpp" 2
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/sub.hpp" 1
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/eti.hpp" 1
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/overload_resolution.hpp" 1
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_spec.hpp" 2
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/lambda_support.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 2
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/compiler.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/stringize.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/or.hpp"
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/or.hpp" 2
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/intrinsics.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/intrinsics.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/config.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/config.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/version.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/config.hpp" 2
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/intrinsics.hpp" 2
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp"
namespace mpl_{

   template <bool B> struct bool_;
   template <class I, I val> struct integral_c;
   struct integral_c_tag;
}

namespace boost
{
   namespace mpl
   {
      using ::mpl_::bool_;
      using ::mpl_::integral_c;
      using ::mpl_::integral_c_tag;
   }
}



namespace boost{

   template <class T, T val>
   struct integral_constant
   {
      typedef mpl::integral_c_tag tag;
      typedef T value_type;
      typedef integral_constant<T, val> type;
      static const T value = val;

      operator const mpl::integral_c<T, val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::integral_c<T, val>*>(pdata));
      }
      
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp" 3
     constexpr 
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp"
                     operator T()const { return val; }
   };

   template <class T, T val>
   T const integral_constant<T, val>::value;

   template <bool val>
   struct integral_constant<bool, val>
   {
      typedef mpl::integral_c_tag tag;
      typedef bool value_type;
      typedef integral_constant<bool, val> type;
      static const bool value = val;

      operator const mpl::bool_<val>& ()const
      {
         static const char data[sizeof(long)] = { 0 };
         static const void* pdata = data;
         return *(reinterpret_cast<const mpl::bool_<val>*>(pdata));
      }
      
# 86 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp" 3
     constexpr 
# 86 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/integral_constant.hpp"
                     operator bool()const { return val; }
   };

   template <bool val>
   bool const integral_constant<bool, val>::value;

   typedef integral_constant<bool, true> true_type;
   typedef integral_constant<bool, false> false_type;

}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_rvalue_reference.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_rvalue_reference.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_void.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_void.hpp"
namespace boost {

template <class T>
struct is_void : public false_type {};

template<> struct is_void<void> : public true_type {};
template<> struct is_void<const void> : public true_type{};
template<> struct is_void<const volatile void> : public true_type{};
template<> struct is_void<volatile void> : public true_type{};

}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_rvalue_reference.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_reference.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_reference.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_lvalue_reference.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_lvalue_reference.hpp"
namespace boost {





   template <class T> struct is_lvalue_reference : public false_type{};
   template <class T> struct is_lvalue_reference<T&> : public true_type{};
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_lvalue_reference.hpp"
}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_reference.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_rvalue_reference.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_rvalue_reference.hpp"
namespace boost {

template <class T> struct is_rvalue_reference : public false_type {};

template <class T> struct is_rvalue_reference<T&&> : public true_type {};


}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_reference.hpp" 2

namespace boost {

template <class T> struct is_reference
   : public
   integral_constant<
      bool,
      ::boost::is_lvalue_reference<T>::value || ::boost::is_rvalue_reference<T>::value>
{};

}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_rvalue_reference.hpp" 2
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_rvalue_reference.hpp"
namespace boost {

namespace type_traits_detail {

    template <typename T, bool b>
    struct add_rvalue_reference_helper
    { typedef T type; };


    template <typename T>
    struct add_rvalue_reference_helper<T, true>
    {
        typedef T&& type;
    };


    template <typename T>
    struct add_rvalue_reference_imp
    {
       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
                  <T, (is_void<T>::value == false && is_reference<T>::value == false) >::type type;
    };

}

template <class T> struct add_rvalue_reference
{
   typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type;
};



   template <class T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;



}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp"
namespace boost {

    template <typename T>
    typename add_rvalue_reference<T>::type declval() 
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp" 3
                                                    noexcept
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/declval.hpp"
                                                                  ;

}
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_reference.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_reference.hpp"
namespace boost {


namespace detail{




template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};

template <class T>
struct remove_rvalue_ref<T&&>
{
   typedef T type;
};


}

template <class T> struct remove_reference{ typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template <class T> struct remove_reference<T&>{ typedef T type; };
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_reference.hpp"
   template <class T> using remove_reference_t = typename remove_reference<T>::type;



}
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_function.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_function.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_function_cxx_11.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_function_cxx_11.hpp"
namespace boost {

   template <class T>
   struct is_function : public false_type {};
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_function_cxx_11.hpp"
   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile noexcept(NE)> : public true_type {};



   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)& noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)& noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const & noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile & noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile & noexcept(NE)> : public true_type {};



   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)&& noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)&& noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const && noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)volatile && noexcept(NE)> : public true_type {};

   template <class Ret, class...Args , bool NE>
   struct is_function<Ret (Args...)const volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class ...Args , bool NE>
   struct is_function<Ret(Args..., ...)const volatile && noexcept(NE)> : public true_type {};
# 566 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_function_cxx_11.hpp"
}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_function.hpp" 2
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/yes_no_type.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/yes_no_type.hpp"
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp" 2
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp"
namespace boost {
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp"
   namespace detail{

      template <unsigned N>
      struct ok_tag { double d; char c[N]; };

      template <class T>
      ok_tag<sizeof(T)> check_is_complete(int);
      template <class T>
      char check_is_complete(...);
   }

   template <class T> struct is_complete
      : public integral_constant<bool, ::boost::is_function<typename boost::remove_reference<T>::type>::value || (sizeof(boost::detail::check_is_complete<T>(0)) != sizeof(char))> {};
# 90 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_complete.hpp"
}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_array.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_array.hpp"
namespace boost {




   template <class T> struct is_array : public false_type {};

   template <class T, std::size_t N> struct is_array<T[N]> : public true_type {};
   template <class T, std::size_t N> struct is_array<T const[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T volatile[N]> : public true_type{};
   template <class T, std::size_t N> struct is_array<T const volatile[N]> : public true_type{};

   template <class T> struct is_array<T[]> : public true_type{};
   template <class T> struct is_array<T const[]> : public true_type{};
   template <class T> struct is_array<T const volatile[]> : public true_type{};
   template <class T> struct is_array<T volatile[]> : public true_type{};





}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/static_assert.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_arithmetic.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_arithmetic.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_integral.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_integral.hpp"
namespace boost {






template <class T> struct is_integral : public false_type {};
template <class T> struct is_integral<const T> : public is_integral<T> {};
template <class T> struct is_integral<volatile const T> : public is_integral<T>{};
template <class T> struct is_integral<volatile T> : public is_integral<T>{};




template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type{};
template<> struct is_integral<unsigned int> : public true_type{};
template<> struct is_integral<unsigned long> : public true_type{};

template<> struct is_integral<signed char> : public true_type{};
template<> struct is_integral<short> : public true_type{};
template<> struct is_integral<int> : public true_type{};
template<> struct is_integral<long> : public true_type{};

template<> struct is_integral<char> : public true_type{};
template<> struct is_integral<bool> : public true_type{};





template<> struct is_integral<wchar_t> : public true_type{};
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_integral.hpp"
template<> struct is_integral< ::boost::ulong_long_type> : public true_type{};
template<> struct is_integral< ::boost::long_long_type> : public true_type{};






template<> struct is_integral<boost::int128_type> : public true_type{};
template<> struct is_integral<boost::uint128_type> : public true_type{};


template<> struct is_integral<char16_t> : public true_type{};


template<> struct is_integral<char32_t> : public true_type{};




}
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_arithmetic.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_floating_point.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_floating_point.hpp"
namespace boost {


   template <class T> struct is_floating_point : public false_type{};
   template <class T> struct is_floating_point<const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile const T> : public is_floating_point<T>{};
   template <class T> struct is_floating_point<volatile T> : public is_floating_point<T>{};
   template<> struct is_floating_point<float> : public true_type{};
   template<> struct is_floating_point<double> : public true_type{};
   template<> struct is_floating_point<long double> : public true_type{};





}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_arithmetic.hpp" 2

namespace boost {

template <class T>
struct is_arithmetic : public integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_abstract.hpp" 1
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_abstract.hpp"
namespace boost {

namespace detail{


template <class T>
struct is_abstract_imp
{
   
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_abstract.hpp" 3
  static const 
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_abstract.hpp"
  bool value = __is_abstract(T);
};
# 140 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_abstract.hpp"
}


template <class T> struct is_abstract : public integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value> {};




}
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_lvalue_reference.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_lvalue_reference.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_reference.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_reference.hpp"
namespace boost {

namespace detail {






template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template <typename T>
struct add_reference_impl<T&&>
{
    typedef T&& type;
};


}

template <class T> struct add_reference
{
   typedef typename boost::detail::add_reference_impl<T>::type type;
};
template <class T> struct add_reference<T&>
{
   typedef T& type;
};


template <> struct add_reference<void> { typedef void type; };

template <> struct add_reference<const void> { typedef const void type; };
template <> struct add_reference<const volatile void> { typedef const volatile void type; };
template <> struct add_reference<volatile void> { typedef volatile void type; };




template <class T> using add_reference_t = typename add_reference<T>::type;




}
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_lvalue_reference.hpp" 2

namespace boost{

template <class T> struct add_lvalue_reference
{
   typedef typename boost::add_reference<T>::type type;
};


template <class T> struct add_lvalue_reference<T&&>
{
   typedef T& type;
};




   template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;



}
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 2
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
namespace boost {
# 59 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
namespace detail {







   template <class A, class B, class C>
   struct or_helper
   {
      static const bool value = (A::value || B::value || C::value);
   };

   template<typename From, typename To, bool b = or_helper<boost::is_void<From>, boost::is_function<To>, boost::is_array<To> >::value>
   struct is_convertible_basic_impl
   {

      static const bool value = is_void<To>::value;
   };

   template<typename From, typename To>
   class is_convertible_basic_impl<From, To, false>
   {
      typedef char one;
      typedef int two;

      template<typename To1>
      static void test_aux(To1);

      template<typename From1, typename To1>
      static decltype(test_aux<To1>(boost::declval<From1>()), one()) test(int);

      template<typename, typename>
      static two test(...);

   public:
      static const bool value = sizeof(test<From, To>(0)) == 1;
   };
# 362 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
template <typename From, typename To>
struct is_convertible_impl
{
   
# 365 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp" 3
  static const 
# 365 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
  bool value = ( ::boost::detail::is_convertible_basic_impl<From, To>::value && !::boost::is_array<To>::value && !::boost::is_function<To>::value);
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,




      false

   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 442 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
template <> struct is_convertible_impl_dispatch<void, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void const, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void const volatile, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void const volatile, void volatile> : public true_type{};

template <> struct is_convertible_impl_dispatch<void volatile, void> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void const> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void const volatile> : public true_type{};
template <> struct is_convertible_impl_dispatch<void volatile, void volatile> : public true_type{};





template <class To> struct is_convertible_impl_dispatch<void, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void> : public false_type{};


template <class To> struct is_convertible_impl_dispatch<void const, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void const> : public false_type{};
template <class To> struct is_convertible_impl_dispatch<void const volatile, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void const volatile> : public false_type{};
template <class To> struct is_convertible_impl_dispatch<void volatile, To> : public false_type{};
template <class From> struct is_convertible_impl_dispatch<From, void volatile> : public false_type{};


}

template <class From, class To>
struct is_convertible : public integral_constant<bool, ::boost::detail::is_convertible_impl_dispatch<From, To>::value>
{
   static_assert(boost::is_complete<To>::value || boost::is_void<To>::value || boost::is_array<To>::value, "Destination argument type to is_convertible must be a complete type");
   static_assert(boost::is_complete<From>::value || boost::is_void<From>::value || boost::is_array<From>::value, "From argument type to is_convertible must be a complete type");
};
# 504 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_convertible.hpp"
}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 2

namespace boost {
namespace iterators {
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp"
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

using iterators::is_interoperable;

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/interoperable.hpp" 2
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 1
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/eval_if.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/eval_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/if.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/value_wknd.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/value_wknd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/integral.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/value_wknd.hpp" 2
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/value_wknd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/value_wknd.hpp"
}}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/if.hpp" 2







namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/if.hpp"
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/eval_if.hpp" 2






namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/identity.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/identity.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg_fwd.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg_fwd.hpp"
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_assert.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_assert.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/not.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/not.hpp"
namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/yes_no.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/yes_no.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/arrays.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/yes_no.hpp" 2




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/yes_no.hpp"
}}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/gpu.hpp" 1
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/pp_counter.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp" 2
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
namespace mpl_ {

struct failed {};
# 79 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 127 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};
# 171 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"


template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );



#pragma GCC diagnostic pop


template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 257 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/assert.hpp"
}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/na_assert.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arity_spec.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arg_typedef.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
namespace mpl_ {
template<> struct arg< -1 >
{
    
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    
# 105 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
   static const 
# 105 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
   int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 2
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp" 2
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp"
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp" 2
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 2
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp"
namespace boost {
namespace iterators {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};

}




template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::iterators::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename std::iterator_traits<Iterator>::iterator_category
    >
{};
# 146 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp"
template <class Traversal>
struct pure_traversal_tag
  : mpl::eval_if<
        is_convertible<Traversal,random_access_traversal_tag>
      , mpl::identity<random_access_traversal_tag>
      , mpl::eval_if<
            is_convertible<Traversal,bidirectional_traversal_tag>
          , mpl::identity<bidirectional_traversal_tag>
          , mpl::eval_if<
                is_convertible<Traversal,forward_traversal_tag>
              , mpl::identity<forward_traversal_tag>
              , mpl::eval_if<
                    is_convertible<Traversal,single_pass_traversal_tag>
                  , mpl::identity<single_pass_traversal_tag>
                  , mpl::eval_if<
                        is_convertible<Traversal,incrementable_traversal_tag>
                      , mpl::identity<incrementable_traversal_tag>
                      , void
                    >
                >
            >
        >
    >
{
};




template <class Iterator = mpl::_1>
struct pure_iterator_traversal
  : pure_traversal_tag<typename iterator_traversal<Iterator>::type>
{};
# 194 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp"
}

using iterators::no_traversal_tag;
using iterators::incrementable_traversal_tag;
using iterators::single_pass_traversal_tag;
using iterators::forward_traversal_tag;
using iterators::bidirectional_traversal_tag;
using iterators::random_access_traversal_tag;
using iterators::iterator_category_to_traversal;
using iterators::iterator_traversal;




namespace detail {
using iterators::pure_traversal_tag;
}

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 215 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_categories.hpp" 2
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 1






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/use_default.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/use_default.hpp"
namespace boost {

struct use_default { };

}
# 8 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/and.hpp" 1
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/and.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/and.hpp"
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/and.hpp" 2
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_same.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_same.hpp"
namespace boost {


   template <class T, class U> struct is_same : public false_type {};
   template <class T> struct is_same<T,T> : public true_type {};







}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_const.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_const.hpp"
namespace boost {
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_const.hpp"
   template <class T>
   struct is_const : public false_type {};
   template <class T> struct is_const<T const> : public true_type{};
   template <class T, std::size_t N> struct is_const<T const[N]> : public true_type{};
   template <class T> struct is_const<T const[]> : public true_type{};



}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 1
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pointer.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pointer.hpp"
namespace boost {




template <class T> struct is_pointer : public false_type{};
template <class T> struct is_pointer<T*> : public true_type{};
template <class T> struct is_pointer<T*const> : public true_type{};
template <class T> struct is_pointer<T*const volatile> : public true_type{};
template <class T> struct is_pointer<T*volatile> : public true_type{};
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pointer.hpp"
}
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_class.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_class.hpp"
namespace boost {

namespace detail {
# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_class.hpp"
template <typename T>
struct is_class_impl
{
    
# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_class.hpp" 3
   static const 
# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_class.hpp"
   bool value = __is_class(T);
};


}

template <class T> struct is_class : public integral_constant<bool, ::boost::detail::is_class_impl<T>::value> {};






}
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_volatile.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_volatile.hpp"
namespace boost {
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_volatile.hpp"
   template <class T>
   struct is_volatile : public false_type {};
   template <class T> struct is_volatile<T volatile> : public true_type{};
   template <class T, std::size_t N> struct is_volatile<T volatile[N]> : public true_type{};
   template <class T> struct is_volatile<T volatile[]> : public true_type{};



}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_member_function_pointer.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_member_function_pointer.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
namespace boost {
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
   template <class T>
   struct is_member_function_pointer : public false_type {};
   template <class T>
   struct is_member_function_pointer<T const> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T volatile> : public is_member_function_pointer<T> {};
   template <class T>
   struct is_member_function_pointer<T const volatile> : public is_member_function_pointer<T> {};
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret (C::*)(Args..., ...)noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile noexcept(NE)> : public true_type {};



   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)& noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)& noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const & noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile & noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile & noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile & noexcept(NE)> : public true_type {};



   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...) && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...) && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)volatile && noexcept(NE)> : public true_type {};

   template <class Ret, class C, class...Args , bool NE>
   struct is_member_function_pointer<Ret ( C::*)(Args...)const volatile && noexcept(NE)> : public true_type {};
   template <class Ret, class C, class ...Args , bool NE>
   struct is_member_function_pointer<Ret(C::*)(Args..., ...)const volatile && noexcept(NE)> : public true_type {};
# 670 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp"
}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_member_pointer.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_member_pointer.hpp"
namespace boost {




template <class T> struct is_member_pointer : public integral_constant<bool, ::boost::is_member_function_pointer<T>::value>{};
template <class T, class U> struct is_member_pointer<U T::* > : public true_type{};


template <class T, class U> struct is_member_pointer<U T::*const> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*const volatile> : public true_type{};
template <class T, class U> struct is_member_pointer<U T::*volatile> : public true_type{};




}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_cv.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_cv.hpp"
namespace boost {


template <class T> struct remove_cv{ typedef T type; };
template <class T> struct remove_cv<T const>{ typedef T type; };
template <class T> struct remove_cv<T volatile>{ typedef T type; };
template <class T> struct remove_cv<T const volatile>{ typedef T type; };


template <class T, std::size_t N> struct remove_cv<T const[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T const volatile[N]>{ typedef T type[N]; };
template <class T, std::size_t N> struct remove_cv<T volatile[N]>{ typedef T type[N]; };

template <class T> struct remove_cv<T const[]>{ typedef T type[]; };
template <class T> struct remove_cv<T const volatile[]>{ typedef T type[]; };
template <class T> struct remove_cv<T volatile[]>{ typedef T type[]; };





   template <class T> using remove_cv_t = typename remove_cv<T>::type;



}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_pointer.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_pointer.hpp"
namespace boost {
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_pointer.hpp"
template <class T> struct remove_pointer{ typedef T type; };
template <class T> struct remove_pointer<T*>{ typedef T type; };
template <class T> struct remove_pointer<T*const>{ typedef T type; };
template <class T> struct remove_pointer<T*volatile>{ typedef T type; };
template <class T> struct remove_pointer<T*const volatile>{ typedef T type; };





   template <class T> using remove_pointer_t = typename remove_pointer<T>::type;



}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/select_type.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/select_type.hpp"
namespace boost { namespace detail {






  template <bool b> struct if_true
  {
      template <class T, class F>
      struct then { typedef T type; };
  };

  template <>
  struct if_true<false>
  {
      template <class T, class F>
      struct then { typedef F type; };
  };
}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp" 2


namespace boost { namespace detail {

namespace indirect_traits {

template <class T>
struct is_reference_to_const : boost::false_type
{
};

template <class T>
struct is_reference_to_const<T const&> : boost::true_type
{
};
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp"
template <class T>
struct is_reference_to_function : boost::false_type
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : boost::false_type
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : boost::false_type
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
};

template <class T>
struct is_reference_to_function_pointer_aux
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : boost::detail::if_true<
          is_reference_to_function<T>::value
      >::template then<
          boost::false_type
        , is_reference_to_function_pointer_aux<T>
      >::type
{
};

template <class T>
struct is_reference_to_non_const
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          !is_reference_to_const<T>::value
      >
{
};

template <class T>
struct is_reference_to_volatile : boost::false_type
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : boost::true_type
{
};
# 137 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/indirect_traits.hpp"
template <class T>
struct is_reference_to_pointer : boost::false_type
{
};

template <class T>
struct is_reference_to_pointer<T*&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : boost::true_type
{
};

template <class T>
struct is_reference_to_class
    : boost::integral_constant<bool,
          is_reference<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >::value
      >
{
};

template <class T>
struct is_pointer_to_class
    : boost::integral_constant<bool,
          is_pointer<T>::value &&
          is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >::value
      >
{
};


}

using namespace indirect_traits;

}}
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2






namespace boost {
namespace iterators {

using boost::use_default;

namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp"
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{



    enum { mpl_assertion_in_line_146 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) }



             ;

    enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_150 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };

};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{
    enum { mpl_assertion_in_line_161 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };

    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/facade_iterator_category.hpp" 2
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/enable_if.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/enable_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/enable_if.hpp" 2







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/enable_if.hpp"
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {
    };

  }

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/enable_if.hpp" 2
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp" 1
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp"
namespace boost {

template<class T>

# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp" 3
constexpr 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp"
               inline T*
addressof(T& o) 
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp" 3
               noexcept

# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp"
{
    return __builtin_addressof(o);
}

}
# 266 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/addressof.hpp"
namespace boost {

template<class T>
const T* addressof(const T&&) = delete;

}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_const.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_const.hpp"
namespace boost {
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_const.hpp"
   template <class T> struct add_const
   {
      typedef T const type;
   };





   template <class T> struct add_const<T&>
   {
      typedef T& type;
   };



   template <class T> using add_const_t = typename add_const<T>::type;



}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_pointer.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_pointer.hpp"
namespace boost {
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_pointer.hpp"
template <typename T>
struct add_pointer
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};





   template <class T> using add_pointer_t = typename add_pointer<T>::type;



}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_const.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/remove_const.hpp"
namespace boost {


   template <class T> struct remove_const{ typedef T type; };
   template <class T> struct remove_const<T const>{ typedef T type; };


   template <class T, std::size_t N> struct remove_const<T const[N]>{ typedef T type[N]; };

   template <class T> struct remove_const<T const[]>{ typedef T type[]; };





   template <class T> using remove_const_t = typename remove_const<T>::type;



}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pod.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pod.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_scalar.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_scalar.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_enum.hpp" 1
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_enum.hpp"
namespace boost {
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_enum.hpp"
template <class T> struct is_enum : public integral_constant<bool, __is_enum(T)> {};



}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_scalar.hpp" 2




namespace boost {

template <typename T>
struct is_scalar
   : public integral_constant<bool, ::boost::is_arithmetic<T>::value || ::boost::is_enum<T>::value || ::boost::is_pointer<T>::value || ::boost::is_member_pointer<T>::value>
{};

}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pod.hpp" 2
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_pod.hpp"
namespace boost {


template< typename T > struct is_POD;

template <typename T> struct is_pod
: public integral_constant<bool, ::boost::is_scalar<T>::value || ::boost::is_void<T>::value || __is_pod(T)>
{};


template <typename T, std::size_t sz> struct is_pod<T[sz]> : public is_pod<T>{};




template<> struct is_pod<void> : public true_type{};


template<> struct is_pod<void const> : public true_type{};
template<> struct is_pod<void const volatile> : public true_type{};
template<> struct is_pod<void volatile> : public true_type{};


template<class T> struct is_POD : public is_pod<T>{};

}
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/always.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/always.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessor/default_params.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/always.hpp" 2



namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
        typename T1 = na , typename T2 = na , typename T3 = na , typename T4 = na , typename T5 = na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_fwd.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp"
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_fwd.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/type_wrapper.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/type_wrapper.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/has_xxx.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/msvc_typename.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/elem.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/elem.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/data.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/elem.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/size.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/array/elem.hpp" 2
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/enum_params.hpp" 1
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 1
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/has_xxx.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/has_apply.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp" 2

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp" 3
static const 
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_apply.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_never_true.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 2
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp"
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 2
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind_fwd.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/bind.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind_fwd.hpp" 2






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp"
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind_fwd.hpp" 2
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/placeholders.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next_prior.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next_prior.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/common_name_wknd.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next_prior.hpp" 2



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/next.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/protect.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/protect.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/protect.hpp"
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp"
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/bind_fwd.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/void.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/void.hpp"
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_type.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_type.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_type.hpp" 3
static const 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_type.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/bcc.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp" 2
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp"
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/quote.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/template_arity.hpp" 1
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/template_arity.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
namespace boost { namespace mpl { namespace aux {
template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
   static const 
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
   int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) )

         ;
};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    
# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
   static const 
# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
   int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1

         ;
};

template< typename F >
struct template_arity
{
    
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
   static const 
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp"
   int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value )

          ;
    typedef mpl::int_<value> type;
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/template_arity.hpp" 2
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 2
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp"
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/full_lambda.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/lambda.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp"
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2

namespace boost {
namespace iterators {



  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };


    template< typename CategoryOrTraversal, typename Required >
    struct is_traversal_at_least :
        public boost::is_convertible< typename iterator_category_to_traversal< CategoryOrTraversal >::type, Required >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable :
        public boost::iterators::enable_if<
            is_interoperable< Facade1, Facade2 >
          , Return
        >
    {};




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable_and_random_access_traversal :
        public boost::iterators::enable_if<
            mpl::and_<
                is_interoperable< Facade1, Facade2 >
              , is_traversal_at_least< typename iterator_category< Facade1 >::type, random_access_traversal_tag >
              , is_traversal_at_least< typename iterator_category< Facade2 >::type, random_access_traversal_tag >
            >
          , Return
        >
    {};





    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;


        typedef typename mpl::eval_if<
            boost::iterators::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 145 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 259 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 284 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<
                    Reference





                  , typename add_lvalue_reference<Value const>::type
                >



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class Reference, class Pointer>
    struct operator_arrow_dispatch
    {
        struct proxy
        {
            explicit proxy(Reference const & x) : m_ref(x) {}
            Reference* operator->() { return boost::addressof(m_ref); }


            operator Reference*() { return boost::addressof(m_ref); }
            Reference m_ref;
        };
        typedef proxy result_type;
        static result_type apply(Reference const & x)
        {
            return result_type(x);
        }
    };

    template <class T, class Pointer>
    struct operator_arrow_dispatch<T&, Pointer>
    {
        typedef Pointer result_type;
        static result_type apply(T& x)
        {
            return boost::addressof(x);
        }
    };




    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :



          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };

    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
      , bool IsBidirectionalTraversal
      , bool IsRandomAccessTraversal
    >
    class iterator_facade_base;

  }
# 497 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
  class iterator_core_access
  {






      template <class I, class V, class TC, class R, class D> friend class iterator_facade;
      template <class I, class V, class TC, class R, class D, bool IsBidirectionalTraversal, bool IsRandomAccessTraversal>
      friend class detail::iterator_facade_base;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);






      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);



      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }


      iterator_core_access() 
# 613 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 3
     = delete;
  
# 614 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
 };

  namespace detail {


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >






    {
    private:
        typedef boost::iterators::detail::iterator_facade_types<
            Value, CategoryOrTraversal, Reference, Difference
        > associated_types;

        typedef boost::iterators::detail::operator_arrow_dispatch<
            Reference
          , typename associated_types::pointer
        > operator_arrow_dispatch_;

    public:
        typedef typename associated_types::value_type value_type;
        typedef Reference reference;
        typedef Difference difference_type;

        typedef typename operator_arrow_dispatch_::result_type pointer;

        typedef typename associated_types::iterator_category iterator_category;

    public:
        reference operator*() const
        {
            return iterator_core_access::dereference(this->derived());
        }

        pointer operator->() const
        {
            return operator_arrow_dispatch_::apply(*this->derived());
        }

        Derived& operator++()
        {
            iterator_core_access::increment(this->derived());
            return this->derived();
        }

    protected:



        Derived& derived()
        {
            return *static_cast<Derived*>(this);
        }

        Derived const& derived() const
        {
            return *static_cast<Derived const*>(this);
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, false, false >
    {
    public:
        Derived& operator--()
        {
            iterator_core_access::decrement(this->derived());
            return this->derived();
        }

        Derived operator--(int)
        {
            Derived tmp(this->derived());
            --*this;
            return tmp;
        }
    };


    template <
        class Derived
      , class Value
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    class iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, true > :
        public iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false >
    {
    private:
        typedef iterator_facade_base< Derived, Value, CategoryOrTraversal, Reference, Difference, true, false > base_type;

    public:
        typedef typename base_type::reference reference;
        typedef typename base_type::difference_type difference_type;

    public:
        typename boost::iterators::detail::operator_brackets_result<Derived, Value, reference>::type
        operator[](difference_type n) const
        {
            typedef boost::iterators::detail::use_operator_brackets_proxy<Value, Reference> use_proxy;

            return boost::iterators::detail::make_operator_brackets_result<Derived>(
                this->derived() + n
              , use_proxy()
            );
        }

        Derived& operator+=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), n);
            return this->derived();
        }

        Derived& operator-=(difference_type n)
        {
            iterator_core_access::advance(this->derived(), -n);
            return this->derived();
        }

        Derived operator-(difference_type x) const
        {
            Derived result(this->derived());
            return result -= x;
        }
    };

  }





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade :
      public detail::iterator_facade_base<
          Derived,
          Value,
          CategoryOrTraversal,
          Reference,
          Difference,
          detail::is_traversal_at_least< CategoryOrTraversal, bidirectional_traversal_tag >::value,
          detail::is_traversal_at_least< CategoryOrTraversal, random_access_traversal_tag >::value
      >
  {
  protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;
  };

  template <class I, class V, class TC, class R, class D>
  inline typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::iterators::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 900 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 930 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }




  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::iterators::detail::enable_if_interoperable_and_random_access_traversal< Derived1, Derived2 , typename mpl::apply2<boost::iterators::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value ), "( is_interoperable< Derived1, Derived2 >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived1 >::type, random_access_traversal_tag >::value && boost::iterators::detail::is_traversal_at_least< typename iterator_category< Derived2 >::type, random_access_traversal_tag >::value )"); return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 955 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




  template <class Derived, class V, class TC, class R, class D> inline typename boost::iterators::enable_if< boost::iterators::detail::is_traversal_at_least< TC, boost::iterators::random_access_traversal_tag >, Derived >::type operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }
# 972 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp"
}

using iterators::iterator_core_access;
using iterators::iterator_facade;

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 980 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_facade.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_and_derived.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_and_derived.hpp"
namespace boost {

namespace detail {
# 220 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_and_derived.hpp"
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    
# 226 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_and_derived.hpp" 3
   static const 
# 226 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_and_derived.hpp"
   bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};

}

template <class Base, class Derived> struct is_base_and_derived
   : public integral_constant<bool, (::boost::detail::is_base_and_derived_impl<Base, Derived>::value)> {};

template <class Base, class Derived> struct is_base_and_derived<Base&, Derived> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base, Derived&> : public false_type{};
template <class Base, class Derived> struct is_base_and_derived<Base&, Derived&> : public false_type{};





}
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/config.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 2





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/range_fwd.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/range_fwd.hpp"
namespace boost
{


    template<typename C, typename Enabler>
    struct range_iterator;

    template<typename C, typename Enabler>
    struct range_mutable_iterator;

    template<typename C, typename Enabler>
    struct range_const_iterator;


    template<typename IteratorT>
    class iterator_range;

    template<typename ForwardRange>
    class sub_range;


    template<typename T>
    struct range_category;

    template<typename T>
    struct range_difference;

    template<typename T>
    struct range_pointer;

    template<typename T>
    struct range_reference;

    template<typename T>
    struct range_reverse_iterator;

    template<typename T>
    struct range_size;

    template<typename T>
    struct range_value;

    template<typename T>
    struct has_range_iterator;

    template<typename T>
    struct has_range_const_iterator;

}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/extract_optional_type.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 2



#include <utility>


# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
namespace boost
{





    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 3
static const 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_iterator<C>::value > struct extract_iterator {}; template< typename C > struct extract_iterator< C, true > { typedef 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 3
typename 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
C::iterator type; };

template< typename C >
struct range_mutable_iterator
        : range_detail::extract_iterator<
            
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 3
           typename 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
                                  remove_reference<C>::type>
{};





template< typename Iterator >
struct range_mutable_iterator< std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_mutable_iterator< T[sz] >
{
    typedef T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_mutable_iterator
        : range_detail::range_mutable_iterator<
            
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 3
           typename 
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp"
                                  remove_reference<C>::type
        >
{
};

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/msvc_has_iterator_workaround.hpp" 1
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/mutable_iterator.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp"
namespace boost
{




    namespace range_detail
    {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_const_iterator { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::const_iterator>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp" 3
static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; }; template< typename C, bool B = has_const_iterator<C>::value > struct extract_const_iterator {}; template< typename C > struct extract_const_iterator< C, true > { typedef 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp" 3
typename 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp"
C::const_iterator type; };

template< typename C >
struct range_const_iterator_helper
        : extract_const_iterator<C>
{};





template< typename Iterator >
struct range_const_iterator_helper<std::pair<Iterator,Iterator> >
{
    typedef Iterator type;
};





template< typename T, std::size_t sz >
struct range_const_iterator_helper< T[sz] >
{
    typedef const T* type;
};

    }

template<typename C, typename Enabler=void>
struct range_const_iterator
        : range_detail::range_const_iterator_helper<
            
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp" 3
           typename 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/const_iterator.hpp"
                                  remove_reference<C>::type
        >
{
};

}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp" 2




namespace boost
{
# 60 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator.hpp"
    template< typename C, typename Enabler=void >
    struct range_iterator
      : mpl::if_c<
            is_const<typename remove_reference<C>::type>::value,
            range_const_iterator<typename remove_const<typename remove_reference<C>::type>::type>,
            range_mutable_iterator<typename remove_reference<C>::type>
        >::type
    {
    };



}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 2



namespace boost
{


namespace range_detail
{






    template< typename C >
    
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
   constexpr 
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                   inline 
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
                          typename 
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                                                 range_iterator<C>::type
    range_begin( C& c )
    {





        return c.begin();
    }





    template< typename Iterator >
    
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
   constexpr 
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                   inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
   constexpr 
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                   inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
    template< typename T, std::size_t sz >
    
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
   constexpr 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                   inline const T* range_begin( const T (&a)[sz] ) 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
                                                                   noexcept
    
# 77 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
   {
        return a;
    }

    template< typename T, std::size_t sz >
    
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
   constexpr 
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                   inline T* range_begin( T (&a)[sz] ) 
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
                                                       noexcept
    
# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
   {
        return a;
    }



}





namespace range_adl_barrier
{

template< class T >


# 100 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
constexpr


# 102 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
inline 
# 102 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
      typename 
# 102 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                             range_iterator<T>::type begin( T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

template< class T >


# 112 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
constexpr


# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
inline 
# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
      typename 
# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                             range_iterator<const T>::type begin( const T& r )
{

    using namespace range_detail;

    return range_begin( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        inline 
# 132 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp" 3
              typename 
# 132 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/begin.hpp"
                                     range_iterator<const T>::type
        const_begin( const T& r )
        {
            return boost::range_adl_barrier::begin( r );
        }
    }

    using namespace range_adl_barrier;
}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/sfinae.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/sfinae.hpp"
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 2
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
namespace boost
{
    namespace range_detail
    {
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_string_ = (is_const_char_ptr_ || is_const_wchar_t_ptr_);
            
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
           static const 
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
           bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef 
# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef 
# 86 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 86 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef 
# 89 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 89 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef 
# 92 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 92 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef 
# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef 
# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef 
# 104 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 104 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp" 3
                   typename 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/common.hpp"
                                                  boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 2


extern "C" {
#include <string.h>
}


extern "C" {
#include <wchar.h>
}



# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }


        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 3
       constexpr 
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
                       inline T* array_end( T (&boost_range_array)[sz] ) 
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 3
                                                                            noexcept
        
# 64 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
       {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 3
       constexpr 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
                       inline const T* array_end( const T (&boost_range_array)[sz] ) 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp" 3
                                                                                        noexcept
        
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/implementation_help.hpp"
       {
            return boost_range_array + sz;
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        inline bool is_same_address(const void* l, const void* r)
        {
            return l == r;
        }

        template<class T1, class T2>
        inline bool is_same_object(const T1& l, const T2& r)
        {
            return range_detail::is_same_address(&l, &r);
        }

    }

}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 2





namespace boost
{


namespace range_detail
{





        template< typename C >
        
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
                              typename 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                                                     range_iterator<C>::type
        range_end( C& c )
        {





            return c.end();
        }





        template< typename Iterator >
        
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        
# 64 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 64 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline const T* range_end( const T (&a)[sz] ) 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
                                                                     noexcept
        
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
       {
            return range_detail::array_end<T,sz>( a );
        }

        template< typename T, std::size_t sz >
        
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline T* range_end( T (&a)[sz] ) 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
                                                         noexcept
        
# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
       {
            return range_detail::array_end<T,sz>( a );
        }


}


namespace range_adl_barrier
{

template< class T >


# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
constexpr


# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
inline 
# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
      typename 
# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                             range_iterator<T>::type end( T& r )
{

    using namespace range_detail;

    return range_end( r );
}

template< class T >


# 106 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
constexpr


# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
inline 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
      typename 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                             range_iterator<const T>::type end( const T& r )
{

    using namespace range_detail;

    return range_end( r );
}

    }
}



namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        
# 126 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
       constexpr 
# 126 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                       inline 
# 126 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp" 3
                              typename 
# 126 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/end.hpp"
                                                     range_iterator<const T>::type
        const_end( const T& r )
        {
            return boost::range_adl_barrier::end( r );
        }
    }
    using namespace range_adl_barrier;
}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/enable_if.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/enable_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/enable_if.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/enable_if.hpp"
namespace boost
{
  template<typename T, typename R=void>
  struct enable_if_has_type
  {
    typedef R type;
  };

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/enable_if.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 2

namespace boost
{
    namespace range_detail
    {
        template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
       static const 
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
       bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };

        template<class T, class Enabler = void>
        struct has_range_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_iterator_impl<
            T,
            
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
           typename 
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                  ::boost::enable_if<
                
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
               typename 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                      mpl::eval_if<is_const<T>,
                    has_type<boost::range_const_iterator<
                                
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
                               typename 
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                                      remove_const<T>::type> >,
                    has_type<boost::range_mutable_iterator<T> >
                >::type
            >::type
        >
            : boost::mpl::true_
        {
        };

        template<class T, class Enabler = void>
        struct has_range_const_iterator_impl
            : boost::mpl::false_
        {
        };

        template<class T>
        struct has_range_const_iterator_impl<
            T,
            
# 59 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
           typename 
# 59 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                  ::boost::enable_if<
                has_type<boost::range_const_iterator<T> >
            >::type
        >
            : boost::mpl::true_
        {
        };

    }

    template<class T>
    struct has_range_iterator
        : range_detail::has_range_iterator_impl<
            
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
           typename 
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                  remove_reference<T>::type>
    {};

    template<class T>
    struct has_range_const_iterator
        : range_detail::has_range_const_iterator_impl<
            
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp" 3
           typename 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/has_range_iterator.hpp"
                                  remove_reference<T>::type>
    {};
}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp" 2



namespace boost
{
    namespace range_detail
    {
        template< class T, bool B = has_type<range_iterator<T> >::value >
        struct range_difference
        { };

        template< class T >
        struct range_difference<T, true>
          : iterator_difference<
                
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp" 3
               typename 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp"
                                      range_iterator<T>::type
            >
        { };
    }

    template< class T >
    struct range_difference
      : range_detail::range_difference<
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp" 3
                                      typename 
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/difference_type.hpp"
                                                             remove_reference<T>::type>
    { };
}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/assert.hpp" 1
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/assert.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/backward_compatibility.hpp" 1






namespace boost
{
  namespace concepts {}




}
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/has_constraints.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/has_constraints.hpp"
namespace boost { namespace concepts {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/has_constraints.hpp"
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/has_constraints.hpp" 3
   static const 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/has_constraints.hpp"
   bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes)

                                                                                      ;
    typedef boost::integral_constant<bool, value> type;
};

}}
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/conditional.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/conditional.hpp"
namespace boost {

template <bool b, class T, class U> struct conditional { typedef T type; };
template <class T, class U> struct conditional<false, T, U> { typedef U type; };



   template <bool b, class T, class U> using conditional_t = typename conditional<b, T, U>::type;



}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp" 2




namespace boost { namespace concepts {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};

struct failed {};

template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : boost::conditional<
        concepts::not_satisfied<Model>::value
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/general.hpp"
}}
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/assert.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/conversion_traits.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/usage.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/usage.hpp"
namespace boost { namespace concepts {

template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/usage.hpp"
}}
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_def.hpp" 1





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/for.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/for.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/for.hpp" 2
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/for.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/detail/for.hpp" 1
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/for.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/seq.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/seq.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/elem.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/seq.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/size.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/detail/is_empty.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/for_each_i.hpp" 2
# 7 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_def.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/enum.hpp" 1
# 8 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_def.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 2







namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check50 __attribute__((__unused__));
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check72 __attribute__((__unused__)); ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<char> {};
  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check98 __attribute__((__unused__)); ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check115 __attribute__((__unused__)); ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check137 __attribute__((__unused__)); ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check145 __attribute__((__unused__)); ~Assignable() {

      a = b;

      const_constraints(b);
    }
   private:
    void const_constraints(const TT& x) {

      a = x;



    }
   private:
    TT a;
    TT b;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check167 __attribute__((__unused__)); ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };


  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186 __attribute__((__unused__)); ~SGIAssignable() {
      TT c(a);

      a = b;

      const_constraints(b);
      ignore_unused_variable_warning(c);
    }
   private:
    void const_constraints(const TT& x) {
      TT c(x);

      a = x;

      ignore_unused_variable_warning(c);
    }
    TT a;
    TT b;
  };

  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check208 __attribute__((__unused__)); ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
# 225 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check233 __attribute__((__unused__)); ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check243 __attribute__((__unused__)); ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check253 __attribute__((__unused__)); ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
# 283 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check283 __attribute__((__unused__)); ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check285 __attribute__((__unused__)); ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check286 __attribute__((__unused__)); ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check287 __attribute__((__unused__)); ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check288 __attribute__((__unused__)); ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check290 __attribute__((__unused__)); ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check291 __attribute__((__unused__)); ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check292 __attribute__((__unused__)); ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check293 __attribute__((__unused__)); ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check294 __attribute__((__unused__)); ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check301 __attribute__((__unused__)); ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check321 __attribute__((__unused__)); ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::false_type)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::true_type)
      {
          f(arg);
      }







      UnaryFunction();


      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check351 __attribute__((__unused__)); ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::false_type)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::true_type)
      {
          f(first,second);
      }







      BinaryFunction();


      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check381 __attribute__((__unused__)); ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:






      UnaryPredicate();


    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check400 __attribute__((__unused__)); ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:






      BinaryPredicate();

    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check421 __attribute__((__unused__)); ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }






      Const_BinaryPredicate();


    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check448 __attribute__((__unused__)); ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check450 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check462 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check463 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check481 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check482 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check483 __attribute__((__unused__));
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename std::iterator_traits<TT>::value_type value_type;
      typedef typename std::iterator_traits<TT>::difference_type difference_type;
      typedef typename std::iterator_traits<TT>::reference reference;
      typedef typename std::iterator_traits<TT>::pointer pointer;
      typedef typename std::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check512 __attribute__((__unused__)); ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check514 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check515 __attribute__((__unused__));

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check529 __attribute__((__unused__)); ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check543 __attribute__((__unused__)); ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< 
# 545 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 3
         typename 
# 545 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
         ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check548 __attribute__((__unused__))


             ;

          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check561 __attribute__((__unused__)); ~Mutable_ForwardIterator() {
        *i++ = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check571 __attribute__((__unused__)); ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< 
# 573 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 3
         typename 
# 573 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
         BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check576 __attribute__((__unused__))


             ;

          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check589 __attribute__((__unused__)); ~Mutable_BidirectionalIterator()
      {
          *i-- = *j;
      }
   private:
      TT i, j;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check601 __attribute__((__unused__)); ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< 
# 603 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 3
         typename 
# 603 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp"
         BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check606 __attribute__((__unused__))


             ;

          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename std::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check626 __attribute__((__unused__)); ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename std::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check648 __attribute__((__unused__)); ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check650 __attribute__((__unused__));
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check675 __attribute__((__unused__)); ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check678 __attribute__((__unused__))
                                                                   ;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check680 __attribute__((__unused__));

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check695 __attribute__((__unused__)); ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check700 __attribute__((__unused__))


                  ;
      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check708 __attribute__((__unused__)); ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check713 __attribute__((__unused__))


                  ;
      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check724 __attribute__((__unused__)); ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check728 __attribute__((__unused__))

                                                                 ;

          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check730 __attribute__((__unused__));

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator _i = cc.rbegin();
          _i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check749 __attribute__((__unused__)); ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check752 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check753 __attribute__((__unused__));

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check768 __attribute__((__unused__)); ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check773 __attribute__((__unused__))


                 ;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check795 __attribute__((__unused__)); ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check797 __attribute__((__unused__));
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check798 __attribute__((__unused__));

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check817 __attribute__((__unused__)); ~Sequence()
      {
          S
              c(n, t),
              c2(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check852 __attribute__((__unused__)); ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check865 __attribute__((__unused__)); ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      }
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check892 __attribute__((__unused__)); ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check900 __attribute__((__unused__));

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check903 __attribute__((__unused__));
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check928 __attribute__((__unused__)); ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check946 __attribute__((__unused__)); ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check965 __attribute__((__unused__)); ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          static_assert((boost::is_same<key_type,value_type>::value), "(boost::is_same<key_type,value_type>::value)");
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check976 __attribute__((__unused__)); ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          static_assert((boost::is_same<value_type,required_value_type>::value), "(boost::is_same<value_type,required_value_type>::value)");
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check990 __attribute__((__unused__)); ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



  template < typename C > struct Collection; template < typename C > struct CollectionConcept : Collection< C > { }; template < typename C > struct Collection
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1039 __attribute__((__unused__)); ~Collection()
      {
        boost::function_requires<boost::InputIteratorConcept<iterator> >();
        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
        const_constraints(c);
        i = c.begin();
        i = c.end();
        c.swap(c);
      }

      void const_constraints(const C& cc) {
        ci = cc.begin();
        ci = cc.end();
        n = cc.size();
        b = cc.empty();
      }

    private:
      typedef typename C::value_type value_type;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef typename C::reference reference;
      typedef typename C::const_reference const_reference;

      typedef typename C::difference_type difference_type;
      typedef typename C::size_type size_type;

      C c;
      bool b;
      iterator i;
      const_iterator ci;
      size_type n;
  };
}





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_undef.hpp" 1
# 1080 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept_check.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/limits.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 2


#include <algorithm>


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_def.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 2


# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
namespace boost_concepts
{







  template < typename Iterator > struct ReadableIterator; template < typename Iterator > struct ReadableIteratorConcept : ReadableIterator< Iterator > { }; template < typename Iterator > struct ReadableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>

  {
      typedef 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
             typename 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
                                    std::iterator_traits<Iterator>::value_type value_type;
      typedef 
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
             typename 
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
                                    std::iterator_traits<Iterator>::reference reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check48 __attribute__((__unused__)); ~ReadableIterator()
      {

          value_type v = *i;
          boost::ignore_unused_variable_warning(v);
      }
  private:
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = 
# 60 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
                          typename 
# 60 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
                                                 std::iterator_traits<Iterator>::value_type
  >
  struct WritableIterator
    : boost::CopyConstructible<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check65 __attribute__((__unused__)); ~WritableIterator()
      {
          *i = v;
      }
  private:
      ValueType v;
      Iterator i;
  };

  template <
      typename Iterator
    , typename ValueType = 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
                          typename 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
                                                 std::iterator_traits<Iterator>::value_type
  >
  struct WritableIteratorConcept : WritableIterator<Iterator,ValueType> {};

  template < typename Iterator > struct SwappableIterator; template < typename Iterator > struct SwappableIteratorConcept : SwappableIterator< Iterator > { }; template < typename Iterator > struct SwappableIterator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check82 __attribute__((__unused__)); ~SwappableIterator()
      {
          std::iter_swap(i1, i2);
      }
  private:
      Iterator i1;
      Iterator i2;
  };

  template < typename Iterator > struct LvalueIterator; template < typename Iterator > struct LvalueIteratorConcept : LvalueIterator< Iterator > { }; template < typename Iterator > struct LvalueIterator
  {
      typedef typename std::iterator_traits<Iterator>::value_type value_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check95 __attribute__((__unused__)); ~LvalueIterator()
      {
        value_type& r = const_cast<value_type&>(*i);
        boost::ignore_unused_variable_warning(r);
      }
  private:
      Iterator i;
  };





  template < typename Iterator > struct IncrementableIterator; template < typename Iterator > struct IncrementableIteratorConcept : IncrementableIterator< Iterator > { }; template < typename Iterator > struct IncrementableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::iterator_traversal<Iterator>::type traversal_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< traversal_category , boost::incrementable_traversal_tag >)>::failed> boost_concept_check118 __attribute__((__unused__))



           ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check120 __attribute__((__unused__)); ~IncrementableIterator()
      {
          ++i;
          (void)i++;
      }
  private:
      Iterator i;
  };

  template < typename Iterator > struct SinglePassIterator; template < typename Iterator > struct SinglePassIteratorConcept : SinglePassIterator< Iterator > { }; template < typename Iterator > struct SinglePassIterator
    : IncrementableIterator<Iterator>
    , boost::EqualityComparable<Iterator>

  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< 
# 134 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
     typename 
# 134 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
     SinglePassIterator::traversal_category , boost::single_pass_traversal_tag > )>::failed> boost_concept_check138 __attribute__((__unused__))



              ;
  };

  template < typename Iterator > struct ForwardTraversal; template < typename Iterator > struct ForwardTraversalConcept : ForwardTraversal< Iterator > { }; template < typename Iterator > struct ForwardTraversal
    : SinglePassIterator<Iterator>
    , boost::DefaultConstructible<Iterator>
  {
      typedef typename std::iterator_traits<Iterator>::difference_type difference_type;

      enum { mpl_assertion_in_line_147 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_integral<difference_type>))0, 1 ) ) ) };
      enum { mpl_assert_rel_value148 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_148 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value148>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< 
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
     typename 
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
     ForwardTraversal::traversal_category , boost::forward_traversal_tag > )>::failed> boost_concept_check154 __attribute__((__unused__))



              ;
  };

  template < typename Iterator > struct BidirectionalTraversal; template < typename Iterator > struct BidirectionalTraversalConcept : BidirectionalTraversal< Iterator > { }; template < typename Iterator > struct BidirectionalTraversal
    : ForwardTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< 
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
     typename 
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
     BidirectionalTraversal::traversal_category , boost::bidirectional_traversal_tag > )>::failed> boost_concept_check164 __attribute__((__unused__))



              ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check166 __attribute__((__unused__)); ~BidirectionalTraversal()
      {
          --i;
          (void)i--;
      }
   private:
      Iterator i;
  };

  template < typename Iterator > struct RandomAccessTraversal; template < typename Iterator > struct RandomAccessTraversalConcept : RandomAccessTraversal< Iterator > { }; template < typename Iterator > struct RandomAccessTraversal
    : BidirectionalTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< 
# 178 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 3
     typename 
# 178 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp"
     RandomAccessTraversal::traversal_category , boost::random_access_traversal_tag > )>::failed> boost_concept_check182 __attribute__((__unused__))



              ;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check184 __attribute__((__unused__)); ~RandomAccessTraversal()
      {
          i += n;
          i = i + n;
          i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
      }

   private:
      typename BidirectionalTraversal<Iterator>::difference_type n;
      Iterator i, j;
  };




  namespace detail
  {
    template <typename Iterator1, typename Iterator2>
    void interop_single_pass_constraints(Iterator1 const& i1, Iterator2 const& i2)
    {
        bool b;
        b = i1 == i2;
        b = i1 != i2;

        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const& i1, Iterator2 const& i2,
        boost::random_access_traversal_tag, boost::random_access_traversal_tag)
    {
        bool b;
        typename std::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;

        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
    }

    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const&, Iterator2 const&,
        boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
    { }

  }

  template < typename Iterator , typename ConstIterator > struct InteroperableIterator; template < typename Iterator , typename ConstIterator > struct InteroperableIteratorConcept : InteroperableIterator< Iterator, ConstIterator > { }; template < typename Iterator , typename ConstIterator > struct InteroperableIterator
  {
   private:
      typedef typename boost::iterators::pure_iterator_traversal<Iterator>::type traversal_category;
      typedef typename boost::iterators::pure_iterator_traversal<ConstIterator>::type const_traversal_category;

   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check253 __attribute__((__unused__));
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check254 __attribute__((__unused__));

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check256 __attribute__((__unused__)); ~InteroperableIterator()
      {
          detail::interop_single_pass_constraints(i, ci);
          detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());

          ci = i;
      }

   private:
      Iterator i;
      ConstIterator ci;
  };

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/concept/detail/concept_undef.hpp" 1
# 272 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_concepts.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/value_type.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/value_type.hpp"
namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/misc_concept.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/misc_concept.hpp"
namespace boost
{
    namespace range_detail
    {
        template<typename T1, typename T2>
        class SameTypeConcept
        {
        public:
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21 __attribute__((__unused__)); ~SameTypeConcept()
            {
                same_type(a,b);
            }
        private:
            template<typename T> void same_type(T,T) {}
            T1 a;
            T2 b;
        };
    }
}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 2
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
namespace boost {

    namespace range_detail {
# 124 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
        template<class Iterator>
        struct IncrementableIteratorConcept : CopyConstructible<Iterator>
        {

            typedef 
# 128 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
                   typename 
# 128 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                          iterator_traversal<Iterator>::type traversal_category;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< traversal_category, incrementable_traversal_tag >)>::failed> boost_concept_check134 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check136 __attribute__((__unused__)); ~IncrementableIteratorConcept()
            {
                ++i;
                (void)i++;
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct SinglePassIteratorConcept
            : IncrementableIteratorConcept<Iterator>
            , EqualityComparable<Iterator>
        {

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
           typename 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
           SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag >)>::failed> boost_concept_check156 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassIteratorConcept>)>::failed> boost_concept_check158 __attribute__((__unused__)); ~SinglePassIteratorConcept()
            {
                Iterator i2(++i);
                boost::ignore_unused_variable_warning(i2);





                (void)(i++);

                
# 169 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 169 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      std::iterator_traits<Iterator>::reference r1(*i);
                boost::ignore_unused_variable_warning(r1);

                
# 172 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 172 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      std::iterator_traits<Iterator>::reference r2(*(++i));
                boost::ignore_unused_variable_warning(r2);
            }
        private:
            Iterator i;

        };

        template<class Iterator>
        struct ForwardIteratorConcept
            : SinglePassIteratorConcept<Iterator>
            , DefaultConstructible<Iterator>
        {

            typedef 
# 186 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
                   typename 
# 186 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                          std::iterator_traits<Iterator>::difference_type difference_type;

            enum { mpl_assertion_in_line_188 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_integral<difference_type>))0, 1 ) ) ) };
            enum { mpl_assert_rel_value189 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_189 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value189>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< 
# 191 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
           typename 
# 191 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
           ForwardIteratorConcept::traversal_category, forward_traversal_tag >)>::failed> boost_concept_check195 __attribute__((__unused__))



                   ;

            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIteratorConcept>)>::failed> boost_concept_check197 __attribute__((__unused__)); ~ForwardIteratorConcept()
            {




                Iterator i2(i++);
                boost::ignore_unused_variable_warning(i2);
                
# 205 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 205 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      std::iterator_traits<Iterator>::reference r(*(i++));
                boost::ignore_unused_variable_warning(r);
            }
        private:
            Iterator i;

         };

         template<class Iterator>
         struct BidirectionalIteratorConcept
             : ForwardIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< 
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
            typename 
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
            BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag >)>::failed> boost_concept_check222 __attribute__((__unused__))



                    ;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check224 __attribute__((__unused__)); ~BidirectionalIteratorConcept()
             {
                 --i;
                 (void)i--;
             }
         private:
             Iterator i;

         };

         template<class Iterator>
         struct RandomAccessIteratorConcept
             : BidirectionalIteratorConcept<Iterator>
         {

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< 
# 239 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
            typename 
# 239 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
            RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag >)>::failed> boost_concept_check243 __attribute__((__unused__))



                    ;

             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check245 __attribute__((__unused__)); ~RandomAccessIteratorConcept()
             {
                 i += n;
                 i = i + n;
                 i = n + i;
                 i -= n;
                 i = i - n;
                 n = i - j;
             }
         private:
             
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
            typename 
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                   BidirectionalIteratorConcept<Iterator>::difference_type n;
             Iterator i;
             Iterator j;

         };

    }


    template<class T>
    struct SinglePassRangeConcept
    {



        typedef 
# 270 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 270 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      remove_reference<T>::type Rng;

        typedef 
# 272 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 272 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      range_iterator<
            Rng const
        >::type const_iterator;

        typedef 
# 276 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 276 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      range_iterator<Rng>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check279 __attribute__((__unused__))
                                                                   ;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check282 __attribute__((__unused__))
                                                                         ;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check284 __attribute__((__unused__)); ~SinglePassRangeConcept()
        {



            iterator i1 = boost::begin(*m_range);
            iterator i2 = boost::end(*m_range);

            boost::ignore_unused_variable_warning(i1);
            boost::ignore_unused_variable_warning(i2);

            const_constraints(*m_range);
        }

    private:
        void const_constraints(const Rng& const_range)
        {
            const_iterator ci1 = boost::begin(const_range);
            const_iterator ci2 = boost::end(const_range);

            boost::ignore_unused_variable_warning(ci1);
            boost::ignore_unused_variable_warning(ci2);
        }





       Rng* m_range;

    };


    template<class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<
# 321 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 321 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       ForwardRangeConcept::iterator>)>::failed> boost_concept_check321 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<
# 322 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 322 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check322 __attribute__((__unused__));

    };

    template<class T>
    struct WriteableRangeConcept
    {

        typedef 
# 330 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
               typename 
# 330 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                                      range_iterator<T>::type iterator;

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check332 __attribute__((__unused__)); ~WriteableRangeConcept()
        {
            *i = v;
        }
    private:
        iterator i;
        
# 338 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 338 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
                              range_value<T>::type v;

    };


    template<class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<
# 355 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 355 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check355 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::BidirectionalIteratorConcept<
# 356 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 356 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check356 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };


    template<class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {

        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<
# 373 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 373 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check373 __attribute__((__unused__));
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::RandomAccessIteratorConcept<
# 374 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp" 3
       typename 
# 374 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/concepts.hpp"
       RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check374 __attribute__((__unused__));

    };


    template<class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };

}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp"
#include <climits>

namespace boost {







namespace detail{

template <class T>
struct is_signed_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp" 3
  static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp"
  bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};

template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};

template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_signed_impl
{
   typedef ::boost::detail::is_signed_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp" 3
  static const 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp"
  bool value = type::value;
};

}

template <class T> struct is_signed : public integral_constant<bool, boost::detail::is_signed_impl<T>::value> {};
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp"
template <> struct is_signed<signed char> : public true_type{};
template <> struct is_signed<const signed char> : public true_type{};
template <> struct is_signed<volatile signed char> : public true_type{};
template <> struct is_signed<const volatile signed char> : public true_type{};
template <> struct is_signed<short> : public true_type{};
template <> struct is_signed<const short> : public true_type{};
template <> struct is_signed<volatile short> : public true_type{};
template <> struct is_signed<const volatile short> : public true_type{};
template <> struct is_signed<int> : public true_type{};
template <> struct is_signed<const int> : public true_type{};
template <> struct is_signed<volatile int> : public true_type{};
template <> struct is_signed<const volatile int> : public true_type{};
template <> struct is_signed<long> : public true_type{};
template <> struct is_signed<const long> : public true_type{};
template <> struct is_signed<volatile long> : public true_type{};
template <> struct is_signed<const volatile long> : public true_type{};

template <> struct is_signed<unsigned char> : public false_type{};
template <> struct is_signed<const unsigned char> : public false_type{};
template <> struct is_signed<volatile unsigned char> : public false_type{};
template <> struct is_signed<const volatile unsigned char> : public false_type{};
template <> struct is_signed<unsigned short> : public false_type{};
template <> struct is_signed<const unsigned short> : public false_type{};
template <> struct is_signed<volatile unsigned short> : public false_type{};
template <> struct is_signed<const volatile unsigned short> : public false_type{};
template <> struct is_signed<unsigned int> : public false_type{};
template <> struct is_signed<const unsigned int> : public false_type{};
template <> struct is_signed<volatile unsigned int> : public false_type{};
template <> struct is_signed<const volatile unsigned int> : public false_type{};
template <> struct is_signed<unsigned long> : public false_type{};
template <> struct is_signed<const unsigned long> : public false_type{};
template <> struct is_signed<volatile unsigned long> : public false_type{};
template <> struct is_signed<const volatile unsigned long> : public false_type{};

template <> struct is_signed< ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const ::boost::long_long_type> : public true_type{};
template <> struct is_signed<volatile ::boost::long_long_type> : public true_type{};
template <> struct is_signed<const volatile ::boost::long_long_type> : public true_type{};

template <> struct is_signed< ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<volatile ::boost::ulong_long_type> : public false_type{};
template <> struct is_signed<const volatile ::boost::ulong_long_type> : public false_type{};



template <> struct is_signed<char> : public true_type{};
template <> struct is_signed<const char> : public true_type{};
template <> struct is_signed<volatile char> : public true_type{};
template <> struct is_signed<const volatile char> : public true_type{};
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_signed.hpp"
template <> struct is_signed<wchar_t> : public true_type{};
template <> struct is_signed<const wchar_t> : public true_type{};
template <> struct is_signed<volatile wchar_t> : public true_type{};
template <> struct is_signed<const volatile wchar_t> : public true_type{};







}
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
#include <climits>

namespace boost {







namespace detail{

template <class T>
struct is_unsigned_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_ununsigned_helper
{
   
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp" 3
  static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
  bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};

template <bool integral_type>
struct is_unsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};

template <>
struct is_unsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_unsigned
{
   typedef ::boost::detail::is_unsigned_select_helper< ::boost::is_integral<T>::value || ::boost::is_enum<T>::value > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp" 3
  static const 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
  bool value = type::value;
};

}

template <class T> struct is_unsigned : public integral_constant<bool, boost::detail::is_unsigned<T>::value> {};
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
template <> struct is_unsigned<unsigned char> : public true_type{};
template <> struct is_unsigned<const unsigned char> : public true_type{};
template <> struct is_unsigned<volatile unsigned char> : public true_type{};
template <> struct is_unsigned<const volatile unsigned char> : public true_type{};
template <> struct is_unsigned<unsigned short> : public true_type{};
template <> struct is_unsigned<const unsigned short> : public true_type{};
template <> struct is_unsigned<volatile unsigned short> : public true_type{};
template <> struct is_unsigned<const volatile unsigned short> : public true_type{};
template <> struct is_unsigned<unsigned int> : public true_type{};
template <> struct is_unsigned<const unsigned int> : public true_type{};
template <> struct is_unsigned<volatile unsigned int> : public true_type{};
template <> struct is_unsigned<const volatile unsigned int> : public true_type{};
template <> struct is_unsigned<unsigned long> : public true_type{};
template <> struct is_unsigned<const unsigned long> : public true_type{};
template <> struct is_unsigned<volatile unsigned long> : public true_type{};
template <> struct is_unsigned<const volatile unsigned long> : public true_type{};

template <> struct is_unsigned<signed char> : public false_type{};
template <> struct is_unsigned<const signed char> : public false_type{};
template <> struct is_unsigned<volatile signed char> : public false_type{};
template <> struct is_unsigned<const volatile signed char> : public false_type{};
template <> struct is_unsigned< short> : public false_type{};
template <> struct is_unsigned<const short> : public false_type{};
template <> struct is_unsigned<volatile short> : public false_type{};
template <> struct is_unsigned<const volatile short> : public false_type{};
template <> struct is_unsigned< int> : public false_type{};
template <> struct is_unsigned<const int> : public false_type{};
template <> struct is_unsigned<volatile int> : public false_type{};
template <> struct is_unsigned<const volatile int> : public false_type{};
template <> struct is_unsigned< long> : public false_type{};
template <> struct is_unsigned<const long> : public false_type{};
template <> struct is_unsigned<volatile long> : public false_type{};
template <> struct is_unsigned<const volatile long> : public false_type{};

template <> struct is_unsigned< ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<volatile ::boost::ulong_long_type> : public true_type{};
template <> struct is_unsigned<const volatile ::boost::ulong_long_type> : public true_type{};

template <> struct is_unsigned< ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<volatile ::boost::long_long_type> : public false_type{};
template <> struct is_unsigned<const volatile ::boost::long_long_type> : public false_type{};
# 142 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
template <> struct is_unsigned<char> : public false_type{};
template <> struct is_unsigned<const char> : public false_type{};
template <> struct is_unsigned<volatile char> : public false_type{};
template <> struct is_unsigned<const volatile char> : public false_type{};
# 155 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_unsigned.hpp"
template <> struct is_unsigned<wchar_t> : public false_type{};
template <> struct is_unsigned<const wchar_t> : public false_type{};
template <> struct is_unsigned<volatile wchar_t> : public false_type{};
template <> struct is_unsigned<const volatile wchar_t> : public false_type{};


}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp" 2






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_volatile.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_volatile.hpp"
namespace boost {
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/add_volatile.hpp"
template <class T> struct add_volatile{ typedef T volatile type; };





template <class T> struct add_volatile<T&>{ typedef T& type; };



   template <class T> using add_volatile_t = typename add_volatile<T>::type;



}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp" 2


namespace boost {

template <class T>
struct make_unsigned
{
private:
   static_assert((::boost::is_integral<T>::value || ::boost::is_enum<T>::value), "The template argument to make_unsigned must be an integer or enum type.");
   static_assert((! ::boost::is_same<typename remove_cv<T>::type, bool>::value), "The template argument to make_unsigned must not be the type bool");

   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename conditional<
      (::boost::is_unsigned<T>::value && ::boost::is_integral<T>::value
      && ! ::boost::is_same<t_no_cv, char>::value
      && ! ::boost::is_same<t_no_cv, wchar_t>::value
      && ! ::boost::is_same<t_no_cv, bool>::value),
      T,
      typename conditional<
         (::boost::is_integral<T>::value
         && ! ::boost::is_same<t_no_cv, char>::value
         && ! ::boost::is_same<t_no_cv, wchar_t>::value
         && ! ::boost::is_same<t_no_cv, bool>::value),
         typename conditional<
            is_same<t_no_cv, signed char>::value,
            unsigned char,
            typename conditional<
               is_same<t_no_cv, short>::value,
               unsigned short,
               typename conditional<
                  is_same<t_no_cv, int>::value,
                  unsigned int,
                  typename conditional<
                     is_same<t_no_cv, long>::value,
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp"
                  >::type
               >::type
            >::type
         >::type,

         typename conditional<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename conditional<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename conditional<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename conditional<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,


                     typename conditional<
                        sizeof(t_no_cv) == sizeof(boost::ulong_long_type),
                        boost::ulong_long_type,
                        boost::uint128_type
                     >::type
# 105 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_unsigned.hpp"
                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename conditional<
      is_const<T>::value,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;
public:

   typedef typename conditional<
      is_volatile<T>::value,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};



   template <class T> using make_unsigned_t = typename make_unsigned<T>::type;



}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 2




namespace boost
{
    namespace detail
    {





        template<typename T>
        class has_size_type
        {
            typedef char no_type;
            struct yes_type { char dummy[2]; };

            template<typename C>
            static yes_type test(
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 3
                                typename 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
                                                       C::size_type x);

            template<typename C>
            static no_type test(...);

        public:
            static const bool value = sizeof(test<T>(0)) == sizeof(yes_type);
        };

        template<typename C, typename Enabler=void>
        struct range_size_
        {
            typedef 
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 3
                   typename 
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
                                          make_unsigned<
                
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 3
               typename 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
                                      range_difference<C>::type
            >::type type;
        };

        template<typename C>
        struct range_size_<
            C,
            
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 3
           typename 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
                                  ::boost::enable_if<has_size_type<C>, void>::type
        >
        {
            typedef 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp" 3
                   typename 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size_type.hpp"
                                          C::size_type type;
        };

        template<typename C, bool B = range_detail::has_type< range_iterator<C> >::value>
        struct range_size
        { };

        template<typename C>
        struct range_size<C, true>
          : range_size_<C>
        { };
    }

    template< class T >
    struct range_size :
        detail::range_size<T>
    { };

}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/has_member_size.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/has_member_size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp"
       
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 3
# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 3

# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 3
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
# 387 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 3
namespace boost {
    using ::intptr_t;
    using ::uintptr_t;
}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/has_member_size.hpp" 2


# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/has_member_size.hpp"
namespace boost
{
    namespace range_detail
    {

template<class T>
class has_member_size_impl
{
private:
    template<class U, U>
    class check
    {
    };

    template<class C>
    static boost::uint8_t f(check<std::size_t(C::*)(void) const, &C::size>*);

    template<class C>
    static boost::uint16_t f(...);

public:
    static const bool value =
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t));

    typedef typename mpl::if_c<
        (sizeof(f<T>(0)) == sizeof(boost::uint8_t)),
        mpl::true_,
        mpl::false_
    >::type type;
};

template<class T>
struct has_member_size
{
    typedef typename mpl::and_<
        typename is_class<T>::type,
        typename has_member_size_impl<const T>::type
    >::type type;

    static const bool value =
        is_class<T>::value && has_member_size_impl<const T>::value;
};

    }
}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp"
extern "C" {
#include <assert.h>
}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat_from_to.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 2
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"

# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
namespace boost
{

namespace detail
{
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
template < typename T >
struct remove_cv_ref
{
    typedef typename ::boost::remove_cv<typename
     ::boost::remove_reference<T>::type>::type type;

};







template < typename T, typename U >
struct is_related
    : public ::boost::is_same<
     typename ::boost::detail::remove_cv_ref<T>::type,
     typename ::boost::detail::remove_cv_ref<U>::type >
{};
# 100 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
template<typename ...T>
struct enable_if_unrelated
    : public ::boost::enable_if_c<true>
{};

template<typename T, typename U, typename ...U2>
struct enable_if_unrelated<T, U, U2...>
    : public ::boost::disable_if< ::boost::detail::is_related<T, U> >
{};


}
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;





    template <typename ...T, typename EnableIf = typename
     ::boost::detail::enable_if_unrelated<base_from_member, T...>::type>
    explicit 
# 135 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 3
            constexpr 
# 135 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
                            base_from_member( T&& ...x )
        
# 136 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 3
       noexcept((noexcept((
# 136 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
       ::new ((void*) 0) MemberType( static_cast<T&&>(x)... )
# 136 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 3
       ))))

        
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
       : member( static_cast<T&&>(x)... )
        {}
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
};

template < typename MemberType, int UniqueID >
class base_from_member<MemberType&, UniqueID>
{
protected:
    MemberType& member;

    explicit 
# 158 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 3
            constexpr 
# 158 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
                            base_from_member( MemberType& x )
        
# 159 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp" 3
       noexcept
        
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/base_from_member.hpp"
       : member( x )
        {}

};

}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/deduce_d.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/deduce_d.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/control/deduce_d.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/cat.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/cat.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/fold_left.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/fold_left.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/fold_left.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/cat.hpp" 2
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/seq/transform.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/mod.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/mod.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/detail/div_base.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comparison/less_equal.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comparison/less_equal.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/logical/not.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/comparison/less_equal.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/preprocessor/arithmetic/mod.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/binary.hpp" 2
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/identity_type.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/identity_type.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
namespace boost {

namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 41 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  
# 52 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 52 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  
# 116 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 116 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  
# 132 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 132 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp" 3
 static const 
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/function_traits.hpp"
 unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
  public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};

}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility/identity_type.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp"
namespace boost
{



template<class T> inline void checked_delete(T * x) 
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp" 3
                                                   noexcept

# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp"
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x) 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp" 3
                                                         noexcept

# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp"
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp" 3
                                noexcept
    
# 52 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp"
   {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const 
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp" 3
                                noexcept
    
# 64 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/checked_delete.hpp"
   {
        boost::checked_array_delete(x);
    }
};

}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/noncopyable.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/noncopyable.hpp"
namespace boost {






namespace noncopyable_
{
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/noncopyable.hpp"
  struct base_token {};



  class noncopyable: base_token
  {
  protected:

      
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/noncopyable.hpp" 3
     constexpr 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/noncopyable.hpp"
                     noncopyable() = default;
      ~noncopyable() = default;





      noncopyable( const noncopyable& ) = delete;
      noncopyable& operator=( const noncopyable& ) = delete;





  };
}

typedef noncopyable_::noncopyable noncopyable;

}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/utility.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/size.hpp" 2

namespace boost
{
    namespace range_detail
    {

        template<class SinglePassRange>
        inline typename ::boost::enable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return rng.size();
        }

        template<class SinglePassRange>
        inline typename disable_if<
            has_member_size<SinglePassRange>,
            typename range_size<const SinglePassRange>::type
        >::type
        range_calculate_size(const SinglePassRange& rng)
        {
            return std::distance(boost::begin(rng), boost::end(rng));
        }
    }

    template<class SinglePassRange>
    inline typename range_size<const SinglePassRange>::type
    size(const SinglePassRange& rng)
    {





        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::SinglePassRangeConcept<SinglePassRange>)>::failed> boost_concept_check62 __attribute__((__unused__));





        using namespace range_detail;


        return range_calculate_size(rng);
    }

}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/distance.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/distance.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp"
namespace boost {
namespace iterators {

    namespace detail {
        template <typename SinglePassIterator>
        inline 
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp" 3
              constexpr 
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp"
                                    typename iterator_difference<SinglePassIterator>::type
        distance_impl(
            SinglePassIterator first
          , SinglePassIterator last
          , single_pass_traversal_tag
        )
        {
            typename iterator_difference<SinglePassIterator>::type n = 0;
            while (first != last) {
                ++first;
                ++n;
            }
            return n;
        }

        template <typename RandomAccessIterator>
        inline 
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp" 3
              constexpr 
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp"
                                    typename iterator_difference<RandomAccessIterator>::type
        distance_impl(
            RandomAccessIterator first
          , RandomAccessIterator last
          , random_access_traversal_tag
        )
        {
            return last - first;
        }
    }

    namespace distance_adl_barrier {
        template <typename SinglePassIterator>
        inline 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp" 3
              constexpr 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/distance.hpp"
                                    typename iterator_difference<SinglePassIterator>::type
        distance(SinglePassIterator first, SinglePassIterator last)
        {
            return detail::distance_impl(
                first, last, typename iterator_traversal<SinglePassIterator>::type()
            );
        }
    }

    using namespace distance_adl_barrier;

}

using namespace iterators::distance_adl_barrier;

}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/distance.hpp" 2




namespace boost
{

    namespace range_distance_adl_barrier
    {
        template< class T >
        inline 
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/distance.hpp" 3
              constexpr typename 
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/distance.hpp"
                                                           range_difference<T>::type
        distance( const T& r )
        {
            return boost::iterators::distance( boost::begin( r ), boost::end( r ) );
        }
    }

    using namespace range_distance_adl_barrier;

}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/empty.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/empty.hpp"
namespace boost
{

    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }

}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/reverse_iterator.hpp" 1
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/reverse_iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_def.hpp" 1
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp" 2



namespace boost {
namespace iterators {




  using boost::use_default;

}




template<class To>
struct is_convertible<use_default,To>
  : mpl::false_ {};

namespace iterators {

  namespace detail
  {
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp"
    struct enable_type;
  }
# 130 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp"
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::iterators::detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename boost::iterators::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename boost::iterators::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename boost::iterators::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      static_assert((is_convertible<Tr1, Tr2>::value), "(is_convertible<Tr1, Tr2>::value)");
    }
  }
# 241 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp"
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::iterators::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename boost::iterators::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::iterators::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

using iterators::iterator_adaptor;
using iterators::enable_if_convertible;

}

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/detail/config_undef.hpp" 1
# 357 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/iterator_adaptor.hpp" 2
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/reverse_iterator.hpp" 2

namespace boost {
namespace iterators {




  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;

      friend class iterator_core_access;

   public:
      reverse_iterator() {}

      explicit reverse_iterator(Iterator x)
          : super_t(x) {}

      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}

   private:
      typename super_t::reference dereference() const
      {
          Iterator it = this->base_reference();
          --it;
          return *it;
      }

      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }

      void advance(typename super_t::difference_type n)
      {
          this->base_reference() -= n;
      }

      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };

  template <class BidirectionalIterator>
  inline reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }

}

using iterators::reverse_iterator;
using iterators::make_reverse_iterator;

}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp" 2


namespace boost
{




    template< typename T >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp" 3
           typename 
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp"
                                  range_iterator<
                
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp" 3
               typename 
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/reverse_iterator.hpp"
                                      remove_reference<T>::type>::type > type;
    };


}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 2

namespace boost
{
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
template< class C >
inline 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 3
      typename 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
                             range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 3
           typename 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
                                  range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}

template< class C >
inline 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 3
      typename 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
                             range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 3
           typename 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
                                  range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}



template< class T >
inline 
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp" 3
      typename 
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rbegin.hpp"
                             range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}

}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
namespace boost
{
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
template< class C >
inline 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 3
      typename 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
                             range_reverse_iterator<C>::type
rend( C& c )
{
    typedef 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 3
           typename 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
                                  range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}

template< class C >
inline 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 3
      typename 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
                             range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 3
           typename 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
                                  range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}



template< class T >
inline 
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp" 3
      typename 
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/rend.hpp"
                             range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}

}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/functions.hpp" 2
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
namespace boost
{
    namespace range_detail
    {


        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2 >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (*first1 != *first2)
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2,
                  class BinaryPredicate >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            for (;;)
            {



                if (first1 == last1)
                    return first2 == last2;




                if (first2 == last2)
                    return false;


                if (!pred(*first1, *first2))
                    break;

                ++first1;
                ++first2;
            }



            return false;
        }



        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2 >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2);
        }

        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2, pred);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2 >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2 )
        {
            
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp" 3
           typename 
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
                                  std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            
# 139 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp" 3
           typename 
# 139 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
                                  std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, tag1, tag2);
        }

        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2,
                           BinaryPredicate pred )
        {
            
# 153 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp" 3
           typename 
# 153 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
                                  std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            
# 154 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp" 3
           typename 
# 154 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
                                  std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;

            return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
        }

    }

    namespace range
    {
# 171 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/algorithm/equal.hpp"
        template< class SinglePassRange1, class SinglePassRange2 >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2 )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check174 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check175 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2) );
        }


        template< class SinglePassRange1, class SinglePassRange2, class BinaryPredicate >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2,
                           BinaryPredicate pred )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check187 __attribute__((__unused__));
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check188 __attribute__((__unused__));

            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2),
                pred);
        }

    }
    using ::boost::range::equal;
}
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/safe_bool.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/safe_bool.hpp"
namespace boost
{
    namespace range_detail
    {

template<class DataMemberPtr>
class safe_bool
{
public:
    typedef safe_bool this_type;
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/detail/safe_bool.hpp"
    typedef DataMemberPtr unspecified_bool_type;
    static unspecified_bool_type to_unspecified_bool(const bool x, DataMemberPtr p)
    {
        return x ? p : 0;
    }

private:
    safe_bool();
    safe_bool(const safe_bool&);
    void operator=(const safe_bool&);
    ~safe_bool();
};

    }
}
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus.hpp" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
          
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_void.hpp" 1 3
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_void.hpp" 3

# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_void.hpp" 3
namespace boost {


template<class...>
struct make_void {
    typedef void type;
};


template<class... Ts>
using void_t = typename make_void<Ts...>::type;
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/make_void.hpp" 3
}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3





namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_ret_imp 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      : public boost::false_type {};

      template <class T, class U, class Ret>
      struct 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_ret_imp
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     <T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                    + 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                      std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                 + 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_void_imp 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                       : public boost::false_type {};

      template <class T, class U>
      struct 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_void_imp
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                + 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                  std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                          + 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                            std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_dc_imp 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     : public boost::false_type {};

      template <class T, class U>
      struct 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_plus_dc_imp
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                    <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                              + 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_plus 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                             : public boost::binary_op_detail:: 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                has_plus_ret_imp 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                          <T, U, Ret> {};
   template <class T, class U>
   struct 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_plus
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, void> : public boost::binary_op_detail:: 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                            has_plus_void_imp 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                       <T, U> {};
   template <class T, class U>
   struct 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_plus
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                          has_plus_dc_imp 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   <T, U> {};


}
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus_assign.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus_assign.hpp"
          
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus_assign.hpp" 3
# 52 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_plus_assign.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_plus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_plus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_plus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_plus_assign_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() += std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_plus_assign_filter_ret : public boost::binary_op_detail:: has_plus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, void> : public boost::binary_op_detail:: has_plus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_plus_assign_filter_ret<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: has_plus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool f>
      struct has_plus_assign_filter_impossible : public boost::binary_op_detail:: has_plus_assign_filter_ret <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_plus_assign_filter_impossible<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_plus_assign : public boost::binary_op_detail:: has_plus_assign_filter_impossible <T, U, Ret, boost::is_arithmetic<typename boost::remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value && !boost::is_same<bool, typename boost::remove_cv<typename remove_reference<T>::type>::type>::value> {};

}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus.hpp"
          
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus.hpp" 3
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_minus_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_minus_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_minus_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() - std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_ret_filter : public boost::binary_op_detail::has_minus_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_void_ptr_filter : public boost::binary_op_detail::has_minus_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus :
      public boost::binary_op_detail::has_minus_void_ptr_filter<
         T, U, Ret,
         boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
         || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value> {};


}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus_assign.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus_assign.hpp"
          
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus_assign.hpp" 3
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_minus_assign.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct has_minus_assign_ret_imp : public boost::false_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_imp<T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct has_minus_assign_void_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_void_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct has_minus_assign_dc_imp : public boost::false_type {};

      template <class T, class U>
      struct has_minus_assign_dc_imp<T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() -= std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

      template <class T, class U, class Ret>
      struct has_minus_assign_ret_filter : public boost::binary_op_detail::has_minus_assign_ret_imp <T, U, Ret> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, void> : public boost::binary_op_detail::has_minus_assign_void_imp <T, U> {};
      template <class T, class U>
      struct has_minus_assign_ret_filter<T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail::has_minus_assign_dc_imp <T, U> {};

      template <class T, class U, class Ret, bool b>
      struct has_minus_assign_void_ptr_filter : public boost::binary_op_detail::has_minus_assign_ret_filter <T, U, Ret> {};
      template <class T, class U, class Ret>
      struct has_minus_assign_void_ptr_filter<T, U, Ret, true> : public boost::false_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct has_minus_assign :
      public boost::binary_op_detail::has_minus_assign_void_ptr_filter<
      T, U, Ret,
      boost::is_void<typename remove_pointer<typename remove_reference<T>::type>::type>::value
      || boost::is_void<typename remove_pointer<typename remove_reference<U>::type>::type>::value
      || (boost::is_pointer<typename remove_reference<T>::type>::value && boost::is_pointer<typename remove_reference<U>::type>::value)> {};


}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"

# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"
namespace boost {
namespace iterators {

    namespace detail {
        template <typename InputIterator, typename Distance>
        inline 
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp" 3
              constexpr 
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"
                                    void
        advance_impl(
            InputIterator& it
          , Distance n
          , incrementable_traversal_tag
        )
        {
            while (n > 0) {
                ++it;
                --n;
            }
        }

        template <typename BidirectionalIterator, typename Distance>
        inline 
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp" 3
              constexpr 
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"
                                    void
        advance_impl(
            BidirectionalIterator& it
          , Distance n
          , bidirectional_traversal_tag
        )
        {
            if (n >= 0) {
                while (n > 0) {
                    ++it;
                    --n;
                }
            }
            else {
                while (n < 0) {
                    --it;
                    ++n;
                }
            }
        }

        template <typename RandomAccessIterator, typename Distance>
        inline 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp" 3
              constexpr 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"
                                    void
        advance_impl(
            RandomAccessIterator& it
          , Distance n
          , random_access_traversal_tag
        )
        {
            it += n;
        }
    }

    namespace advance_adl_barrier {
        template <typename InputIterator, typename Distance>
        inline 
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp" 3
              constexpr 
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/iterator/advance.hpp"
                                    void
        advance(InputIterator& it, Distance n)
        {
            detail::advance_impl(
                it, n, typename iterator_traversal<InputIterator>::type()
            );
        }
    }

    using namespace advance_adl_barrier;

}

using namespace iterators::advance_adl_barrier;

}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 2


namespace boost {
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp"
namespace next_prior_detail {







template< typename T, typename Void = void >
struct is_iterator_class
{
    static 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 3
          constexpr 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp"
                                   bool value = false;
};

template< typename T >
struct is_iterator_class<
    T,
    typename enable_if_has_type<

        typename std::iterator_traits< T >::iterator_category



    >::type
>
{
    static 
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 3
          constexpr 
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp"
                                   bool value = true;
};

template< typename T >
struct is_iterator :
    public is_iterator_class< T >
{
};

template< typename T >
struct is_iterator< T* >
{
    static 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp" 3
          constexpr 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/next_prior.hpp"
                                   bool value = true;
};


template< typename T, typename Distance, bool HasPlus = has_plus< T, Distance >::value >
struct next_plus_impl;

template< typename T, typename Distance >
struct next_plus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x + n;
    }
};

template< typename T, typename Distance, bool HasPlusAssign = has_plus_assign< T, Distance >::value >
struct next_plus_assign_impl :
    public next_plus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_plus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x += n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct next_advance_impl :
    public next_plus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct next_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        boost::iterators::advance(x, n);
        return x;
    }
};


template< typename T, typename Distance, bool HasMinus = has_minus< T, Distance >::value >
struct prior_minus_impl;

template< typename T, typename Distance >
struct prior_minus_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        return x - n;
    }
};

template< typename T, typename Distance, bool HasMinusAssign = has_minus_assign< T, Distance >::value >
struct prior_minus_assign_impl :
    public prior_minus_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_minus_assign_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {
        x -= n;
        return x;
    }
};

template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
struct prior_advance_impl :
    public prior_minus_assign_impl< T, Distance >
{
};

template< typename T, typename Distance >
struct prior_advance_impl< T, Distance, true >
{
    static T call(T x, Distance n)
    {

        boost::iterators::reverse_iterator< T > rx(x);
        boost::iterators::advance(rx, n);
        return rx.base();
    }
};

}

template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    return next_prior_detail::next_advance_impl< T, Distance >::call(x, n);
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    return next_prior_detail::prior_advance_impl< T, Distance >::call(x, n);
}

}
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 2
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
namespace boost
{
    namespace iterator_range_detail
    {




        template<class IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return IteratorT( boost::begin( r ) );
            }

            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return IteratorT( boost::end( r ) );
            }
        };

        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }

        template< class Left, class Right >
        inline bool greater_than( const Left& l, const Right& r )
        {
            return iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool less_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(r,l);
        }

        template< class Left, class Right >
        inline bool greater_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(l,r);
        }



        template< class Left, class Right >
        inline bool equal(const Left& l, const Right& r)
        {
            return boost::equal(l, r);
        }

struct range_tag
{
};

struct const_range_tag
{
};

struct iterator_range_tag
{
};

typedef char (&incrementable_t)[1];
typedef char (&bidirectional_t)[2];
typedef char (&random_access_t)[3];

incrementable_t test_traversal_tag(boost::incrementable_traversal_tag);
bidirectional_t test_traversal_tag(boost::bidirectional_traversal_tag);
random_access_t test_traversal_tag(boost::random_access_traversal_tag);

template<std::size_t S>
struct pure_iterator_traversal_impl
{
    typedef boost::incrementable_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(bidirectional_t)>
{
    typedef boost::bidirectional_traversal_tag type;
};

template<>
struct pure_iterator_traversal_impl<sizeof(random_access_t)>
{
    typedef boost::random_access_traversal_tag type;
};

template<typename IteratorT>
struct pure_iterator_traversal
{
    typedef
        
# 157 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
       typename 
# 157 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                              iterator_traversal<IteratorT>::type
    traversal_t;
    
# 159 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
   static const 
# 159 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
   std::size_t traversal_i = sizeof(iterator_range_detail::test_traversal_tag((traversal_t())))


     ;
    typedef
        
# 164 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
       typename 
# 164 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                              pure_iterator_traversal_impl<traversal_i>::type
    type;
};

template<class IteratorT, class TraversalTag>
class iterator_range_base
    : public iterator_range_tag
{
    typedef range_detail::safe_bool<
                IteratorT iterator_range_base<IteratorT, TraversalTag>::*
    > safe_bool_t;

    typedef iterator_range_base<IteratorT, TraversalTag> type;

protected:
    typedef iterator_range_impl<IteratorT> impl;

public:
    typedef 
# 182 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename
        
# 183 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       safe_bool_t::unspecified_bool_type unspecified_bool_type;

    typedef 
# 185 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename
        
# 186 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       iterator_value<IteratorT>::type value_type;

    typedef 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename
        
# 189 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       iterator_difference<IteratorT>::type difference_type;

    typedef std::size_t size_type;



    typedef 
# 195 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename
                
# 196 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
               iterator_reference<IteratorT>::type reference;






    typedef IteratorT const_iterator;

    typedef IteratorT iterator;

protected:
    iterator_range_base()
        : m_Begin()
        , m_End()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator Begin, Iterator End)
        : m_Begin(Begin)
        , m_End(End)
    {
    }

public:
    IteratorT begin() const
    {
        return m_Begin;
    }

    IteratorT end() const
    {
        return m_End;
    }

    bool empty() const
    {
        return m_Begin == m_End;
    }

    operator unspecified_bool_type() const
    {
        return safe_bool_t::to_unspecified_bool(
                    m_Begin != m_End, &iterator_range_base::m_Begin);
    }

    bool operator!() const
    {
        return empty();
    }

    bool equal(const iterator_range_base& r) const
    {
        return m_Begin == r.m_Begin && m_End == r.m_End;
    }

   reference front() const
   {
       
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ((
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      !empty()
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ) ? static_cast<void> (0) : __assert_fail (
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      "!empty()"
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 255, __PRETTY_FUNCTION__))
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                            ;
       return *m_Begin;
   }

   void drop_front()
   {
       
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ((
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      !empty()
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ) ? static_cast<void> (0) : __assert_fail (
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      "!empty()"
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 261, __PRETTY_FUNCTION__))
# 261 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                            ;
       ++m_Begin;
   }

   void drop_front(difference_type n)
   {
       
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ((
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      n >= difference_type()
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      ) ? static_cast<void> (0) : __assert_fail (
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
      "n >= difference_type()"
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
      , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 267, __PRETTY_FUNCTION__))
# 267 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          ;
       std::advance(this->m_Begin, n);
   }


   void pop_front() { drop_front(); }

protected:
    template<class Iterator>
    void assign(Iterator first, Iterator last)
    {
        m_Begin = first;
        m_End = last;
    }

    template<class SinglePassRange>
    void assign(const SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    template<class SinglePassRange>
    void assign(SinglePassRange& r)
    {
        m_Begin = impl::adl_begin(r);
        m_End = impl::adl_end(r);
    }

    IteratorT m_Begin;
    IteratorT m_End;
};

template<class IteratorT>
class iterator_range_base<IteratorT, bidirectional_traversal_tag>
        : public iterator_range_base<IteratorT, incrementable_traversal_tag>
{
    typedef iterator_range_base<IteratorT, incrementable_traversal_tag> base_type;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    typedef 
# 318 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 318 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::difference_type difference_type;
    typedef 
# 319 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 319 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::reference reference;

    reference back() const
    {
        
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       !this->empty()
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "!this->empty()"
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 323, __PRETTY_FUNCTION__))
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                   ;
        return *boost::prior(this->m_End);
    }

    void drop_back()
    {
        
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       !this->empty()
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "!this->empty()"
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 329, __PRETTY_FUNCTION__))
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                   ;
        --this->m_End;
    }

    void drop_back(difference_type n)
    {
        
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       n >= difference_type()
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "n >= difference_type()"
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 335, __PRETTY_FUNCTION__))
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                           ;
        std::advance(this->m_End, -n);
    }


    void pop_back() { drop_back(); }
};

template<class IteratorT>
class iterator_range_base<IteratorT, random_access_traversal_tag>
        : public iterator_range_base<IteratorT, bidirectional_traversal_tag>
{
    typedef iterator_range_base<
                IteratorT, bidirectional_traversal_tag> base_type;

public:
    typedef 
# 351 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename
        
# 352 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       boost::mpl::if_<
            boost::mpl::or_<
                boost::is_abstract<
                    
# 355 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 355 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          base_type::value_type
                >,
                boost::is_array<
                    
# 358 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 358 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          base_type::value_type
                >,
                boost::is_function<
                    
# 361 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 361 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          base_type::value_type
                >
            >,
            
# 364 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 364 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::reference,
            
# 365 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 365 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::value_type
        >::type abstract_value_type;




    typedef 
# 371 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 371 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::difference_type difference_type;
    typedef 
# 372 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 372 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::size_type size_type;
    typedef 
# 373 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
           typename 
# 373 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                  base_type::reference reference;

protected:
    iterator_range_base()
    {
    }

    template<class Iterator>
    iterator_range_base(Iterator first, Iterator last)
        : base_type(first, last)
    {
    }

public:
    reference operator[](difference_type at) const
    {
        
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       at >= 0
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "at >= 0"
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 389, __PRETTY_FUNCTION__))
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                            ;
        
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       static_cast<typename base_type::size_type>(at) < size()
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "static_cast<typename base_type::size_type>(at) < size()"
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 390, __PRETTY_FUNCTION__))
# 390 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                                            ;
        return this->m_Begin[at];
    }






    abstract_value_type operator()(difference_type at) const
    {
        
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       at >= 0
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "at >= 0"
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 401, __PRETTY_FUNCTION__))
# 401 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                            ;
        
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ((
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       static_cast<typename base_type::size_type>(at) < size()
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
       "static_cast<typename base_type::size_type>(at) < size()"
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3 4
       , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp", 402, __PRETTY_FUNCTION__))
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                                            ;
        return this->m_Begin[at];
    }

    
# 406 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
   typename 
# 406 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                          base_type::size_type size() const
    {
        return this->m_End - this->m_Begin;
    }
};

    }
# 433 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
        template<class IteratorT>
        class iterator_range
            : public iterator_range_detail::iterator_range_base<
                    IteratorT,
                    
# 437 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 437 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          iterator_range_detail::pure_iterator_traversal<IteratorT>::type
                >
        {
            typedef iterator_range_detail::iterator_range_base<
                    IteratorT,
                    
# 442 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 442 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          iterator_range_detail::pure_iterator_traversal<IteratorT>::type
            > base_type;

            template<class Source>
            struct is_compatible_range_
              : is_convertible<
                    
# 448 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 448 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          mpl::eval_if<
                        has_range_iterator<Source>,
                        range_iterator<Source>,
                        mpl::identity<void>
                    >::type,
                    
# 453 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 453 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          base_type::iterator
                >
            {
            };

            template<class Source>
            struct is_compatible_range
                : mpl::and_<
                    mpl::not_<
                        is_convertible<
                            Source,
                            
# 464 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                           typename 
# 464 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                  base_type::iterator
                        >
                    >,
                    is_compatible_range_<Source>
                >
            {
            };

        protected:
            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;

        public:
            typedef iterator_range<IteratorT> type;

            iterator_range()
            {
            }

            template<class Iterator>
            iterator_range(Iterator first, Iterator last)
                : base_type(first, last)
            {
            }

            template<class SinglePassRange>
            iterator_range(
                const SinglePassRange& r,
                
# 491 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
               typename 
# 491 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                      ::boost::enable_if<
                    is_compatible_range<const SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(
                SinglePassRange& r,
                
# 502 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
               typename 
# 502 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                      ::boost::enable_if<
                    is_compatible_range<SinglePassRange>
                >::type* = 0
            )
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(const SinglePassRange& r,
                           iterator_range_detail::const_range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class SinglePassRange>
            iterator_range(SinglePassRange& r,
                           iterator_range_detail::range_tag)
                : base_type(impl::adl_begin(r), impl::adl_end(r))
            {
            }

            template<class Iterator>
            iterator_range& operator=(const iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class Iterator>
            iterator_range& operator=(iterator_range<Iterator>& other)
            {
                this->assign(other.begin(), other.end());
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            template<class SinglePassRange>
            iterator_range& operator=(const SinglePassRange& r)
            {
                this->assign(r);
                return *this;
            }

            iterator_range& advance_begin(
                
# 553 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
               typename 
# 553 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                      base_type::difference_type n)
            {
                std::advance(this->m_Begin, n);
                return *this;
            }

            iterator_range& advance_end(
                
# 560 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
               typename 
# 560 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                      base_type::difference_type n)
            {
                std::advance(this->m_End, n);
                return *this;
            }

        protected:




            typedef iterator_range iterator_range_;
        };







        template< class IteratorT, class ForwardRange >
        inline 
# 581 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 581 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 591 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 591 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 601 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 601 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 611 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 611 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 621 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 621 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 631 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 631 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const ForwardRange& l, const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }



        template< class Iterator1T, class Iterator2T >
        inline bool
        operator==( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 650 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 650 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator==( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator!=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return !boost::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 668 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 668 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator!=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return !boost::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator<=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 703 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 703 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator<=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 720 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 720 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }

        template< class Iterator1T, class Iterator2T >
        inline bool
        operator>=( const iterator_range<Iterator1T>& l, const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline 
# 737 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
              typename 
# 737 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                     boost::enable_if<
            mpl::not_<boost::is_base_and_derived<iterator_range_detail::iterator_range_tag, ForwardRange> >,
            bool
        >::type
        operator>=( const iterator_range<IteratorT>& l, const ForwardRange& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
# 758 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }

        template<typename IteratorT, typename IntegerT>
        inline iterator_range<IteratorT>
        make_iterator_range_n(IteratorT first, IntegerT n)
        {
            return iterator_range<IteratorT>(first, boost::next(first, n));
        }
# 788 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
        template< class ForwardRange >
        inline iterator_range< 
# 789 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                              typename 
# 789 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                     range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< 
# 792 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                                 typename 
# 792 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                        range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }

        template< class ForwardRange >
        inline iterator_range< 
# 797 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                              typename 
# 797 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                     range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< 
# 800 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                                 typename 
# 800 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                        range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }



        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< 
# 809 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                                  typename 
# 809 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                         range_iterator<Range>::type >
            make_range_impl( Range& r,
                             
# 811 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                            typename 
# 811 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                   range_difference<Range>::type advance_begin,
                             
# 812 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                            typename 
# 812 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                   range_difference<Range>::type advance_end )
            {







                
# 821 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
               typename 
# 821 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                      range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
# 843 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
        template< class Range >
        inline iterator_range< 
# 844 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                              typename 
# 844 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                     range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    
# 846 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 846 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          range_difference<Range>::type advance_begin,
                    
# 847 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 847 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }

        template< class Range >
        inline iterator_range< 
# 853 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                              typename 
# 853 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                                     range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    
# 855 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 855 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          range_difference<Range>::type advance_begin,
                    
# 856 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp" 3
                   typename 
# 856 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
                                          range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
# 871 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/range/iterator_range_core.hpp"
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }

}
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
          




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp" 1
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
namespace boost { template <class T> class shared_ptr; }
namespace boost { namespace exception_detail { using boost::shared_ptr; } }



       
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3






# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    class
    
# 147 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
   __attribute__((__visibility__("default")))
    
# 148 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
   exception;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        template <class>
        struct set_info_rv;

        template <>
        struct set_info_rv<throw_function>;

        template <>
        struct set_info_rv<throw_file>;

        template <>
        struct set_info_rv<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }

    class
    
# 215 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
   __attribute__((__visibility__("default")))
    
# 216 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
   exception
        {

        public:
        template <class Tag> void set( typename Tag::type const & );
        template <class Tag> typename Tag::type const * get() const;


        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 245 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        template <class>
        friend struct exception_detail::set_info_rv;
        friend struct exception_detail::set_info_rv<throw_function>;
        friend struct exception_detail::set_info_rv<throw_file>;
        friend struct exception_detail::set_info_rv<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };

    inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {
        template <class T>
        struct
        
# 329 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
       __attribute__((__visibility__("default")))
        
# 330 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
       error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {
        class
        
# 392 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
       __attribute__((__visibility__("default")))
        
# 393 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
       clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };

        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        
# 427 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
       __attribute__((__visibility__("default")))
        
# 428 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
       clone_impl:
            public T,
            public virtual clone_base
            {
            struct clone_tag { };
            clone_impl( clone_impl const & x, clone_tag ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this,clone_tag());
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }

    template <class T>
    struct
    
# 478 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp"
   __attribute__((__visibility__("default")))
    
# 479 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/exception/exception.hpp" 3
   wrapexcept:
        public exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type>
        {
        typedef exception_detail::clone_impl<typename exception_detail::enable_error_info_return_type<T>::type> base_type;
        public:
        explicit
        wrapexcept( typename exception_detail::enable_error_info_return_type<T>::type const & x ):
            base_type( x )
            {
            }

        ~wrapexcept() throw()
            {
            }
        };

    namespace
    exception_detail
        {
        template <class T>
        struct
        remove_error_info_injector
            {
            typedef T type;
            };

        template <class T>
        struct
        remove_error_info_injector< error_info_injector<T> >
            {
            typedef T type;
            };

        template <class T>
        inline
        wrapexcept<typename remove_error_info_injector<T>::type>
        enable_both( T const & x )
            {
            return wrapexcept<typename remove_error_info_injector<T>::type>( enable_error_info( x ) );
            }
        }
    }
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/current_function.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/current_function.hpp"

# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/current_function.hpp"
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/current_function.hpp"
}

}

}
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp" 2
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp"
       
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp" 3






# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/throw_exception.hpp" 3
namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__ ((__noreturn__)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw exception_detail::enable_both( e );



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__ ((__noreturn__))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 2


# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
namespace boost
{

    class __attribute__((__visibility__("default"))) bad_lexical_cast :




        public std::bad_cast







    {
    public:
        bad_lexical_cast() 
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                          noexcept

           
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
          : source(&typeid(void)), target(&typeid(void))

        {}

        virtual const char *what() const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                                        noexcept 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
                                                                  {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }

        virtual ~bad_lexical_cast() 
# 59 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                                   noexcept
        
# 60 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
       {}


        bad_lexical_cast(
                const std::type_info &source_type_arg,
                const std::type_info &target_type_arg) 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                                                      noexcept
            
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
           : source(&source_type_arg), target(&target_type_arg)
        {}

        const std::type_info &source_type() const 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                                                 noexcept 
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
                                                                {
            return *source;
        }

        const std::type_info &target_type() const 
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp" 3
                                                 noexcept 
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/bad_lexical_cast.hpp"
                                                                {
            return *target;
        }

    private:
        const std::type_info *source;
        const std::type_info *target;

    };

    namespace conversion { namespace detail {






        template <class S, class T>
        inline void throw_bad_cast() {
            boost::throw_exception(bad_lexical_cast(typeid(S), typeid(T)));
        }

    }}


}
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
          





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wsign-conversion"





# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/type_identity.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/type_identity.hpp"
namespace boost
{

template<class T> struct type_identity
{
    typedef T type;
};



template <class T> using type_identity_t = typename type_identity<T>::type;




}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp"
          





namespace boost {

    namespace detail
    {

        template < typename T >
        struct is_character
        {
            typedef 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp" 3
                   typename 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp"
                                          boost::integral_constant<
              bool,
              boost::is_same< T, char >::value ||

                        boost::is_same< T, wchar_t >::value ||


                        boost::is_same< T, char16_t >::value ||


                        boost::is_same< T, char32_t >::value ||

                    boost::is_same< T, unsigned char >::value ||
                    boost::is_same< T, signed char >::value
            > type;

            
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp" 3
           static const 
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/is_character.hpp"
           bool value = (type::value);
        };
    }
}
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
          
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_of.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_of.hpp"
namespace boost {

   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_of.hpp" 3
         static const 
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_base_of.hpp"
         bool value = ( (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value) || (::boost::is_same<ncvB,ncvD>::value && ::boost::is_class<ncvB>::value))

                                                                                    ;
      };
   }

   template <class Base, class Derived> struct is_base_of
      : public integral_constant<bool, (::boost::detail::is_base_of_imp<Base, Derived>::value)> {};

   template <class Base, class Derived> struct is_base_of<Base, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived&> : false_type{};
   template <class Base, class Derived> struct is_base_of<Base&, Derived> : false_type{};

}
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_float.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/is_float.hpp"
namespace boost {


   template <class T> struct is_float : public is_floating_point<T> {};
}
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/cast.hpp" 1
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/cast.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type.hpp"
namespace boost {



  template <class T>
  struct type {};

}
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/cast.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/conversion_traits.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/conversion_traits.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/equal_to.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/equal_to.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/numeric_cast.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/numeric_cast.hpp"
namespace boost { namespace mpl {



template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};

}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/tag.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/tag.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_tag.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_tag.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_tag.hpp" 3
static const 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_tag.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/tag.hpp" 2


namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/tag.hpp"
};

}}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/forwarding.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2

namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp"
    };
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_cast_utils.hpp"
    };
};

}}}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_eti_base.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_eti_base.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/is_msvc_eti_arg.hpp"
namespace boost { namespace mpl { namespace aux {
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/is_msvc_eti_arg.hpp"
}}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_eti_base.hpp" 2




namespace boost { namespace mpl { namespace aux {
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_eti_base.hpp"
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
       int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
       int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp"
       int value = 0;
    };
};

template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to

    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value == N2::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/equal_to.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp" 2





namespace boost { namespace numeric { namespace convdetail
{
   template< class T1, class T2>
   struct equal_to
   {


       enum { x = ( T1::value == T2::value ) };

       
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp" 3
      static const 
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp"
      bool value = x;

       typedef mpl::bool_<value> type;
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp"
   };
# 59 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp"
  template<class Value,
           class Case0Val,
           class Case1Val,
           class Case2Val,
           class Case0Type,
           class Case1Type,
           class Case2Type,
           class DefaultType
          >
  struct ct_switch4
  {
    typedef mpl::identity<Case0Type> Case0TypeQ ;
    typedef mpl::identity<Case1Type> Case1TypeQ ;

    typedef equal_to<Value,Case0Val> is_case0 ;
    typedef equal_to<Value,Case1Val> is_case1 ;
    typedef equal_to<Value,Case2Val> is_case2 ;

    typedef mpl::if_<is_case2,Case2Type,DefaultType> choose_2_3Q ;
    typedef mpl::eval_if<is_case1,Case1TypeQ,choose_2_3Q> choose_1_2_3Q ;

    typedef typename
      mpl::eval_if<is_case0,Case0TypeQ,choose_1_2_3Q>::type
        type ;
  } ;
# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/meta.hpp"
  template<class expr0, class expr1, class TT, class TF, class FT, class FF>
  struct for_both
  {
    typedef mpl::identity<TF> TF_Q ;
    typedef mpl::identity<TT> TT_Q ;

    typedef typename mpl::not_<expr0>::type not_expr0 ;
    typedef typename mpl::not_<expr1>::type not_expr1 ;

    typedef typename mpl::and_<expr0,expr1>::type caseTT ;
    typedef typename mpl::and_<expr0,not_expr1>::type caseTF ;
    typedef typename mpl::and_<not_expr0,expr1>::type caseFT ;

    typedef mpl::if_<caseFT,FT,FF> choose_FT_FF_Q ;
    typedef mpl::eval_if<caseTF,TF_Q,choose_FT_FF_Q> choose_TF_FT_FF_Q ;

    typedef typename mpl::eval_if<caseTT,TT_Q,choose_TF_FT_FF_Q>::type type ;
  } ;

} } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/int_float_mixture.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/int_float_mixture_enum.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/int_float_mixture_enum.hpp"
namespace boost { namespace numeric
{
  enum int_float_mixture_enum
  {
     integral_to_integral
    ,integral_to_float
    ,float_to_integral
    ,float_to_float
  } ;

} }
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_fwd.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c_fwd.hpp"
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
   T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   constexpr 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
                   operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp" 2




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp" 3
   static const 
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/integral_c.hpp"
   bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/int_float_mixture.hpp" 2

namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<int_float_mixture_enum, integral_to_integral> int2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, integral_to_float> int2float_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_integral> float2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_float> float2float_c ;







  template<class T,class S>
  struct get_int_float_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_integer > S_int ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_integer > T_int ;

    typedef typename
      for_both<S_int, T_int, int2int_c, int2float_c, float2int_c, float2float_c>::type
        type ;
  } ;
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/int_float_mixture.hpp"
  template<class IntFloatMixture, class Int2Int, class Int2Float, class Float2Int, class Float2Float>
  struct for_int_float_mixture
  {
    typedef typename
      ct_switch4<IntFloatMixture
                 ,int2int_c, int2float_c, float2int_c
                 ,Int2Int , Int2Float , Float2Int , Float2Float
                >::type
        type ;
  } ;

} } }
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/sign_mixture.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/sign_mixture.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/sign_mixture_enum.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/sign_mixture_enum.hpp"
namespace boost { namespace numeric
{
  enum sign_mixture_enum
  {
     unsigned_to_unsigned
    ,signed_to_signed
    ,signed_to_unsigned
    ,unsigned_to_signed
  } ;

} }
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/sign_mixture.hpp" 2




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_unsigned> unsig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_signed> sig2sig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_unsigned> sig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_signed> unsig2sig_c ;







  template<class T,class S>
  struct get_sign_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_signed > S_signed ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_signed > T_signed ;

    typedef typename
      for_both<S_signed, T_signed, sig2sig_c, sig2unsig_c, unsig2sig_c, unsig2unsig_c>::type
        type ;
  } ;
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/sign_mixture.hpp"
  template<class SignMixture, class Sig2Sig, class Sig2Unsig, class Unsig2Sig, class Unsig2Unsig>
  struct for_sign_mixture
  {
    typedef typename
      ct_switch4<SignMixture
                 , sig2sig_c, sig2unsig_c, unsig2sig_c
                 , Sig2Sig , Sig2Unsig , Unsig2Sig , Unsig2Unsig
                >::type
        type ;
  } ;

} } }
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/udt_builtin_mixture_enum.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/udt_builtin_mixture_enum.hpp"
namespace boost { namespace numeric
{
  enum udt_builtin_mixture_enum
  {
     builtin_to_builtin
    ,builtin_to_udt
    ,udt_to_builtin
    ,udt_to_udt
  } ;

} }
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp" 2




namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_builtin> builtin2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_udt> builtin2udt_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_builtin> udt2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_udt> udt2udt_c ;
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/udt_builtin_mixture.hpp"
  template<class UdtMixture, class BuiltIn2BuiltIn, class BuiltIn2Udt, class Udt2BuiltIn, class Udt2Udt>
  struct for_udt_builtin_mixture
  {
    typedef typename
      ct_switch4<UdtMixture
                 , builtin2builtin_c, builtin2udt_c, udt2builtin_c
                 , BuiltIn2BuiltIn , BuiltIn2Udt , Udt2BuiltIn , Udt2Udt
                >::type
        type ;
  } ;







  template<class T,class S>
  struct get_udt_builtin_mixture
  {
    typedef is_arithmetic<S> S_builtin ;
    typedef is_arithmetic<T> T_builtin ;

    typedef typename
      for_both<S_builtin, T_builtin, builtin2builtin_c, builtin2udt_c, udt2builtin_c, udt2udt_c>::type
        type ;
  } ;

} } }
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/multiplies.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/multiplies.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/times.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/times.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/largest_int.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/largest_int.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct integral_rank;

template<> struct integral_rank<bool> : int_<1> {};
template<> struct integral_rank<signed char> : int_<2> {};
template<> struct integral_rank<char> : int_<3> {};
template<> struct integral_rank<unsigned char> : int_<4> {};

template<> struct integral_rank<wchar_t> : int_<5> {};

template<> struct integral_rank<short> : int_<6> {};
template<> struct integral_rank<unsigned short> : int_<7> {};
template<> struct integral_rank<int> : int_<8> {};
template<> struct integral_rank<unsigned int> : int_<9> {};
template<> struct integral_rank<long> : int_<10> {};
template<> struct integral_rank<unsigned long> : int_<11> {};


template<> struct integral_rank<long_long_type> : int_<12> {};
template<> struct integral_rank<ulong_long_type>: int_<13> {};


template< typename T1, typename T2 > struct largest_int

    : if_c<
          ( integral_rank<T1>::value >= integral_rank<T2>::value )
        , T1
        , T2
        >
{






};

}}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct times_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< times_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< times_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct times_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp"
       int value = 0;
    };
};

template< typename Tag > struct times_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp"
       int value = 0;
    };
};

template< typename Tag > struct times_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/times.hpp"
       int value = 0;
    };
};

template< typename T > struct times_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct times
    : times< times< times< times< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct times< N1,N2,N3,N4,na >

    : times< times< times< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct times< N1,N2,N3,na,na >

    : times< times< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct times< N1,N2,na,na,na >
    : times_impl<
          typename times_tag<N1>::type
        , typename times_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct times< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : times< T1 , T2 > { }; }; template< typename Tag > struct lambda< times< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef times< na , na > result_; typedef times< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< times< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< times< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct times_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  * N2::value
                )
            >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/times.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/multiplies.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/multiplies.hpp"
namespace boost { namespace mpl {







template<
      typename N1 = na , typename N2 = na , typename N3 = na , typename N4 = na , typename N5 = na
    >
struct multiplies
    : times< N1 , N2 , N3 , N4 , N5 >
{
   




};

template<> struct multiplies< na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct apply : multiplies< T1 , T2 , T3 , T4 , T5 > { }; }; template< typename Tag > struct lambda< multiplies< na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef multiplies< na , na , na , na , na > result_; typedef multiplies< na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< multiplies< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< multiplies< na , na , na , na , na > > : int_<-1> { }; }



}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp"
       int value = 0;
    };
};

template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp"
       int value = 0;
    };
};

template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less.hpp"
       int value = 0;
    };
};

template< typename T > struct less_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less

    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N2::value > N1::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp"
namespace boost { namespace numeric { namespace convdetail
{





    template<class T,class S>
    struct subranged_Sig2Unsig
    {


      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Unsig2Sig
    {
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/is_subranged.hpp"
       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;


       typedef typename T_digits::next u_T_digits ;

       typedef mpl::int_<2> Two ;

       typedef typename mpl::multiplies<S_digits,Two>::type S_digits_times_2 ;

       typedef typename mpl::less<u_T_digits,S_digits_times_2>::type type ;
    } ;


    template<class T,class S>
    struct subranged_SameSign
    {


       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;

       typedef typename mpl::less<T_digits,S_digits>::type type ;
    } ;


    template<class T,class S>
    struct subranged_Int2Float
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Int
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_Float2Float
    {



      typedef mpl::int_< ::std::numeric_limits<S>::digits > S_mantisa ;
      typedef mpl::int_< ::std::numeric_limits<T>::digits > T_mantisa ;

      typedef mpl::int_< ::std::numeric_limits<S>::max_exponent > S_exponent ;
      typedef mpl::int_< ::std::numeric_limits<T>::max_exponent > T_exponent ;

      typedef typename mpl::less<T_exponent,S_exponent>::type T_smaller_exponent ;

      typedef typename mpl::equal_to<T_exponent,S_exponent>::type equal_exponents ;

      typedef mpl::less<T_mantisa,S_mantisa> T_smaller_mantisa ;

      typedef mpl::eval_if<equal_exponents,T_smaller_mantisa,mpl::false_> not_bigger_exponent_case ;

      typedef typename
        mpl::eval_if<T_smaller_exponent,mpl::true_,not_bigger_exponent_case>::type
          type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2BuiltIn
    {
      typedef mpl::true_ type ;
    } ;


    template<class T,class S>
    struct subranged_BuiltIn2Udt
    {
      typedef mpl::false_ type ;
    } ;


    template<class T,class S>
    struct subranged_Udt2Udt
    {
      typedef mpl::false_ type ;
    } ;





    template<class T,class S>
    struct get_subranged_Int2Int
    {
      typedef subranged_SameSign<T,S> Sig2Sig ;
      typedef subranged_Sig2Unsig<T,S> Sig2Unsig ;
      typedef subranged_Unsig2Sig<T,S> Unsig2Sig ;
      typedef Sig2Sig Unsig2Unsig ;

      typedef typename get_sign_mixture<T,S>::type sign_mixture ;

      typedef typename
        for_sign_mixture<sign_mixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
           type ;
    } ;

    template<class T,class S>
    struct get_subranged_BuiltIn2BuiltIn
    {
      typedef get_subranged_Int2Int<T,S> Int2IntQ ;

      typedef subranged_Int2Float <T,S> Int2Float ;
      typedef subranged_Float2Int <T,S> Float2Int ;
      typedef subranged_Float2Float<T,S> Float2Float ;

      typedef mpl::identity<Int2Float > Int2FloatQ ;
      typedef mpl::identity<Float2Int > Float2IntQ ;
      typedef mpl::identity<Float2Float> Float2FloatQ ;

      typedef typename get_int_float_mixture<T,S>::type int_float_mixture ;

      typedef for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ> for_ ;

      typedef typename for_::type selected ;

      typedef typename selected::type type ;
    } ;

    template<class T,class S>
    struct get_subranged
    {
      typedef get_subranged_BuiltIn2BuiltIn<T,S> BuiltIn2BuiltInQ ;

      typedef subranged_BuiltIn2Udt<T,S> BuiltIn2Udt ;
      typedef subranged_Udt2BuiltIn<T,S> Udt2BuiltIn ;
      typedef subranged_Udt2Udt<T,S> Udt2Udt ;

      typedef mpl::identity<BuiltIn2Udt> BuiltIn2UdtQ ;
      typedef mpl::identity<Udt2BuiltIn> Udt2BuiltInQ ;
      typedef mpl::identity<Udt2Udt > Udt2UdtQ ;

      typedef typename get_udt_builtin_mixture<T,S>::type udt_builtin_mixture ;

      typedef typename
        for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, BuiltIn2UdtQ, Udt2BuiltInQ, Udt2UdtQ>::type
          selected ;

      typedef typename selected::type selected2 ;

      typedef typename selected2::type type ;
    } ;





  template<class T, class S>
  struct get_is_subranged
  {
    typedef get_subranged<T,S> non_trivial_case ;
    typedef mpl::identity<mpl::false_> trivial_case ;

    typedef is_same<T,S> is_trivial ;

    typedef typename mpl::if_<is_trivial,trivial_case,non_trivial_case>::type selected ;

    typedef typename selected::type type ;
  } ;

} } }
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/conversion_traits.hpp" 2

namespace boost { namespace numeric { namespace convdetail
{





  template<class T,class S>
  struct non_trivial_traits_impl
  {
    typedef typename get_int_float_mixture <T,S>::type int_float_mixture ;
    typedef typename get_sign_mixture <T,S>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture <T,S>::type udt_builtin_mixture ;

    typedef typename get_is_subranged<T,S>::type subranged ;

    typedef mpl::false_ trivial ;

    typedef T target_type ;
    typedef S source_type ;
    typedef T result_type ;

    typedef typename mpl::if_< is_arithmetic<S>, S, S const&>::type argument_type ;

    typedef typename mpl::if_<subranged,S,T>::type supertype ;
    typedef typename mpl::if_<subranged,T,S>::type subtype ;
  } ;






  template<class N>
  struct trivial_traits_impl
  {
    typedef typename get_int_float_mixture <N,N>::type int_float_mixture ;
    typedef typename get_sign_mixture <N,N>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture<N,N>::type udt_builtin_mixture ;

    typedef mpl::false_ subranged ;
    typedef mpl::true_ trivial ;

    typedef N target_type ;
    typedef N source_type ;
    typedef N const& result_type ;
    typedef N const& argument_type ;

    typedef N supertype ;
    typedef N subtype ;

  } ;




  template<class T, class S>
  struct get_conversion_traits
  {
    typedef typename remove_cv<T>::type target_type ;
    typedef typename remove_cv<S>::type source_type ;

    typedef typename is_same<target_type,source_type>::type is_trivial ;

    typedef trivial_traits_impl <target_type> trivial_imp ;
    typedef non_trivial_traits_impl<target_type,source_type> non_trivial_imp ;

    typedef typename mpl::if_<is_trivial,trivial_imp,non_trivial_imp>::type type ;
  } ;

} } }
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/conversion_traits.hpp" 2



namespace boost { namespace numeric
{

template<class T, class S>
struct conversion_traits
    : convdetail::get_conversion_traits<T,S>::type
{
} ;

} }
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter_policies.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter_policies.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/no_tr1/cmath.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/no_tr1/cmath.hpp"
#include <cmath>
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter_policies.hpp" 2


#include <functional>







# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter_policies.hpp"
namespace boost { namespace numeric
{

template<class S>
struct Trunc
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;
    using std::ceil ;


    return s < static_cast<S>(0) ? ceil(s) : floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_zero> round_style ;
} ;



template<class S>
struct Floor
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::floor ;


    return floor(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_neg_infinity> round_style ;
} ;

template<class S>
struct Ceil
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {

    using std::ceil ;


    return ceil(s) ;
  }

  typedef mpl::integral_c< std::float_round_style, std::round_toward_infinity> round_style ;
} ;

template<class S>
struct RoundEven
{
  typedef S source_type ;

  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;

  static source_type nearbyint ( argument_type s )
  {



    using std::floor ;
    using std::ceil ;



    S prev = floor(s);
    S next = ceil(s);

    S rt = (s - prev) - (next - s);

    S const zero(0.0);
    S const two(2.0);

    if ( rt < zero )
      return prev;
    else if ( rt > zero )
      return next;
    else
    {
      bool is_prev_even = two * floor(prev / two) == prev ;
      return ( is_prev_even ? prev : next ) ;
    }
  }

  typedef mpl::integral_c< std::float_round_style, std::round_to_nearest> round_style ;
} ;


enum range_check_result
{
  cInRange = 0 ,
  cNegOverflow = 1 ,
  cPosOverflow = 2
} ;

class bad_numeric_cast : public std::bad_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: overflow"; }
};

class negative_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: negative overflow"; }
};
class positive_overflow : public bad_numeric_cast
{
  public:

    virtual const char * what() const throw()
      { return "bad numeric conversion: positive overflow"; }
};

struct def_overflow_handler
{
  void operator() ( range_check_result r )
  {

    if ( r == cNegOverflow )
      throw negative_overflow() ;
    else if ( r == cPosOverflow )
           throw positive_overflow() ;






  }
} ;

struct silent_overflow_handler
{
  void operator() ( range_check_result ) {}
} ;

template<class Traits>
struct raw_converter
{
  typedef typename Traits::result_type result_type ;
  typedef typename Traits::argument_type argument_type ;

  static result_type low_level_convert ( argument_type s ) { return static_cast<result_type>(s) ; }
} ;

struct UseInternalRangeChecker {} ;

} }
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/bounds.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/bounds.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/bounds.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/bounds.hpp"
namespace boost { namespace numeric { namespace boundsdetail
{
  template<class N>
  class Integral
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return limits::min (); }
      static N highest () { return limits::max (); }
      static N smallest() { return static_cast<N>(1); }
  } ;

  template<class N>
  class Float
  {
      typedef std::numeric_limits<N> limits ;

    public :

      static N lowest () { return static_cast<N>(-limits::max ()) ; }
      static N highest () { return limits::max (); }
      static N smallest() { return limits::min (); }
  } ;

  template<class N>
  struct get_impl
  {
    typedef mpl::bool_< ::std::numeric_limits<N>::is_integer > is_int ;

    typedef Integral<N> impl_int ;
    typedef Float <N> impl_float ;

    typedef typename mpl::if_<is_int,impl_int,impl_float>::type type ;
  } ;

} } }
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/bounds.hpp" 2

namespace boost { namespace numeric
{

template<class N>
struct bounds : boundsdetail::get_impl<N>::type
{} ;

} }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp" 2





namespace boost { namespace numeric { namespace convdetail
{

  typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round2zero_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round2nearest_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round2inf_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round2neg_inf_c ;
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class RoundStyle,class RoundToZero,class RoundToNearest,class RoundToInf,class RoundToNegInf>
  struct for_round_style
  {
    typedef ct_switch4<RoundStyle
                       , round2zero_c, round2nearest_c, round2inf_c
                       , RoundToZero , RoundToNearest , RoundToInf , RoundToNegInf
                      > selector ;

    typedef typename selector::type type ;
  } ;
# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  struct non_applicable { typedef mpl::false_ do_apply ; } ;
  struct applicable { typedef mpl::true_ do_apply ; } ;
# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
    template<class Traits>
    struct LT_LoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_Zero : applicable
    {
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(0) ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LE_PrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s <= static_cast<S>(bounds<T>::lowest()) - static_cast<S>(1.0)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct LT_HalfPrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) - static_cast<S>(0.5)
                 ? cNegOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s > static_cast<S>(bounds<T>::highest())
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GE_SuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(1.0)
                 ? cPosOverflow : cInRange ;
      }
    } ;



    template<class Traits>
    struct GT_HalfSuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(0.5)
                 ? cPosOverflow : cInRange ;
      }
    } ;
# 215 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
    template<class PredA, class PredB>
    struct applyBoth
    {
      typedef typename PredA::argument_type argument_type ;

      static range_check_result apply ( argument_type s )
      {
        range_check_result r = PredA::apply(s) ;
        if ( r == cInRange )
          r = PredB::apply(s);
        return r ;
      }
    } ;

    template<class PredA, class PredB>
    struct combine
    {
      typedef applyBoth<PredA,PredB> Both ;
      typedef void NNone ;

      typedef typename PredA::do_apply do_applyA ;
      typedef typename PredB::do_apply do_applyB ;

      typedef typename for_both<do_applyA, do_applyB, Both, PredA, PredB, NNone>::type type ;
    } ;
# 262 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class Traits>
  struct dummy_range_checker
  {
    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type ) { return cInRange ; }
    static void validate_range ( argument_type ) {}
  } ;
# 279 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class Traits, class IsNegOverflow, class IsPosOverflow, class OverflowHandler>
  struct generic_range_checker
  {
    typedef OverflowHandler overflow_handler ;

    typedef typename Traits::argument_type argument_type ;

    static range_check_result out_of_range ( argument_type s )
    {
      typedef typename combine<IsNegOverflow,IsPosOverflow>::type Predicate ;

      return Predicate::apply(s);
    }

    static void validate_range ( argument_type s )
      { OverflowHandler()( out_of_range(s) ) ; }
  } ;
# 305 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class Traits,class OverflowHandler>
  struct GetRC_Sig2Sig_or_Unsig2Unsig
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Sig2Unsig
  {
    typedef LT_Zero<Traits> Pred1 ;
    typedef GT_HiT <Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ChoiceA ;

    typedef generic_range_checker<Traits,Pred1,non_applicable,OverflowHandler> ChoiceB ;

    typedef typename Traits::target_type T ;
    typedef typename Traits::source_type S ;

    typedef typename subranged_Unsig2Sig<S,T>::type oposite_subranged ;

    typedef typename mpl::not_<oposite_subranged>::type positively_subranged ;

    typedef typename mpl::if_<positively_subranged,ChoiceA,ChoiceB>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Unsig2Sig
  {
    typedef GT_HiT<Traits> Pred1 ;

    typedef generic_range_checker<Traits,non_applicable,Pred1,OverflowHandler> type ;
  } ;

  template<class Traits,class OverflowHandler>
  struct GetRC_Int2Int
  {
    typedef GetRC_Sig2Sig_or_Unsig2Unsig<Traits,OverflowHandler> Sig2SigQ ;
    typedef GetRC_Sig2Unsig <Traits,OverflowHandler> Sig2UnsigQ ;
    typedef GetRC_Unsig2Sig <Traits,OverflowHandler> Unsig2SigQ ;
    typedef Sig2SigQ Unsig2UnsigQ ;

    typedef typename Traits::sign_mixture sign_mixture ;

    typedef typename
      for_sign_mixture<sign_mixture,Sig2SigQ,Sig2UnsigQ,Unsig2SigQ,Unsig2UnsigQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits>
  struct GetRC_Int2Float
  {
    typedef dummy_range_checker<Traits> type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_Float2Int
  {
    typedef LE_PrevLoT <Traits> Pred1 ;
    typedef GE_SuccHiT <Traits> Pred2 ;
    typedef LT_HalfPrevLoT<Traits> Pred3 ;
    typedef GT_HalfSuccHiT<Traits> Pred4 ;
    typedef GT_HiT <Traits> Pred5 ;
    typedef LT_LoT <Traits> Pred6 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ToZero ;
    typedef generic_range_checker<Traits,Pred3,Pred4,OverflowHandler> ToNearest ;
    typedef generic_range_checker<Traits,Pred1,Pred5,OverflowHandler> ToInf ;
    typedef generic_range_checker<Traits,Pred6,Pred2,OverflowHandler> ToNegInf ;

    typedef typename Float2IntRounder::round_style round_style ;

    typedef typename for_round_style<round_style,ToZero,ToNearest,ToInf,ToNegInf>::type type ;
  } ;

  template<class Traits, class OverflowHandler>
  struct GetRC_Float2Float
  {
    typedef dummy_range_checker<Traits> Dummy ;

    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;

    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;

    typedef typename Traits::subranged subranged ;

    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_BuiltIn2BuiltIn
  {
    typedef GetRC_Int2Int<Traits,OverflowHandler> Int2IntQ ;
    typedef GetRC_Int2Float<Traits> Int2FloatQ ;
    typedef GetRC_Float2Int<Traits,OverflowHandler,Float2IntRounder> Float2IntQ ;
    typedef GetRC_Float2Float<Traits,OverflowHandler> Float2FloatQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ>::type selector ;

    typedef typename selector::type type ;
  } ;

  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC
  {
    typedef GetRC_BuiltIn2BuiltIn<Traits,OverflowHandler,Float2IntRounder> BuiltIn2BuiltInQ ;

    typedef dummy_range_checker<Traits> Dummy ;

    typedef mpl::identity<Dummy> DummyQ ;

    typedef typename Traits::udt_builtin_mixture udt_builtin_mixture ;

    typedef typename for_udt_builtin_mixture<udt_builtin_mixture,BuiltIn2BuiltInQ,DummyQ,DummyQ,DummyQ>::type selector ;

    typedef typename selector::type type ;
  } ;
# 452 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class Traits>
  struct trivial_converter_impl : public dummy_range_checker<Traits>
  {
    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type low_level_convert ( argument_type s ) { return s ; }
    static source_type nearbyint ( argument_type s ) { return s ; }
    static result_type convert ( argument_type s ) { return s ; }
  } ;





  template<class Traits,class RangeChecker,class RawConverter,class Float2IntRounder>
  struct rounding_converter : public RangeChecker
                             ,public Float2IntRounder
                             ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef Float2IntRounder Float2IntRounderBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      source_type s1 = Float2IntRounderBase::nearbyint(s);
      return RawConverterBase::low_level_convert(s1);
    }
  } ;





  template<class Traits,class RangeChecker,class RawConverter>
  struct non_rounding_converter : public RangeChecker
                                 ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef RawConverter RawConverterBase ;

    typedef Traits traits ;

    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;

    static source_type nearbyint ( argument_type s ) { return s ; }

    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      return RawConverterBase::low_level_convert(s);
    }
  } ;
# 528 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
  template<class Traits,class OverflowHandler,class Float2IntRounder,class RawConverter, class UserRangeChecker>
  struct get_non_trivial_converter
  {
    typedef GetRC<Traits,OverflowHandler,Float2IntRounder> InternalRangeCheckerQ ;

    typedef is_same<UserRangeChecker,UseInternalRangeChecker> use_internal_RC ;

    typedef mpl::identity<UserRangeChecker> UserRangeCheckerQ ;

    typedef typename
      mpl::eval_if<use_internal_RC,InternalRangeCheckerQ,UserRangeCheckerQ>::type
        RangeChecker ;

    typedef non_rounding_converter<Traits,RangeChecker,RawConverter> NonRounding ;
    typedef rounding_converter<Traits,RangeChecker,RawConverter,Float2IntRounder> Rounding ;

    typedef mpl::identity<NonRounding> NonRoundingQ ;
    typedef mpl::identity<Rounding> RoundingQ ;

    typedef typename Traits::int_float_mixture int_float_mixture ;

    typedef typename
      for_int_float_mixture<int_float_mixture, NonRoundingQ, NonRoundingQ, RoundingQ, NonRoundingQ>::type
        selector ;

    typedef typename selector::type type ;
  } ;

  template< class Traits
           ,class OverflowHandler
           ,class Float2IntRounder
           ,class RawConverter
           ,class UserRangeChecker
          >
  struct get_converter_impl
  {
# 574 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/converter.hpp"
    typedef trivial_converter_impl<Traits> Trivial ;
    typedef mpl::identity <Trivial> TrivialQ ;

    typedef get_non_trivial_converter< Traits
                                      ,OverflowHandler
                                      ,Float2IntRounder
                                      ,RawConverter
                                      ,UserRangeChecker
                                     > NonTrivialQ ;

    typedef typename Traits::trivial trivial ;

    typedef typename mpl::eval_if<trivial,TrivialQ,NonTrivialQ>::type type ;
  } ;

} } }
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp" 2

namespace boost { namespace numeric
{

template<class T,
         class S,
         class Traits = conversion_traits<T,S>,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc< 
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp" 3
                                        typename 
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/converter.hpp"
                                                               Traits::source_type> ,
         class RawConverter = raw_converter<Traits>,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct converter : convdetail::get_converter_impl<Traits,
                                                  OverflowHandler,
                                                  Float2IntRounder,
                                                  RawConverter,
                                                  UserRangeChecker
                                                 >::type
{
  typedef Traits traits ;

  typedef typename Traits::argument_type argument_type ;
  typedef typename Traits::result_type result_type ;

  result_type operator() ( argument_type s ) const { return this->convert(s) ; }
} ;



template<class S,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc<S> ,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct make_converter_from
{
  template<class T,
           class Traits = conversion_traits<T,S>,
           class RawConverter = raw_converter<Traits>
          >
  struct to
  {
    typedef converter<T,S,Traits,OverflowHandler,Float2IntRounder,RawConverter,UserRangeChecker> type ;
  } ;

} ;

} }
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/cast.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/numeric_cast_traits.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/numeric_cast_traits.hpp"
namespace boost { namespace numeric {

    template <typename Target, typename Source, typename EnableIf = void>
    struct numeric_cast_traits
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<Source> rounding_policy;
    };

}}


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/numeric_cast_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp"
namespace boost { namespace numeric {

    template <>
    struct numeric_cast_traits
        <
            char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , signed char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<signed char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned char
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned char> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned short
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned short> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned int
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned int> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , unsigned long
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<unsigned long> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , float
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<float> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<double> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , long double
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<long double> rounding_policy;
    };
}}
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp"
namespace boost { namespace numeric {


    template <>
    struct numeric_cast_traits
        <
            char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            signed char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned char
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned short
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned int
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            unsigned long
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            float
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            long double
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::long_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::long_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::long_long_type> rounding_policy;
    };

    template <>
    struct numeric_cast_traits
        <
            boost::ulong_long_type
          , boost::ulong_long_type
        >
    {
        typedef def_overflow_handler overflow_policy;
        typedef UseInternalRangeChecker range_checking_policy;
        typedef Trunc<boost::ulong_long_type> rounding_policy;
    };
}}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/detail/numeric_cast_traits.hpp" 2
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/numeric_cast_traits.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/numeric/conversion/cast.hpp" 2

namespace boost
{
    template <typename Target, typename Source>
    inline Target numeric_cast( Source arg )
    {
        typedef numeric::conversion_traits<Target, Source> conv_traits;
        typedef numeric::numeric_cast_traits<Target, Source> cast_traits;
        typedef boost::numeric::converter
            <
                Target,
                Source,
                conv_traits,
                typename cast_traits::overflow_policy,
                typename cast_traits::rounding_policy,
                boost::numeric::raw_converter< conv_traits >,
                typename cast_traits::range_checking_policy
            > converter;
        return converter::convert(arg);
    }

    using numeric::bad_numeric_cast;
}
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 2

namespace boost { namespace detail {

template <class Source >
struct detect_precision_loss
{
    typedef Source source_type;
    typedef boost::numeric::Trunc<Source> Rounder;
    typedef 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
           typename 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                  conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& is_ok) 
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                     noexcept 
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                    {
        const source_type near_int = Rounder::nearbyint(s);
        if (near_int && is_ok) {
            const source_type orig_div_round = s / near_int;
            const source_type eps = std::numeric_limits<source_type>::epsilon();

            is_ok = !((orig_div_round > 1 ? orig_div_round - 1 : 1 - orig_div_round) > eps);
        }

        return s;
    }

    typedef typename Rounder::round_style round_style;
};

template <typename Base, class Source>
struct fake_precision_loss: public Base
{
    typedef Source source_type ;
    typedef 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
           typename 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                  conditional<
        boost::is_arithmetic<Source>::value, Source, Source const&
    >::type argument_type ;

    static inline source_type nearbyint(argument_type s, bool& ) 
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                         noexcept 
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                        {
        return s;
    }
};

struct nothrow_overflow_handler
{
    inline bool operator() ( boost::numeric::range_check_result r ) const 
# 79 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                         noexcept 
# 79 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                        {
        return (r == boost::numeric::cInRange);
    }
};

template <typename Target, typename Source>
inline bool noexcept_numeric_convert(const Source& arg, Target& result) 
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                       noexcept 
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                      {
    typedef boost::numeric::converter<
            Target,
            Source,
            boost::numeric::conversion_traits<Target, Source >,
            nothrow_overflow_handler,
            detect_precision_loss<Source >
    > converter_orig_t;

    typedef 
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
           typename 
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                  boost::conditional<
        boost::is_base_of< detect_precision_loss<Source >, converter_orig_t >::value,
        converter_orig_t,
        fake_precision_loss<converter_orig_t, Source>
    >::type converter_t;

    bool res = nothrow_overflow_handler()(converter_t::out_of_range(arg));
    result = converter_t::low_level_convert(converter_t::nearbyint(arg, res));
    return res;
}

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_not_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                     noexcept 
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                    {
        return noexcept_numeric_convert<Target, Source >(arg, result);
    }
};

template <typename Target, typename Source>
struct lexical_cast_dynamic_num_ignoring_minus
{
    static inline bool try_convert(const Source &arg, Target& result) 
# 116 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                     noexcept 
# 116 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                    {
        typedef 
# 117 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
               typename 
# 117 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                      boost::conditional<
                boost::is_float<Source>::value,
                boost::type_identity<Source>,
                boost::make_unsigned<Source>
        >::type usource_lazy_t;
        typedef 
# 122 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
               typename 
# 122 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                      usource_lazy_t::type usource_t;

        if (arg < 0) {
            const bool res = noexcept_numeric_convert<Target, usource_t>(0u - arg, result);
            result = static_cast<Target>(0u - result);
            return res;
        } else {
            return noexcept_numeric_convert<Target, usource_t>(arg, result);
        }
    }
};
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
template <typename Target, typename Source>
struct dynamic_num_converter_impl
{
    static inline bool try_convert(const Source &arg, Target& result) 
# 155 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
                                                                     noexcept 
# 155 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                                                                    {
        typedef 
# 156 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp" 3
               typename 
# 156 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_numeric.hpp"
                                      boost::conditional<
            boost::is_unsigned<Target>::value &&
            (boost::is_signed<Source>::value || boost::is_float<Source>::value) &&
            !(boost::is_same<Source, bool>::value) &&
            !(boost::is_same<Target, bool>::value),
            lexical_cast_dynamic_num_ignoring_minus<Target, Source>,
            lexical_cast_dynamic_num_not_ignoring_minus<Target, Source>
        >::type caster_type;

        return caster_type::try_convert(arg, result);
    }
};

}}
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
          
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_left_shift.hpp" 1
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_left_shift.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
          
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3

# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_ret_imp 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      : public boost::false_type {};

      template <class T, class U, class Ret>
      struct 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_ret_imp
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     <T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                    << 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                      std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                 << 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_void_imp 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                       : public boost::false_type {};

      template <class T, class U>
      struct 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_void_imp
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                << 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                  std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                          << 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                            std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_dc_imp 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     : public boost::false_type {};

      template <class T, class U>
      struct 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_left_shift_dc_imp
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                    <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                              << 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_left_shift 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                             : public boost::binary_op_detail:: 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                has_left_shift_ret_imp 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                          <T, U, Ret> {};
   template <class T, class U>
   struct 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_left_shift
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, void> : public boost::binary_op_detail:: 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                            has_left_shift_void_imp 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                       <T, U> {};
   template <class T, class U>
   struct 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_left_shift
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                          has_left_shift_dc_imp 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   <T, U> {};


}
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_left_shift.hpp" 2
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_right_shift.hpp" 1
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_right_shift.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
          
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
namespace boost
{

   namespace binary_op_detail {

      struct dont_care;

      template <class T, class U, class Ret, class = void>
      struct 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_ret_imp 
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      : public boost::false_type {};

      template <class T, class U, class Ret>
      struct 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_ret_imp
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     <T, U, Ret, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                    >> 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                      std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_convertible<decltype(std::declval<typename add_reference<T>::type>() 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                 >> 
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   std::declval<typename add_reference<U>::type>()), Ret>::value> {};

      template <class T, class U, class = void >
      struct 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_void_imp 
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                       : public boost::false_type {};

      template <class T, class U>
      struct 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_void_imp
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                      <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                                >> 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                  std::declval<typename add_reference<U>::type>())>::type>
         : public boost::integral_constant<bool, ::boost::is_void<decltype(std::declval<typename add_reference<T>::type>() 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                          >> 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                            std::declval<typename add_reference<U>::type>())>::value> {};

      template <class T, class U, class = void>
      struct 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_dc_imp 
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                     : public boost::false_type {};

      template <class T, class U>
      struct 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
            has_right_shift_dc_imp
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                    <T, U, typename boost::make_void<decltype(std::declval<typename add_reference<T>::type>() 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                                                              >> 
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                                std::declval<typename add_reference<U>::type>())>::type>
         : public boost::true_type {};

   }

   template <class T, class U = T, class Ret = boost::binary_op_detail::dont_care>
   struct 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_right_shift 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                             : public boost::binary_op_detail:: 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                has_right_shift_ret_imp 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                          <T, U, Ret> {};
   template <class T, class U>
   struct 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_right_shift
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, void> : public boost::binary_op_detail:: 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                            has_right_shift_void_imp 
# 76 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                       <T, U> {};
   template <class T, class U>
   struct 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
         has_right_shift
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                            <T, U, boost::binary_op_detail::dont_care> : public boost::binary_op_detail:: 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp"
                                                                                                          has_right_shift_dc_imp 
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/detail/has_binary_operator.hpp" 3
                                                                                                                                                   <T, U> {};


}
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/type_traits/has_right_shift.hpp" 2
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
#include <climits>




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp"
# 1 "/scratch/products/gcc/v8_2_0/Linux64bit+3.10-2.17/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include-fixed/limits.h" 1 3 4
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp" 2



extern "C" {
#include <wchar.h>
}
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp"
       
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp" 3


namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};

namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};



template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;


}

template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };

template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-0x7f - 1), 0x7f>
{ };

template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-0x7f - 1), 0x7f>
{ };

template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (0x7f * 2 + 1)>
{ };


template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,



    public detail::integer_traits_base<wchar_t, (-2147483647 - 1), (2147483647)>
# 125 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp" 3
{ };


template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-0x7fff - 1), 0x7fff>
{ };

template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (0x7fff * 2 + 1)>
{ };

template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-0x7fffffff - 1), 0x7fffffff>
{ };

template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (0x7fffffff * 2U + 1U)>
{ };

template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-0x7fffffffffffffffL - 1L), 0x7fffffffffffffffL>
{ };

template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (0x7fffffffffffffffL * 2UL + 1UL)>
{ };




template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-0x7fffffffffffffffLL -1), 0x7fffffffffffffffLL>
{ };

template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, (0x7fffffffffffffffLL * 2ULL + 1)>
{ };
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_traits.hpp" 3
}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"

# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
namespace boost { namespace detail {

class lcast_abstract_stub {};





template<class T>
struct lcast_precision
{



    typedef 
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
           typename 
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
                                  boost::conditional<
        boost::is_abstract<T>::value
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;


    
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   bool use_default_precision = !limits::is_specialized || limits::is_exact

         ;

    
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0


         ;

    
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0


         ;

    
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 71 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max

         ;

    
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 75 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   unsigned int precision_dec = limits::digits10 + 1U;

    static_assert(!is_specialized_dec || precision_dec <= streamsize_max + 0UL, "!is_specialized_dec || precision_dec <= streamsize_max + 0UL")

         ;

    
# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL

         ;

    static_assert(!is_specialized_bin || (limits::digits + 0UL < 
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3 4
   (0x7fffffffffffffffL * 2UL + 1UL) 
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL), "!is_specialized_bin || (limits::digits + 0UL < ULONG_MAX / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)")



         ;

    
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp" 3
   static const 
# 91 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
   std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6


         ;
};


template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{

    return lcast_precision<T>::value;
# 166 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/lcast_precision.hpp"
}

template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}

template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision(static_cast<Source*>(0));
    std::streamsize const t = lcast_get_precision(static_cast<Target*>(0));
    stream.precision(s > t ? s : t);
}

}}
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/widest_char.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/widest_char.hpp"
          





namespace boost { namespace detail {

    template <typename TargetChar, typename SourceChar>
    struct widest_char {
        typedef 
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/widest_char.hpp" 3
               typename 
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/widest_char.hpp"
                                      boost::conditional<
            (sizeof(TargetChar) > sizeof(SourceChar))
            , TargetChar
            , SourceChar
        >::type type;
    };

}}
# 44 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 1
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp"
extern "C" {
#include <assert.h>
}
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/swap.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/swap.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/swap.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/swap.hpp"

# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/core/swap.hpp"
namespace boost_swap_impl
{


  template<class T> struct is_const { enum _vt { value = 0 }; };
  template<class T> struct is_const<T const> { enum _vt { value = 1 }; };

  template<class T>
 
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
 
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
 
  typename enable_if_c< !boost_swap_impl::is_const<T1>::value && !boost_swap_impl::is_const<T2>::value >::type
  swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/swap.hpp" 2
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/iterator.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/iterator.hpp"
namespace boost
{

namespace detail
{

using std::iterator_traits;
using std::distance;
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/iterator.hpp"
}

}
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 2







namespace boost {

    template<class T, std::size_t N>
    class array {
      public:
        T elems[N];

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return elems; }
        const_iterator begin() const { return elems; }
        const_iterator cbegin() const { return elems; }

        iterator end() { return elems+N; }
        const_iterator end() const { return elems+N; }
        const_iterator cend() const { return elems+N; }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            return 
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  ((
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                  (i < N)&&("out of range")
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  ) ? static_cast<void> (0) : __assert_fail (
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                  "(i < N)&&(\"out of range\")"
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp", 118, __PRETTY_FUNCTION__))
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                           , elems[i];
        }

                            const_reference operator[](size_type i) const
        {
            return 
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  ((
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                  (i < N)&&("out of range")
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  ) ? static_cast<void> (0) : __assert_fail (
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                  "(i < N)&&(\"out of range\")"
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3 4
                  , "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp", 123, __PRETTY_FUNCTION__))
# 123 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                           , elems[i];
        }


        reference at(size_type i) { return rangecheck(i), elems[i]; }
                            const_reference at(size_type i) const { return rangecheck(i), elems[i]; }


        reference front()
        {
            return elems[0];
        }

        
# 136 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
       constexpr 
# 136 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                       const_reference front() const
        {
            return elems[0];
        }

        reference back()
        {
            return elems[N-1];
        }

        
# 146 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
       constexpr 
# 146 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                       const_reference back() const
        {
            return elems[N-1];
        }


        static 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              size_type size() { return N; }
        static 
# 153 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 153 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              bool empty() { return false; }
        static 
# 154 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 154 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              size_type max_size() { return N; }
        enum { static_size = N };


        void swap (array<T,N>& y) {
            for (size_type i = 0; i < N; ++i)
                boost::swap(elems[i],y.elems[i]);
        }


        const T* data() const { return elems; }
        T* data() { return elems; }


        T* c_array() { return elems; }


        template <typename T2>
        array<T,N>& operator= (const array<T2,N>& rhs) {
            std::copy(rhs.begin(),rhs.end(), begin());
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& value)
        {
            std::fill_n(begin(),size(),value);
        }


        static 
# 185 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 185 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              bool rangecheck (size_type i) {
            return i >= size() ? boost::throw_exception(std::out_of_range ("array<>: index out of range")), true : true;
        }

    };

    template< class T >
    class array< T, 0 > {

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return iterator( reinterpret_cast< T * >( this ) ); }
        const_iterator begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
        const_iterator cbegin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }

        iterator end() { return begin(); }
        const_iterator end() const { return begin(); }
        const_iterator cend() const { return cbegin(); }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 228 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        const_reverse_iterator crbegin() const {
            return const_reverse_iterator(end());
        }

        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }
        const_reverse_iterator crend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type )
        {
            return failed_rangecheck();
        }

                            const_reference operator[](size_type ) const
        {
            return failed_rangecheck();
        }


        reference at(size_type ) { return failed_rangecheck(); }
                            const_reference at(size_type ) const { return failed_rangecheck(); }


        reference front()
        {
            return failed_rangecheck();
        }

        
# 265 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
       constexpr 
# 265 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                       const_reference front() const
        {
            return failed_rangecheck();
        }

        reference back()
        {
            return failed_rangecheck();
        }

        
# 275 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
       constexpr 
# 275 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                       const_reference back() const
        {
            return failed_rangecheck();
        }


        static 
# 281 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 281 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              size_type size() { return 0; }
        static 
# 282 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 282 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              bool empty() { return true; }
        static 
# 283 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
              constexpr 
# 283 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                              size_type max_size() { return 0; }
        enum { static_size = 0 };

        void swap (array<T,0>& ) {
        }


        const T* data() const { return 0; }
        T* data() { return 0; }


        T* c_array() { return 0; }


        template <typename T2>
        array<T,0>& operator= (const array<T2,0>& ) {
            return *this;
        }


        void assign (const T& value) { fill ( value ); }
        void fill (const T& ) {}


        static reference failed_rangecheck () {
                std::out_of_range e("attempt to access element of an empty array");
                boost::throw_exception(e);






                static T placeholder;
                return placeholder;

            }
    };


    template<class T, std::size_t N>
    bool operator== (const array<T,N>& x, const array<T,N>& y) {
        return std::equal(x.begin(), x.end(), y.begin());
    }
    template<class T, std::size_t N>
    bool operator< (const array<T,N>& x, const array<T,N>& y) {
        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
    }
    template<class T, std::size_t N>
    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
        return !(x==y);
    }
    template<class T, std::size_t N>
    bool operator> (const array<T,N>& x, const array<T,N>& y) {
        return y<x;
    }
    template<class T, std::size_t N>
    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
        return !(y<x);
    }
    template<class T, std::size_t N>
    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
        return !(x<y);
    }


    template<class T, std::size_t N>
    inline void swap (array<T,N>& x, array<T,N>& y) {
        x.swap(y);
    }
# 382 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
    template <typename T, std::size_t N>
    T(&get_c_array(boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }


    template <typename T, std::size_t N>
    const T(&get_c_array(const boost::array<T,N>& arg))[N]
    {
        return arg.elems;
    }
# 414 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
    template <class It> std::size_t hash_range(It, It);

    template<class T, std::size_t N>
    std::size_t hash_value(const array<T,N>& arr)
    {
        return boost::hash_range(arr.begin(), arr.end());
    }

   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) 
# 423 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
                                 noexcept 
# 423 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                {
       static_assert(Idx < N, "boost::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) 
# 429 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
                                             noexcept 
# 429 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                            {
       static_assert(Idx < N, "boost::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }

}



namespace std {
   template <size_t Idx, typename T, size_t N>
   T &get(boost::array<T,N> &arr) 
# 440 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
                                 noexcept 
# 440 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                {
       static_assert(Idx < N, "std::get<>(boost::array &) index out of range");
       return arr[Idx];
       }

   template <size_t Idx, typename T, size_t N>
   const T &get(const boost::array<T,N> &arr) 
# 446 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp" 3
                                             noexcept 
# 446 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/array.hpp"
                                                            {
       static_assert(Idx < N, "std::get<>(const boost::array &) index out of range");
       return arr[Idx];
       }
}
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/container_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/container_fwd.hpp"
         
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/container_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp"
         






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/move/detail/std_ns_begin.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp" 2
namespace std 
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp" 3
__attribute__ ((__visibility__ (
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp"
"default"
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp" 3
))) 
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp"
{

template<class T>
class allocator;

template<class T>
struct less;

template<class T>
struct equal_to;

template<class T1, class T2>
struct pair;

template<class T>
struct char_traits;

struct input_iterator_tag;
struct forward_iterator_tag;
struct bidirectional_iterator_tag;
struct random_access_iterator_tag;

template<class Container>
class insert_iterator;

struct allocator_arg_t;

struct piecewise_construct_t;

 }
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/move/detail/std_ns_end.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/detail/std_fwd.hpp" 2
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/container_fwd.hpp" 2


namespace boost{
namespace intrusive{
namespace detail{

}}}

namespace boost{ namespace container{ namespace dtl{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}

namespace boost{ namespace container{ namespace pmr{
   namespace bi = boost::intrusive;
   namespace bid = boost::intrusive::detail;
}}}
# 88 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/container/container_fwd.hpp"
namespace boost {
namespace container {



template<class T1, class T2>
struct pair;

template<class T>
class new_allocator;

template <class T
         ,class Allocator = void
         ,class Options = void>
class vector;

template <class T
         ,class Allocator = void >
class stable_vector;

template <class T, std::size_t Capacity>
class static_vector;

template < class T, std::size_t N
         , class Allocator = void >
class small_vector;

template <class T
         ,class Allocator = void >
class deque;

template <class T
         ,class Allocator = void >
class list;

template <class T
         ,class Allocator = void >
class slist;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void>
class set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void
         ,class Options = void >
class multimap;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_set;

template <class Key
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_multiset;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_map;

template <class Key
         ,class T
         ,class Compare = std::less<Key>
         ,class Allocator = void >
class flat_multimap;

template <class CharT
         ,class Traits = std::char_traits<CharT>
         ,class Allocator = void >
class basic_string;

typedef basic_string <char> string;
typedef basic_string<wchar_t> wstring;

static const std::size_t ADP_nodes_per_block = 256u;
static const std::size_t ADP_max_free_blocks = 2u;
static const std::size_t ADP_overhead_percent = 1u;
static const std::size_t ADP_only_alignment = 0u;

template < class T
         , std::size_t NodesPerBlock = ADP_nodes_per_block
         , std::size_t MaxFreeBlocks = ADP_max_free_blocks
         , std::size_t OverheadPercent = ADP_overhead_percent
         , unsigned Version = 2
         >
class adaptive_pool;

template < class T
         , unsigned Version = 2
         , unsigned int AllocationDisableMask = 0>
class allocator;

static const std::size_t NodeAlloc_nodes_per_block = 256u;

template
   < class T
   , std::size_t NodesPerBlock = NodeAlloc_nodes_per_block
   , std::size_t Version = 2>
class node_allocator;

namespace pmr {

class memory_resource;

template<class T>
class polymorphic_allocator;

class monotonic_buffer_resource;

struct pool_options;

template <class Allocator>
class resource_adaptor_imp;

class unsynchronized_pool_resource;

class synchronized_pool_resource;

}





struct ordered_range_t
{};



static const ordered_range_t ordered_range = ordered_range_t();



struct ordered_unique_range_t
   : public ordered_range_t
{};



static const ordered_unique_range_t ordered_unique_range = ordered_unique_range_t();



struct default_init_t
{};



static const default_init_t default_init = default_init_t();




struct value_init_t
{};



static const value_init_t value_init = value_init_t();

namespace container_detail_really_deep_namespace {



struct dummy
{
   dummy()
   {
      (void)ordered_range;
      (void)ordered_unique_range;
      (void)default_init;
   }
};

}




}}
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
          
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
#include <cstring>
#include <cstdio>
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
#include <locale>
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
#include <sstream>


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
          



# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
namespace boost
{
    namespace detail
    {
        template < typename Char >
        struct lcast_char_constants {


            
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char zero = static_cast<Char>('0');
            
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char minus = static_cast<Char>('-');
            
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char plus = static_cast<Char>('+');
            
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char lowercase_e = static_cast<Char>('e');
            
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char capital_e = static_cast<Char>('E');
            
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp" 3
           static const 
# 39 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_char_constants.hpp"
           Char c_decimal_separator = static_cast<Char>('.');
        };
    }
}
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
          


#include <climits>


#include <cstring>
#include <cstdio>
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/noncopyable.hpp" 1
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 2

namespace boost
{
    namespace detail
    {
        template<class T>
        inline
        
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
       typename 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                              boost::make_unsigned<T>::type lcast_to_unsigned(const T value) 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                                                                             noexcept 
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                                                                            {
            typedef 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                   typename 
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                          boost::make_unsigned<T>::type result_type;
            return value < 0
                ? static_cast<result_type>(0u - static_cast<result_type>(value))
                : static_cast<result_type>(value);
        }
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_put_unsigned: boost::noncopyable {
            typedef 
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                   typename 
# 73 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                          Traits::int_type int_type;
            
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
           typename 
# 74 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                  boost::conditional<
                    (sizeof(unsigned) > sizeof(T))
                    , unsigned
                    , T
            >::type m_value;
            CharT* m_finish;
            CharT const m_czero;
            int_type const m_zero;

        public:
            lcast_put_unsigned(const T n_param, CharT* finish) 
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                                              noexcept
                
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
               : m_value(n_param), m_finish(finish)
                , m_czero(lcast_char_constants<CharT>::zero), m_zero(Traits::to_int_type(m_czero))
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");

            }

            CharT* convert() {

                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    std::use_facet< 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                    numpunct 
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    >(
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                    loc
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    )
# 101 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                                  ;
                std::string const grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();

                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }



                static_assert(std::numeric_limits<T>::digits10 < 0x7f, "std::numeric_limits<T>::digits10 < CHAR_MAX");

                CharT const thousands_sep = np.thousands_sep();
                std::string::size_type group = 0;
                char last_grp_size = grouping[0];
                char left = last_grp_size;

                do {
                    if (left == 0) {
                        ++group;
                        if (group < grouping_size) {
                            char const grp_size = grouping[group];
                            last_grp_size = (grp_size <= 0 ? static_cast<char>(0x7f) : grp_size);
                        }

                        left = last_grp_size;
                        --m_finish;
                        Traits::assign(*m_finish, thousands_sep);
                    }

                    --left;
                } while (main_convert_iteration());

                return m_finish;



            }

        private:
            inline bool main_convert_iteration() 
# 141 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                                noexcept 
# 141 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                               {
                --m_finish;
                int_type const digit = static_cast<int_type>(m_value % 10U);
                Traits::assign(*m_finish, Traits::to_char_type(m_zero + digit));
                m_value /= 10;
                return !!m_value;
            }

            inline CharT* main_convert_loop() 
# 149 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                             noexcept 
# 149 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                            {
                while (main_convert_iteration());
                return m_finish;
            }
        };
    }

    namespace detail
    {
        template <class Traits, class T, class CharT>
        class lcast_ret_unsigned: boost::noncopyable {
            bool m_multiplier_overflowed;
            T m_multiplier;
            T& m_value;
            const CharT* const m_begin;
            const CharT* m_end;

        public:
            lcast_ret_unsigned(T& value, const CharT* const begin, const CharT* end) 
# 167 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                                                                    noexcept
                
# 168 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
               : m_multiplier_overflowed(false), m_multiplier(1), m_value(value), m_begin(begin), m_end(end)
            {

                static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");






                static_assert(std::numeric_limits<T>::is_specialized, "std::numeric_limits are not specialized for integral type passed to boost::lexical_cast")

                 ;

            }

            inline bool convert() {
                CharT const czero = lcast_char_constants<CharT>::zero;
                --m_end;
                m_value = static_cast<T>(0);

                if (m_begin > m_end || *m_end < czero || *m_end >= czero + 10)
                    return false;
                m_value = static_cast<T>(*m_end - czero);
                --m_end;




                std::locale loc;
                if (loc == std::locale::classic()) {
                    return main_convert_loop();
                }

                typedef std::numpunct<CharT> numpunct;
                numpunct const& np = 
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    std::use_facet< 
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                    numpunct 
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    >(
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                    loc
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    )
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                                  ;
                std::string const& grouping = np.grouping();
                std::string::size_type const grouping_size = grouping.size();




                if (!grouping_size || grouping[0] <= 0) {
                    return main_convert_loop();
                }

                unsigned char current_grouping = 0;
                CharT const thousands_sep = np.thousands_sep();
                char remained = static_cast<char>(grouping[current_grouping] - 1);

                for (;m_end >= m_begin; --m_end)
                {
                    if (remained) {
                        if (!main_convert_iteration()) {
                            return false;
                        }
                        --remained;
                    } else {
                        if ( !Traits::eq(*m_end, thousands_sep) )
                        {
# 239 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                            return main_convert_loop();
                        } else {
                            if (m_begin == m_end) return false;
                            if (current_grouping < grouping_size - 1) ++current_grouping;
                            remained = grouping[current_grouping];
                        }
                    }
                }

                return true;

            }

        private:


            inline bool main_convert_iteration() 
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                                noexcept 
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                               {
                CharT const czero = lcast_char_constants<CharT>::zero;
                T const maxv = (std::numeric_limits<T>::max)();

                m_multiplier_overflowed = m_multiplier_overflowed || (maxv/10 < m_multiplier);
                m_multiplier = static_cast<T>(m_multiplier * 10);

                T const dig_value = static_cast<T>(*m_end - czero);
                T const new_sub_value = static_cast<T>(m_multiplier * dig_value);



                if (*m_end < czero || *m_end >= czero + 10
                    || (dig_value && (
                        m_multiplier_overflowed
                        || static_cast<T>(maxv / dig_value) < m_multiplier
                        || static_cast<T>(maxv - new_sub_value) < m_value
                    ))
                ) return false;

                m_value = static_cast<T>(m_value + new_sub_value);

                return true;
            }

            bool main_convert_loop() 
# 280 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp" 3
                                    noexcept 
# 280 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/lcast_unsigned_converters.hpp"
                                                   {
                for ( ; m_end >= m_begin; --m_end) {
                    if (!main_convert_iteration()) {
                        return false;
                    }
                }

                return true;
            }
        };
    }
}
# 63 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
          







#include <cstring>


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 1







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/version_number.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1






# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/detail/test.h" 1
# 8 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 2
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 2
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 1







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 1
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h"

# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h" 2
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 1







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 1
# 87 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h"

# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h"

# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h"

# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h" 2





# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h"

# 83 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/32.h" 2





# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86/64.h"

# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h" 2
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/architecture/x86.h"

# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp" 2




#include <climits>
#include <cfloat>







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/user.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp" 2
# 335 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/config.hpp"
namespace boost{ namespace math{
namespace tools
{

template <class T>
inline T max (T a, T b, T c) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), c);
}

template <class T>
inline T max (T a, T b, T c, T d) noexcept(std::is_floating_point<T>::value)
{
   return (std::max)((std::max)(a, b), (std::max)(c, d));
}

}

template <class T>
void suppress_unused_variable_warning(const T&) noexcept(std::is_floating_point<T>::value)
{
}

namespace detail{

template <class T>
struct is_integer_for_rounding
{
   static const bool value = boost::is_integral<T>::value

      || (std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer)

      ;
};

}

}}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/round_fwd.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/round_fwd.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/promotion.hpp" 1
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/promotion.hpp"
namespace boost
{
  namespace math
  {
    namespace tools
    {
# 68 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/promotion.hpp"
      template <class T>
      struct promote_arg
      {
        typedef typename mpl::if_<is_integral<T>, double, T>::type type;
      };


      template <> struct promote_arg<float> { typedef float type; };
      template <> struct promote_arg<double>{ typedef double type; };
      template <> struct promote_arg<long double> { typedef long double type; };
      template <> struct promote_arg<int> { typedef double type; };

      template <class T1, class T2>
      struct promote_args_2
      {

        typedef typename promote_arg<T1>::type T1P;
        typedef typename promote_arg<T2>::type T2P;

        typedef typename mpl::if_<
          typename mpl::and_<is_floating_point<T1P>, is_floating_point<T2P> >::type,




             typename mpl::if_< typename mpl::or_<is_same<long double, T1P>, is_same<long double, T2P> >::type,
               long double,
               typename mpl::if_< typename mpl::or_<is_same<double, T1P>, is_same<double, T2P> >::type,
                  double,
                  float
             >::type



             >::type,

          typename mpl::if_< typename mpl::and_<mpl::not_<is_floating_point<T2P> >, ::boost::is_convertible<T1P, T2P> >, T2P, T1P>::type>::type type;
      };


      template <> struct promote_args_2<float, float> { typedef float type; };
      template <> struct promote_args_2<double, double>{ typedef double type; };
      template <> struct promote_args_2<long double, long double> { typedef long double type; };
      template <> struct promote_args_2<int, int> { typedef double type; };
      template <> struct promote_args_2<int, float> { typedef double type; };
      template <> struct promote_args_2<float, int> { typedef double type; };
      template <> struct promote_args_2<int, double> { typedef double type; };
      template <> struct promote_args_2<double, int> { typedef double type; };
      template <> struct promote_args_2<int, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, int> { typedef long double type; };
      template <> struct promote_args_2<float, double> { typedef double type; };
      template <> struct promote_args_2<double, float> { typedef double type; };
      template <> struct promote_args_2<float, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, float> { typedef long double type; };
      template <> struct promote_args_2<double, long double> { typedef long double type; };
      template <> struct promote_args_2<long double, double> { typedef long double type; };

      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;







      };






      template <class T1, class T2=float, class T3=float, class T4=float, class T5=float, class T6=float>
      struct promote_args_permissive
      {
         typedef typename promote_args_2<
            typename remove_cv<T1>::type,
            typename promote_args_2<
               typename remove_cv<T2>::type,
               typename promote_args_2<
                  typename remove_cv<T3>::type,
                  typename promote_args_2<
                     typename remove_cv<T4>::type,
                     typename promote_args_2<
                        typename remove_cv<T5>::type, typename remove_cv<T6>::type
                     >::type
                  >::type
               >::type
            >::type
         >::type type;
      };

    }
  }
}
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/round_fwd.hpp" 2





namespace boost
{
   namespace math
   {

   template <class T, class Policy>
   typename tools::promote_args<T>::type trunc(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type trunc(const T& v);
   template <class T, class Policy>
   int itrunc(const T& v, const Policy& pol);
   template <class T>
   int itrunc(const T& v);
   template <class T, class Policy>
   long ltrunc(const T& v, const Policy& pol);
   template <class T>
   long ltrunc(const T& v);

   template <class T, class Policy>
   boost::long_long_type lltrunc(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type lltrunc(const T& v);

   template <class T, class Policy>
   typename tools::promote_args<T>::type round(const T& v, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type round(const T& v);
   template <class T, class Policy>
   int iround(const T& v, const Policy& pol);
   template <class T>
   int iround(const T& v);
   template <class T, class Policy>
   long lround(const T& v, const Policy& pol);
   template <class T>
   long lround(const T& v);

   template <class T, class Policy>
   boost::long_long_type llround(const T& v, const Policy& pol);
   template <class T>
   boost::long_long_type llround(const T& v);

   template <class T, class Policy>
   T modf(const T& v, T* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, T* ipart);
   template <class T, class Policy>
   T modf(const T& v, int* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, int* ipart);
   template <class T, class Policy>
   T modf(const T& v, long* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, long* ipart);

   template <class T, class Policy>
   T modf(const T& v, boost::long_long_type* ipart, const Policy& pol);
   template <class T>
   T modf(const T& v, boost::long_long_type* ipart);


   }
}
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 1
# 9 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/limits/list.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list20.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list20.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list10.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list10.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long_fwd.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long_fwd.hpp"
namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 40 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< long N >
struct long_
{
    
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
   long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp" 3
   constexpr 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/integral_wrapper.hpp"
                   operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/long.hpp" 2
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_front.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_front.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_front_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_front.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/item.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/item.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/tag.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/tag.hpp"
namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/item.hpp" 2



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_front.hpp" 2


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/pop_front.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/pop_front.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pop_front_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pop_front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/pop_front.hpp" 2



namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_back.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_back.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_back_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/push_back.hpp" 2



namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/front.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/front.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/front_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/front_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/front.hpp" 2


namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/clear.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/clear.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/clear_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/clear_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/clear.hpp" 2



namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/O1_size.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/O1_size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/O1_size_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/O1_size_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/O1_size.hpp" 2


namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/size.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/size_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/size_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/size.hpp" 2


namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/empty.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/empty.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/empty_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/empty_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/empty.hpp" 2



namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/begin_end.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/begin_end.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/begin_end_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/begin_end_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/begin_end.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iterator_tags.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iterator_tags.hpp"
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/deref.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/deref.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_type.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_type.hpp"
namespace boost { namespace mpl { namespace aux {
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/msvc_type.hpp"
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/deref.hpp" 2




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;



   
};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/lambda_spec.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp" 2


namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
# 62 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/iterator.hpp"
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/begin_end.hpp" 2



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list0.hpp" 2


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list10.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list10.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp"
namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list10.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list20.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list20.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp"
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list/list20.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp" 2
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/list.hpp"
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/list.hpp" 2
# 10 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains_fwd.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct contains_impl;
template< typename Sequence, typename T > struct contains;

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag_fwd.hpp"
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_begin.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_begin.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_begin.hpp" 3
static const 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_begin.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp" 2






namespace boost { namespace mpl {
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp"
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/sequence_tag.hpp"
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/contains_impl.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/contains_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/begin_end.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/begin_end.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/begin_end_impl.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/begin_end_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/traits_lambda_spec.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/begin_end_impl.hpp" 2


namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/begin_end_impl.hpp"
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/begin_end.hpp" 2




namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/contains_impl.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find_if.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/find_if_pred.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/find_if_pred.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_apply.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_apply.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_apply.hpp" 2


namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Iterator
    >
struct iter_apply1
    : apply1< F,typename deref<Iterator>::type >
{
};

template<
      typename F
    , typename Iterator1
    , typename Iterator2
    >
struct iter_apply2
    : apply2<
          F
        , typename deref<Iterator1>::type
        , typename deref<Iterator2>::type
        >
{
};

}}}
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/find_if_pred.hpp" 2


namespace boost { namespace mpl { namespace aux {

template< typename Predicate >
struct find_if_pred
{
    template< typename Iterator >
    struct apply
    {
        typedef not_< aux::iter_apply1<Predicate,Iterator> > type;
    };
};

}}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/logical.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pair.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pair.hpp"
namespace boost { namespace mpl {

template<
      typename T1 = na
    , typename T2 = na
    >
struct pair
{
    typedef pair type;
    typedef T1 first;
    typedef T2 second;

   
};

template<
      typename P = na
    >
struct first
{

    typedef typename P::first type;



   
};

template<
      typename P = na
    >
struct second
{

    typedef typename P::second type;



   
};


template<> struct pair< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair< na , na > result_; typedef pair< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair< na , na > > : int_<-1> { }; }
template<> struct first< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : first< T1 > { }; }; template< typename Tag > struct lambda< first< na > , Tag , int_<-1> > { typedef false_ is_le; typedef first< na > result_; typedef first< na > type; }; namespace aux { template< typename T1 > struct template_arity< first< T1 > > : int_<1> { }; template<> struct template_arity< first< na > > : int_<-1> { }; }
template<> struct second< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : second< T1 > { }; }; template< typename Tag > struct lambda< second< na > , Tag , int_<-1> > { typedef false_ is_le; typedef second< na > result_; typedef second< na > type; }; namespace aux { template< typename T1 > struct template_arity< second< T1 > > : int_<1> { }; template<> struct template_arity< second< na > > : int_<-1> { }; }

}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_if_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename Iterator, typename State >
struct iter_fold_if_null_step
{
    typedef State state;
    typedef Iterator iterator;
};

template< bool >
struct iter_fold_if_step_impl
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef typename apply2< StateOp,State,Iterator >::type state;
        typedef typename IteratorOp::type iterator;
    };
};

template<>
struct iter_fold_if_step_impl<false>
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef State state;
        typedef Iterator iterator;
    };
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename Predicate
    >
struct iter_fold_if_forward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,ForwardOp, mpl::next<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename BackwardOp
    , typename Predicate
    >
struct iter_fold_if_backward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,BackwardOp, identity<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename ForwardPredicate
    , typename BackwardOp
    , typename BackwardPredicate
    >
struct iter_fold_if_impl
{
 private:
    typedef iter_fold_if_null_step< Iterator,State > forward_step0;
    typedef iter_fold_if_forward_step< typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate > forward_step1;
    typedef iter_fold_if_forward_step< typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate > forward_step2;
    typedef iter_fold_if_forward_step< typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate > forward_step3;
    typedef iter_fold_if_forward_step< typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate > forward_step4;


    typedef typename if_<
          typename forward_step4::not_last
        , iter_fold_if_impl<
              typename forward_step4::iterator
            , typename forward_step4::state
            , ForwardOp
            , ForwardPredicate
            , BackwardOp
            , BackwardPredicate
            >
        , iter_fold_if_null_step<
              typename forward_step4::iterator
            , typename forward_step4::state
            >
        >::type backward_step4;

    typedef iter_fold_if_backward_step< typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate > backward_step3;
    typedef iter_fold_if_backward_step< typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate > backward_step2;
    typedef iter_fold_if_backward_step< typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate > backward_step1;
    typedef iter_fold_if_backward_step< typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate > backward_step0;


 public:
    typedef typename backward_step0::state state;
    typedef typename backward_step4::iterator iterator;
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold_if.hpp" 2







namespace boost { namespace mpl {

namespace aux {

template< typename Predicate, typename LastIterator >
struct iter_fold_if_pred
{
    template< typename State, typename Iterator > struct apply

        : and_<
              not_< is_same<Iterator,LastIterator> >
            , apply1<Predicate,Iterator>
            >
    {







    };
};

}

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    , typename ForwardPredicate = na
    , typename BackwardOp = na
    , typename BackwardPredicate = na
    >
struct iter_fold_if
{

    typedef typename begin<Sequence>::type first_;
    typedef typename end<Sequence>::type last_;

    typedef typename eval_if<
          is_na<BackwardPredicate>
        , if_< is_na<BackwardOp>, always<false_>, always<true_> >
        , identity<BackwardPredicate>
        >::type backward_pred_;



    struct result_ :



        aux::iter_fold_if_impl<
          first_
        , State
        , ForwardOp
        , protect< aux::iter_fold_if_pred< ForwardPredicate,last_ > >
        , BackwardOp
        , backward_pred_
        >

    { };




public:

    typedef pair<
          typename result_::state
        , typename result_::iterator
        > type;

   




};

template<> struct iter_fold_if< na , na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct apply : iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > { }; }; template< typename Tag > struct lambda< iter_fold_if< na , na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold_if< na , na , na , na , na , na > result_; typedef iter_fold_if< na , na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > > : int_<6> { }; template<> struct template_arity< iter_fold_if< na , na , na , na , na , na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find_if.hpp" 2




namespace boost { namespace mpl {



template<
      typename Sequence = na
    , typename Predicate = na
    >
struct find_if
{
    typedef typename iter_fold_if<
          Sequence
        , void
        , mpl::arg<1>
        , protect< aux::find_if_pred<Predicate> >
        >::type result_;

    typedef typename second<result_>::type type;

   
};

template<> struct find_if< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find_if< T1 , T2 > { }; }; template< typename Tag > struct lambda< find_if< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find_if< na , na > result_; typedef find_if< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find_if< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find_if< na , na > > : int_<-1> { }; }

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/same_as.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/same_as.hpp"
namespace boost { namespace mpl {

template< typename T1 >
struct same_as
{
    template< typename T2 > struct apply

        : is_same<T1,T2>
    {




    };
};

template< typename T1 >
struct not_same_as
{
    template< typename T2 > struct apply

        : not_< is_same<T1,T2> >
    {




    };
};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/find.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct find
    : find_if< Sequence,same_as<T> >
{
   
};

template<> struct find< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find< T1 , T2 > { }; }; template< typename Tag > struct lambda< find< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find< na , na > result_; typedef find< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find< na , na > > : int_<-1> { }; }

}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/contains_impl.hpp" 2







namespace boost { namespace mpl {

template< typename Tag >
struct contains_impl
{
    template< typename Sequence, typename T > struct apply

        : not_< is_same<
              typename find<Sequence,T>::type
            , typename end<Sequence>::type
            > >
    {
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/contains_impl.hpp"
    };
};

 template<> struct contains_impl<non_sequence_tag> {};

}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/contains.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct contains
    : contains_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};

template<> struct contains< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : contains< T1 , T2 > { }; }; template< typename Tag > struct lambda< contains< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef contains< na , na > result_; typedef contains< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< contains< T1 , T2 > > : int_<2> { }; template<> struct template_arity< contains< na , na > > : int_<-1> { }; }

}}
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/fold.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/fold.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/O1_size.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/O1_size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_size.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_size.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_size { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::size>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_size.hpp" 3
static const 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/has_size.hpp"
bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp" 2





namespace boost { namespace mpl {
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp"
namespace aux {
template< typename Sequence > struct O1_size_impl
    : Sequence::size
{
};
}

template< typename Tag >
struct O1_size_impl
{
    template< typename Sequence > struct apply

        : if_<
              aux::has_size<Sequence>
            , aux::O1_size_impl<Sequence>
            , long_<-1>
            >::type
    {
# 69 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp"
    };
};
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/O1_size_impl.hpp"
}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/O1_size.hpp" 2



namespace boost { namespace mpl {


template<
      typename Sequence = na
    >
struct O1_size
    : O1_size_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct O1_size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : O1_size< T1 > { }; }; template< typename Tag > struct lambda< O1_size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef O1_size< na > result_; typedef O1_size< na > type; }; namespace aux { template< typename T1 > struct template_arity< O1_size< T1 > > : int_<1> { }; template<> struct template_arity< O1_size< na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/fold.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/fold_impl.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/fold_impl.hpp" 2
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp, state0, typename deref<iter0>::type >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, state1, typename deref<iter1>::type >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, state2, typename deref<iter2>::type >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, state3, typename deref<iter3>::type >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl
{
    typedef fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,First,Last,State,ForwardOp >
    : fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/fold_impl.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/fold.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct fold
{
    typedef typename aux::fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , ForwardOp
        >::state type;

   
};

template<> struct fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef fold< na , na , na > result_; typedef fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/reverse_fold.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/reverse_fold.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/arg.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/reverse_fold.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/reverse_fold_impl.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/reverse_fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 0,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef fwd_state0 bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef fwd_state1 bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;
    typedef bkwd_state0 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 2,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef fwd_state2 bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 3,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef fwd_state3 bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< 4,First,Last,State,BackwardOp,ForwardOp >
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef fwd_state4 bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef iter4 iterator;
};

template<
      long N
    , typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl
{
    typedef First iter0;
    typedef State fwd_state0;
    typedef typename apply2< ForwardOp, fwd_state0, typename deref<iter0>::type >::type fwd_state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp, fwd_state1, typename deref<iter1>::type >::type fwd_state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp, fwd_state2, typename deref<iter2>::type >::type fwd_state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp, fwd_state3, typename deref<iter3>::type >::type fwd_state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef reverse_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , iter4
        , Last
        , fwd_state4
        , BackwardOp
        , ForwardOp
        > nested_chunk;

    typedef typename nested_chunk::state bkwd_state4;
    typedef typename apply2< BackwardOp, bkwd_state4, typename deref<iter3>::type >::type bkwd_state3;
    typedef typename apply2< BackwardOp, bkwd_state3, typename deref<iter2>::type >::type bkwd_state2;
    typedef typename apply2< BackwardOp, bkwd_state2, typename deref<iter1>::type >::type bkwd_state1;
    typedef typename apply2< BackwardOp, bkwd_state1, typename deref<iter0>::type >::type bkwd_state0;


    typedef bkwd_state0 state;
    typedef typename nested_chunk::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,First,Last,State,BackwardOp,ForwardOp >
{
    typedef reverse_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2<ForwardOp,State, typename deref<First>::type>::type
        , BackwardOp
        , ForwardOp
        > nested_step;

    typedef typename apply2<
          BackwardOp
        , typename nested_step::state
        , typename deref<First>::type
        >::type state;

    typedef typename nested_step::iterator iterator;
};

template<
      typename Last
    , typename State
    , typename BackwardOp
    , typename ForwardOp
    >
struct reverse_fold_impl< -1,Last,Last,State,BackwardOp,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/reverse_fold_impl.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/reverse_fold.hpp" 2


namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename BackwardOp = na
    , typename ForwardOp = arg<1>
    >
struct reverse_fold
{
    typedef typename aux::reverse_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , BackwardOp
        , ForwardOp
        >::state type;

   
};

template<> struct reverse_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_fold< na , na , na > result_; typedef reverse_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_fold< na , na , na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/inserter_algorithm.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/inserter_algorithm.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_inserter.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_inserter.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_back.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_back.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/push_back_impl.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/push_back_impl.hpp"
namespace boost { namespace mpl {

struct has_push_back_arg {};



template< typename Tag >
struct push_back_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST44 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg44; enum { mpl_assertion_in_line_44 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_back_arg >::value ))>( mpl_assert_arg44::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_back_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_back< Seq, has_push_back_arg > >
    {







    };
};

 template<> struct push_back_impl<non_sequence_tag> {};
 template<> struct has_push_back_impl<non_sequence_tag> {};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_back.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_back
    : push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_back
    : has_push_back_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};


template<> struct push_back< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_back< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_back< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_back< na , na > result_; typedef push_back< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_back< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_back< na , na > > : int_<-1> { }; }
template<> struct has_push_back< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_back< T1 > { }; }; template< typename Tag > struct lambda< has_push_back< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_back< na > result_; typedef has_push_back< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_back< T1 > > : int_<1> { }; template<> struct template_arity< has_push_back< na > > : int_<-1> { }; }

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_inserter.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/inserter.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/inserter.hpp"
namespace boost { namespace mpl {

template<
      typename Sequence
    , typename Operation
    >
struct inserter
{
    typedef Sequence state;
    typedef Operation operation;
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_inserter.hpp" 2

namespace boost {
namespace mpl {

template<
      typename Sequence
    >
struct back_inserter
    : inserter< Sequence,push_back<> >
{
};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/inserter_algorithm.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/front_inserter.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/front_inserter.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_front.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_front.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/push_front_impl.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/push_front_impl.hpp"
namespace boost { namespace mpl {

struct has_push_front_arg {};




template< typename Tag >
struct push_front_impl
{
    template< typename Sequence, typename T > struct apply
    {



        struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST; typedef struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST45 : boost::mpl::assert_ { static boost::mpl::failed ************ (REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************ assert_arg()) ( Sequence ) { return 0; } } mpl_assert_arg45; enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<(( boost::is_same< T, has_push_front_arg >::value ))>( mpl_assert_arg45::assert_arg() ) ) }



             ;
    };
};

template< typename Tag >
struct has_push_front_impl
{
    template< typename Seq > struct apply

        : aux::has_type< push_front< Seq, has_push_front_arg > >
    {







    };
};

 template<> struct push_front_impl<non_sequence_tag> {};
 template<> struct has_push_front_impl<non_sequence_tag> {};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/push_front.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct push_front
    : push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};


template<
      typename Sequence = na
    >
struct has_push_front
    : has_push_front_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct push_front< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : push_front< T1 , T2 > { }; }; template< typename Tag > struct lambda< push_front< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef push_front< na , na > result_; typedef push_front< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< push_front< T1 , T2 > > : int_<2> { }; template<> struct template_arity< push_front< na , na > > : int_<-1> { }; }
template<> struct has_push_front< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : has_push_front< T1 > { }; }; template< typename Tag > struct lambda< has_push_front< na > , Tag , int_<-1> > { typedef false_ is_le; typedef has_push_front< na > result_; typedef has_push_front< na > type; }; namespace aux { template< typename T1 > struct template_arity< has_push_front< T1 > > : int_<1> { }; template<> struct template_arity< has_push_front< na > > : int_<-1> { }; }

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/front_inserter.hpp" 2


namespace boost { namespace mpl {

template<
      typename Sequence
    >
struct front_inserter
    : inserter< Sequence,push_front<> >
{
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/inserter_algorithm.hpp" 2




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/clear.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/clear.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/clear_impl.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/clear_impl.hpp"
namespace boost { namespace mpl {



template< typename Tag >
struct clear_impl
{
    template< typename Sequence > struct apply;
};

 template<> struct clear_impl<non_sequence_tag> {};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/clear.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct clear
    : clear_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct clear< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : clear< T1 > { }; }; template< typename Tag > struct lambda< clear< na > , Tag , int_<-1> > { typedef false_ is_le; typedef clear< na > result_; typedef clear< na > type; }; namespace aux { template< typename T1 > struct template_arity< clear< T1 > > : int_<1> { }; template<> struct template_arity< clear< na > > : int_<-1> { }; }

}}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/inserter_algorithm.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/remove_if.hpp" 2

namespace boost { namespace mpl {

namespace aux {

template< typename Pred, typename InsertOp > struct remove_if_helper
{
    template< typename Sequence, typename U > struct apply
    {
        typedef typename eval_if<
              typename apply1<Pred,U>::type
            , identity<Sequence>
            , apply2<InsertOp,Sequence,U>
            >::type type;
    };
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct remove_if_impl
    : fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

template<
      typename Sequence
    , typename Predicate
    , typename Inserter
    >
struct reverse_remove_if_impl
    : reverse_fold<
          Sequence
        , typename Inserter::state
        , protect< aux::remove_if_helper<
              typename lambda<Predicate>::type
            , typename Inserter::operation
            > >
        >
{
};

}

 template< typename P1 = na , typename P2 = na , typename P3 = na > struct remove_if : aux::remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct remove_if< P1 , P2,na > : if_< has_push_back< typename clear<P1>::type> , aux::remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::reverse_remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template< typename P1 = na , typename P2 = na , typename P3 = na > struct reverse_remove_if : aux::reverse_remove_if_impl< P1 , P2 , P3> { }; template< typename P1 , typename P2 > struct reverse_remove_if< P1 , P2,na > : if_< has_push_back<P1> , aux::reverse_remove_if_impl< P1 , P2 , back_inserter< typename clear<P1>::type > > , aux::remove_if_impl< P1 , P2 , front_inserter< typename clear<P1>::type > > >::type { }; template<> struct remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef remove_if< na , na , na > result_; typedef remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< remove_if< na , na , na > > : int_<-1> { }; } template<> struct reverse_remove_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : reverse_remove_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< reverse_remove_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef reverse_remove_if< na , na , na > result_; typedef reverse_remove_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< reverse_remove_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< reverse_remove_if< na , na , na > > : int_<-1> { }; }

}}
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/limits/vector.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector20.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector20.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector10.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector10.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/at_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/at_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct at_impl;
template< typename Sequence, typename N > struct at;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/tag.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/tag.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/config/typeof.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/tag.hpp" 2


namespace boost { namespace mpl { namespace aux {

struct v_iter_tag;


struct vector_tag;




}}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp"
namespace boost { namespace mpl {



template< typename Vector, long n_ >
struct v_at_impl
{
    typedef long_< (Vector::lower_bound_::value + n_) > index_;
    typedef __typeof__( Vector::item_(index_()) ) type;
};


template< typename Vector, long n_ >
struct v_at
    : aux::wrapped_type< typename v_at_impl<Vector,n_>::type >
{
};

template<>
struct at_impl< aux::vector_tag >
{
    template< typename Vector, typename N > struct apply
        : v_at<
              Vector
            , N::value
            >
    {
    };
};
# 114 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/at.hpp"
}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/front.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/front.hpp"
namespace boost { namespace mpl {



template<>
struct front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<Vector,0>
    {
    };
};
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/front.hpp"
}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/push_front.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/push_front.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/item.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/item.hpp"
namespace boost { namespace mpl {



template<
      typename T
    , typename Base
    , int at_front = 0
    >
struct v_item
    : Base
{
    typedef typename Base::upper_bound_ index_;
    typedef typename next<index_>::type upper_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;



    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};

template<
      typename T
    , typename Base
    >
struct v_item<T,Base,1>
    : Base
{
    typedef typename prior<typename Base::lower_bound_>::type index_;
    typedef index_ lower_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;

    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};


template<
      typename Base
    , int at_front
    >
struct v_mask
    : Base
{
    typedef typename prior<typename Base::upper_bound_>::type index_;
    typedef index_ upper_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};

template<
      typename Base
    >
struct v_mask<Base,1>
    : Base
{
    typedef typename Base::lower_bound_ index_;
    typedef typename next<index_>::type lower_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;

    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};



}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/push_front.hpp" 2


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,1> type;
    };
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/pop_front.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/pop_front.hpp"
namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,1> type;
    };
};

}}
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/push_back.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/push_back.hpp"
namespace boost { namespace mpl {

template<>
struct push_back_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,0> type;
    };
};

}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/pop_back.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/pop_back.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pop_back_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/pop_back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct pop_back_impl;
template< typename Sequence > struct pop_back;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/pop_back.hpp" 2







namespace boost { namespace mpl {

template<>
struct pop_back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,0> type;
    };
};

}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/back.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/back.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_fwd.hpp" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/back_fwd.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct back_impl;
template< typename Sequence > struct back;

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/back.hpp" 2






namespace boost { namespace mpl {



template<>
struct back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<
              Vector
            , prior<typename Vector::size>::type::value
            >
    {
    };
};
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/back.hpp"
}}
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/clear.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/clear.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/vector0.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/vector0.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/plus.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/plus.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct plus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< plus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< plus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct plus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp"
       int value = 0;
    };
};

template< typename Tag > struct plus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp"
       int value = 0;
    };
};

template< typename Tag > struct plus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp"
       int value = 0;
    };
};

template< typename T > struct plus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct plus
    : plus< plus< plus< plus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct plus< N1,N2,N3,N4,na >

    : plus< plus< plus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct plus< N1,N2,N3,na,na >

    : plus< plus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct plus< N1,N2,na,na,na >
    : plus_impl<
          typename plus_tag<N1>::type
        , typename plus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct plus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : plus< T1 , T2 > { }; }; template< typename Tag > struct lambda< plus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef plus< na , na > result_; typedef plus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< plus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< plus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct plus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  + N2::value
                )
            >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/plus.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/minus.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/minus.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 1
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct minus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< minus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< minus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct minus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp"
       int value = 0;
    };
};

template< typename Tag > struct minus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp"
       int value = 0;
    };
};

template< typename Tag > struct minus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp"
       int value = 0;
    };
};

template< typename T > struct minus_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct minus
    : minus< minus< minus< minus< N1,N2 >, N3>, N4>, N5>
{
   




};

template<
      typename N1, typename N2, typename N3, typename N4
    >
struct minus< N1,N2,N3,N4,na >

    : minus< minus< minus< N1,N2 >, N3>, N4>
{
   




};

template<
      typename N1, typename N2, typename N3
    >
struct minus< N1,N2,N3,na,na >

    : minus< minus< N1,N2 >, N3>
{
   




};

template<
      typename N1, typename N2
    >
struct minus< N1,N2,na,na,na >
    : minus_impl<
          typename minus_tag<N1>::type
        , typename minus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   





};

template<> struct minus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : minus< T1 , T2 > { }; }; template< typename Tag > struct lambda< minus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef minus< na , na > result_; typedef minus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< minus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< minus< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {
template<>
struct minus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  - N2::value
                )
            >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/arithmetic_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/minus.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance_fwd.hpp"
namespace boost { namespace mpl {



template< typename Tag > struct advance_impl;
template< typename Iterator, typename N > struct advance;

}}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance_fwd.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance_fwd.hpp"
namespace boost { namespace mpl {



template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;

}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/prior.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp" 2





namespace boost { namespace mpl {

template<
      typename Vector
    , long n_
    >
struct v_iter
{
    typedef aux::v_iter_tag tag;
    typedef random_access_iterator_tag category;
    typedef typename v_at<Vector,n_>::type type;

    typedef Vector vector_;
    typedef mpl::long_<n_> pos;
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp"
};




template<
      typename Vector
    , long n_
    >
struct next< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ + 1)> type;
};

template<
      typename Vector
    , long n_
    >
struct prior< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ - 1)> type;
};

template<
      typename Vector
    , long n_
    , typename Distance
    >
struct advance< v_iter<Vector,n_>,Distance>
{
    typedef v_iter<
          Vector
        , (n_ + Distance::value)
        > type;
};

template<
      typename Vector
    , long n_
    , long m_
    >
struct distance< v_iter<Vector,n_>, v_iter<Vector,m_> >
    : mpl::long_<(m_ - n_)>
{
};
# 128 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/iterator.hpp"
}}
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/vector0.hpp" 2



namespace boost { namespace mpl {

template< typename Dummy = na > struct vector0;

template<> struct vector0<na>
{

    typedef aux::vector_tag tag;
    typedef vector0 type;
    typedef long_<32768> lower_bound_;
    typedef lower_bound_ upper_bound_;
    typedef long_<0> size;

    static aux::type_wrapper<void_> item_(...);
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/vector0.hpp"
};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/clear.hpp" 2




namespace boost { namespace mpl {



template<>
struct clear_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef vector0<> type;
    };
};
# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/clear.hpp"
}}
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/O1_size.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/O1_size.hpp"
namespace boost { namespace mpl {



template<>
struct O1_size_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : Vector::size
    {
    };
};
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/O1_size.hpp"
}}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/size.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/size.hpp"
namespace boost { namespace mpl {



template<>
struct size_impl< aux::vector_tag >
    : O1_size_impl< aux::vector_tag >
{
};
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/size.hpp"
}}
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/empty.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/empty.hpp"
namespace boost { namespace mpl {



template<>
struct empty_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : is_same<
              typename Vector::lower_bound_
            , typename Vector::upper_bound_
            >
    {
    };
};
# 66 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/empty.hpp"
}}
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/begin_end.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/begin_end.hpp"
namespace boost { namespace mpl {

template<>
struct begin_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,0> type;
    };
};

template<>
struct end_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,Vector::size::value> type;
    };
};

}}
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector0.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector10.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector10.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp"
namespace boost { namespace mpl {

template<
      typename T0
    >
struct vector1
    : v_item<
          T0
        , vector0< >
        >
{
    typedef vector1 type;
};

template<
      typename T0, typename T1
    >
struct vector2
    : v_item<
          T1
        , vector1<T0>
        >
{
    typedef vector2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector3
    : v_item<
          T2
        , vector2< T0,T1 >
        >
{
    typedef vector3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector4
    : v_item<
          T3
        , vector3< T0,T1,T2 >
        >
{
    typedef vector4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector5
    : v_item<
          T4
        , vector4< T0,T1,T2,T3 >
        >
{
    typedef vector5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector6
    : v_item<
          T5
        , vector5< T0,T1,T2,T3,T4 >
        >
{
    typedef vector6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector7
    : v_item<
          T6
        , vector6< T0,T1,T2,T3,T4,T5 >
        >
{
    typedef vector7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector8
    : v_item<
          T7
        , vector7< T0,T1,T2,T3,T4,T5,T6 >
        >
{
    typedef vector8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector9
    : v_item<
          T8
        , vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef vector9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector10
    : v_item<
          T9
        , vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef vector10 type;
};

}}
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector10.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector20.hpp" 2
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector20.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 1
# 49 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp"
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector11
    : v_item<
          T10
        , vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef vector11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector12
    : v_item<
          T11
        , vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef vector12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector13
    : v_item<
          T12
        , vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef vector13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector14
    : v_item<
          T13
        , vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef vector14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector15
    : v_item<
          T14
        , vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef vector15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector16
    : v_item<
          T15
        , vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef vector16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector17
    : v_item<
          T16
        , vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef vector17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector18
    : v_item<
          T17
        , vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef vector18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector19
    : v_item<
          T18
        , vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef vector19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector20
    : v_item<
          T19
        , vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef vector20 type;
};

}}
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/aux_/include_preprocessed.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector/vector20.hpp" 2
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp" 2
# 46 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp"
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct vector;

template<

    >
struct vector<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector0< >
{
    typedef vector0< >::type type;
};

template<
      typename T0
    >
struct vector<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector1<T0>
{
    typedef typename vector1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct vector<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector2< T0,T1 >
{
    typedef typename vector2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct vector<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector3< T0,T1,T2 >
{
    typedef typename vector3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector4< T0,T1,T2,T3 >
{
    typedef typename vector4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector5< T0,T1,T2,T3,T4 >
{
    typedef typename vector5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename vector6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename vector7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename vector8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : vector15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : vector16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : vector17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : vector18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : vector19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector
    : vector20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename vector20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 47 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/vector.hpp" 2
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/at.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/at.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/at_impl.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/at_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/negate.hpp" 1
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/negate.hpp"
namespace boost { namespace mpl {

template< typename Tag > struct negate_impl;

template< typename T > struct negate_tag
{
    typedef typename T::tag type;
};

template<
      typename N = na
    >
struct negate

    : negate_impl<
          typename negate_tag<N>::type
        >::template apply<N>::type






{
   
};

template<> struct negate< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : negate< T1 > { }; }; template< typename Tag > struct lambda< negate< na > , Tag , int_<-1> > { typedef false_ is_le; typedef negate< na > result_; typedef negate< na > type; }; namespace aux { template< typename T1 > struct template_arity< negate< T1 > > : int_<1> { }; template<> struct template_arity< negate< na > > : int_<-1> { }; }
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/negate.hpp"
template<>
struct negate_impl<integral_c_tag>
{




    template< typename N > struct apply
        : integral_c< typename N::value_type, (-N::value) >

    {
    };
};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_forward.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_forward.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_forward.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_forward.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp"
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_forward;
template<>
struct advance_forward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_forward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_forward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_forward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_forward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef typename next<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_forward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_forward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_forward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_forward.hpp" 2
# 25 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_backward.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_backward.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_backward.hpp" 2
# 32 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_backward.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp"
namespace boost { namespace mpl { namespace aux {

template< long N > struct advance_backward;
template<>
struct advance_backward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};

template<>
struct advance_backward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef iter1 type;
    };
};

template<>
struct advance_backward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef iter2 type;
    };
};

template<>
struct advance_backward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef iter3 type;
    };
};

template<>
struct advance_backward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef typename prior<iter3>::type iter4;
        typedef iter4 type;
    };
};

template< long N >
struct advance_backward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_backward<4>
            , Iterator
            >::type chunk_result_;

        typedef typename apply_wrap1<
              advance_backward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/advance_backward.hpp" 2
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/advance.hpp" 2




namespace boost { namespace mpl {


template< typename Tag >
struct advance_impl
{
    template< typename Iterator, typename N > struct apply
    {
        typedef typename less< N,long_<0> >::type backward_;
        typedef typename if_< backward_, negate<N>, N >::type offset_;

        typedef typename if_<
              backward_
            , aux::advance_backward< offset_::value >
            , aux::advance_forward< offset_::value >
            >::type f_;

        typedef typename apply_wrap1<f_,Iterator>::type type;
    };
};


template<
      typename Iterator = na
    , typename N = na
    >
struct advance
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,N>
{
};

template<
      typename Iterator
    , long N
    >
struct advance_c
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,long_<N> >
{
};

template<> struct advance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : advance< T1 , T2 > { }; }; template< typename Tag > struct lambda< advance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef advance< na , na > result_; typedef advance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< advance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< advance< na , na > > : int_<-1> { }; }

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/at_impl.hpp" 2



namespace boost { namespace mpl {




template< typename Tag >
struct at_impl
{
    template< typename Sequence, typename N > struct apply
    {
        typedef typename advance<
              typename begin<Sequence>::type
            , N
            >::type iter_;

        typedef typename deref<iter_>::type type;
    };
};

 template<> struct at_impl<non_sequence_tag> {};

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/at.hpp" 2






namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename N = na
    >
struct at
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,N >
{
   
};

template<
      typename Sequence
    , long N
    >
struct at_c
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,mpl::long_<N> >
{
};

template<> struct at< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : at< T1 , T2 > { }; }; template< typename Tag > struct lambda< at< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef at< na , na > result_; typedef at< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< at< T1 , T2 > > : int_<2> { }; template<> struct template_arity< at< na , na > > : int_<-1> { }; }

}}
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/size.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/size.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/size_impl.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/size_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_impl.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_impl.hpp" 2
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_impl.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp"
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,state3,iter3 >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl
{
    typedef iter_fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,First,Last,State,ForwardOp >
    : iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/iter_fold_impl.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iter_fold.hpp" 2



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct iter_fold
{
    typedef typename aux::iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<ForwardOp>::type
        >::state type;

   
};

template<> struct iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold< na , na , na > result_; typedef iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< iter_fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iterator_range.hpp" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/iterator_range.hpp"
namespace boost { namespace mpl {

struct iterator_range_tag;

template<
      typename First = na
    , typename Last = na
    >
struct iterator_range
{
    typedef iterator_range_tag tag;
    typedef iterator_range type;
    typedef First begin;
    typedef Last end;

   
};

template<> struct iterator_range< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_range< T1 , T2 > { }; }; template< typename Tag > struct lambda< iterator_range< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_range< na , na > result_; typedef iterator_range< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< iterator_range< T1 , T2 > > : int_<2> { }; template<> struct template_arity< iterator_range< na , na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp" 2







namespace boost { namespace mpl {


template< typename Tag > struct distance_impl
{
    template< typename First, typename Last > struct apply

        : aux::msvc_eti_base< typename iter_fold<
              iterator_range<First,Last>
            , mpl::long_<0>
            , next<>
            >::type >
    {
# 60 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/distance.hpp"
    };
};

template<
      typename First = na
    , typename Last = na
    >
struct distance
    : distance_impl< typename tag<First>::type >
        ::template apply<First, Last>
{
   
};

template<> struct distance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : distance< T1 , T2 > { }; }; template< typename Tag > struct lambda< distance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef distance< na , na > result_; typedef distance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< distance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< distance< na , na > > : int_<-1> { }; }

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/size_impl.hpp" 2



namespace boost { namespace mpl {




template< typename Tag >
struct size_impl
{
    template< typename Sequence > struct apply

        : distance<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {







    };
};

 template<> struct size_impl<non_sequence_tag> {};

}}
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/size.hpp" 2




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct size
    : aux::msvc_eti_base<
        typename size_impl< typename sequence_tag<Sequence>::type >
            ::template apply< Sequence >::type
      >::type
{
   
};

template<> struct size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : size< T1 > { }; }; template< typename Tag > struct lambda< size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef size< na > result_; typedef size< na > type; }; namespace aux { template< typename T1 > struct template_arity< size< T1 > > : int_<1> { }; template<> struct template_arity< size< na > > : int_<-1> { }; }

}}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/not_equal_to.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/not_equal_to.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct not_equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< not_equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< not_equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct not_equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
       int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
       int value = 0;
    };
};

template< typename Tag > struct not_equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/not_equal_to.hpp"
       int value = 0;
    };
};

template< typename T > struct not_equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct not_equal_to

    : not_equal_to_impl<
          typename not_equal_to_tag<N1>::type
        , typename not_equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct not_equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< not_equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_equal_to< na , na > result_; typedef not_equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< not_equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< not_equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct not_equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value != N2::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/not_equal_to.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp"
       int value = 0;
    };
};

template< typename Tag > struct greater_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp"
       int value = 0;
    };
};

template< typename Tag > struct greater_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp"
       int value = 0;
    };
};

template< typename T > struct greater_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater

    : greater_impl<
          typename greater_tag<N1>::type
        , typename greater_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater< na , na > result_; typedef greater< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value > N2::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater.hpp" 2
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less_equal.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less_equal.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
       int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
       int value = 0;
    };
};

template< typename Tag > struct less_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/less_equal.hpp"
       int value = 0;
    };
};

template< typename T > struct less_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less_equal

    : less_equal_impl<
          typename less_equal_tag<N1>::type
        , typename less_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< less_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less_equal< na , na > result_; typedef less_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value <= N2::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/less_equal.hpp" 2
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater_equal.hpp" 1
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater_equal.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 1
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/apply_wrap.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/numeric_op.hpp" 2
# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2







# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 3
       static const 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
       int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 3
       static const 
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
       int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 3
       static const 
# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp"
       int value = 0;
    };
};

template< typename T > struct greater_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater_equal

    : greater_equal_impl<
          typename greater_equal_tag<N1>::type
        , typename greater_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater_equal< na , na > result_; typedef greater_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value >= N2::value ) >
    {
    };
};

}}
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/aux_/comparison_op.hpp" 2
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/greater_equal.hpp" 2
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/mpl/comparison.hpp" 2
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp"
extern "C" {
#include <assert.h>
}
# 22 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2




# 1 "/scratch/products/gcc/v8_2_0/Linux64bit+3.10-2.17/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include-fixed/limits.h" 1 3 4
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
#include <stdlib.h>
# 1 "/scratch/products/gcc/v8_2_0/Linux64bit+3.10-2.17/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include/stddef.h" 1 3 4
# 29 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 2
#include <math.h>


# 31 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
namespace boost{ namespace math{

namespace tools{

template <class T>

# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
constexpr 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                    int digits() 
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                     noexcept
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                                                                                   ;
template <class T>

# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
constexpr 
# 38 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                    T epsilon() noexcept(std::is_floating_point<T>::value);

}

namespace policies{
# 197 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
enum error_policy_type
{
   throw_on_error = 0,
   errno_on_error = 1,
   ignore_error = 2,
   user_error = 3
};

template <error_policy_type N = throw_on_error> struct domain_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const domain_error<N>*); char test_is_default_arg(const domain_error<throw_on_error>*); template <class T> struct is_domain_error_imp { template <error_policy_type N> static char test(const domain_error<N>*); static double test(...); 
# 205 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 205 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_domain_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_domain_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct pole_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const pole_error<N>*); char test_is_default_arg(const pole_error<throw_on_error>*); template <class T> struct is_pole_error_imp { template <error_policy_type N> static char test(const pole_error<N>*); static double test(...); 
# 206 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 206 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_pole_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_pole_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct overflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const overflow_error<N>*); char test_is_default_arg(const overflow_error<throw_on_error>*); template <class T> struct is_overflow_error_imp { template <error_policy_type N> static char test(const overflow_error<N>*); static double test(...); 
# 207 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 207 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_overflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_overflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct underflow_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const underflow_error<N>*); char test_is_default_arg(const underflow_error<ignore_error>*); template <class T> struct is_underflow_error_imp { template <error_policy_type N> static char test(const underflow_error<N>*); static double test(...); 
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_underflow_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_underflow_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct denorm_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const denorm_error<N>*); char test_is_default_arg(const denorm_error<ignore_error>*); template <class T> struct is_denorm_error_imp { template <error_policy_type N> static char test(const denorm_error<N>*); static double test(...); 
# 209 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 209 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_denorm_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_denorm_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct evaluation_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const evaluation_error<N>*); char test_is_default_arg(const evaluation_error<throw_on_error>*); template <class T> struct is_evaluation_error_imp { template <error_policy_type N> static char test(const evaluation_error<N>*); static double test(...); 
# 210 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 210 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_evaluation_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_evaluation_error_imp<T>::value>{};
template <error_policy_type N = throw_on_error> struct rounding_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const rounding_error<N>*); char test_is_default_arg(const rounding_error<throw_on_error>*); template <class T> struct is_rounding_error_imp { template <error_policy_type N> static char test(const rounding_error<N>*); static double test(...); 
# 211 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 211 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_rounding_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_rounding_error_imp<T>::value>{};
template <error_policy_type N = ignore_error> struct indeterminate_result_error : public boost::mpl::int_<N>{}; namespace detail{ template <error_policy_type N> char test_is_valid_arg(const indeterminate_result_error<N>*); char test_is_default_arg(const indeterminate_result_error<ignore_error>*); template <class T> struct is_indeterminate_result_error_imp { template <error_policy_type N> static char test(const indeterminate_result_error<N>*); static double test(...); 
# 212 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 212 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_indeterminate_result_error : public boost::mpl::bool_< ::boost::math::policies::detail::is_indeterminate_result_error_imp<T>::value>{};




template <bool N = true> struct promote_float : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_float<N>*); char test_is_default_arg(const promote_float<true>*); template <class T> struct is_promote_float_imp { template <bool N> static char test(const promote_float<N>*); static double test(...); 
# 217 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 217 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_float : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_float_imp<T>::value>{};
template <bool N = true> struct promote_double : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const promote_double<N>*); char test_is_default_arg(const promote_double<true>*); template <class T> struct is_promote_double_imp { template <bool N> static char test(const promote_double<N>*); static double test(...); 
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_promote_double : public boost::mpl::bool_< ::boost::math::policies::detail::is_promote_double_imp<T>::value>{};
template <bool N = true> struct assert_undefined : public boost::mpl::bool_<N>{}; namespace detail{ template <bool N> char test_is_valid_arg(const assert_undefined<N>*); char test_is_default_arg(const assert_undefined<true>*); template <class T> struct is_assert_undefined_imp { template <bool N> static char test(const assert_undefined<N>*); static double test(...); 
# 219 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 219 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_assert_undefined : public boost::mpl::bool_< ::boost::math::policies::detail::is_assert_undefined_imp<T>::value>{};



enum discrete_quantile_policy_type
{
   real,
   integer_round_outwards,
   integer_round_inwards,
   integer_round_down,
   integer_round_up,
   integer_round_nearest
};

template <discrete_quantile_policy_type N = integer_round_outwards> struct discrete_quantile : public boost::mpl::int_<N>{}; namespace detail{ template <discrete_quantile_policy_type N> char test_is_valid_arg(const discrete_quantile<N>*); char test_is_default_arg(const discrete_quantile<integer_round_outwards>*); template <class T> struct is_discrete_quantile_imp { template <discrete_quantile_policy_type N> static char test(const discrete_quantile<N>*); static double test(...); 
# 233 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 233 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_discrete_quantile : public boost::mpl::bool_< ::boost::math::policies::detail::is_discrete_quantile_imp<T>::value>{};



template <int N = 0> struct digits10 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits10<N>*); char test_is_default_arg(const digits10<0>*); template <class T> struct is_digits10_imp { template <int N> static char test(const digits10<N>*); static double test(...); 
# 237 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 237 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits10 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits10_imp<T>::value>{};
template <int N = 0> struct digits2 : public boost::mpl::int_<N>{}; namespace detail{ template <int N> char test_is_valid_arg(const digits2<N>*); char test_is_default_arg(const digits2<0>*); template <class T> struct is_digits2_imp { template <int N> static char test(const digits2<N>*); static double test(...); 
# 238 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 238 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_digits2 : public boost::mpl::bool_< ::boost::math::policies::detail::is_digits2_imp<T>::value>{};



template <unsigned long N = 1000000> struct max_series_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_series_iterations<N>*); char test_is_default_arg(const max_series_iterations<1000000>*); template <class T> struct is_max_series_iterations_imp { template <unsigned long N> static char test(const max_series_iterations<N>*); static double test(...); 
# 242 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 242 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_series_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_series_iterations_imp<T>::value>{};
template <unsigned long N = 200> struct max_root_iterations : public boost::mpl::int_<N>{}; namespace detail{ template <unsigned long N> char test_is_valid_arg(const max_root_iterations<N>*); char test_is_default_arg(const max_root_iterations<200>*); template <class T> struct is_max_root_iterations_imp { template <unsigned long N> static char test(const max_root_iterations<N>*); static double test(...); 
# 243 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
static const 
# 243 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
bool value = sizeof(test(static_cast<T*>(0))) == 1; }; } template <class T> struct is_max_root_iterations : public boost::mpl::bool_< ::boost::math::policies::detail::is_max_root_iterations_imp<T>::value>{};







struct default_policy{};

namespace detail{



template <class Digits10, class Digits2>
struct precision
{



   typedef typename mpl::if_c<
      (Digits10::value == 0),
      digits2<0>,
      digits2<((Digits10::value + 1) * 1000L) / 301L>
   >::type digits2_type;
public:





   typedef typename mpl::if_c<
      (Digits2::value > digits2_type::value),
      Digits2, digits2_type>::type type;

};

template <class A, class B, bool b>
struct select_result
{
   typedef A type;
};
template <class A, class B>
struct select_result<A, B, false>
{
   typedef typename mpl::deref<B>::type type;
};

template <class Seq, class Pred, class DefaultType>
struct find_arg
{
private:
   typedef typename mpl::find_if<Seq, Pred>::type iter;
   typedef typename mpl::end<Seq>::type end_type;
public:
   typedef typename select_result<
      DefaultType, iter,
      ::boost::is_same<iter, end_type>::value>::type type;
};

double test_is_valid_arg(...);
double test_is_default_arg(...);
char test_is_valid_arg(const default_policy*);
char test_is_default_arg(const default_policy*);

template <class T>
struct is_valid_policy_imp
{
   
# 311 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
  static const 
# 311 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
  bool value = sizeof(::boost::math::policies::detail::test_is_valid_arg(static_cast<T*>(0))) == 1;
};

template <class T>
struct is_default_policy_imp
{
   
# 317 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
  static const 
# 317 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
  bool value = sizeof(::boost::math::policies::detail::test_is_default_arg(static_cast<T*>(0))) == 1;
};

template <class T> struct is_valid_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_valid_policy_imp<T>::value>
{};

template <class T> struct is_default_policy
: public mpl::bool_<
   ::boost::math::policies::detail::is_default_policy_imp<T>::value>
{
   template <class U>
   struct apply
   {
      typedef is_default_policy<U> type;
   };
};

template <class Seq, class T, int N>
struct append_N
{
   typedef typename mpl::push_back<Seq, T>::type new_seq;
   typedef typename append_N<new_seq, T, N-1>::type type;
};

template <class Seq, class T>
struct append_N<Seq, T, 0>
{
   typedef Seq type;
};





template <bool f, bool d>
struct default_args
{
   typedef promote_float<false> arg1;
   typedef promote_double<false> arg2;
};

template <>
struct default_args<false, false>
{
   typedef default_policy arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<true, false>
{
   typedef promote_float<false> arg1;
   typedef default_policy arg2;
};

template <>
struct default_args<false, true>
{
   typedef promote_double<false> arg1;
   typedef default_policy arg2;
};

typedef default_args<true, true>::arg1 forwarding_arg1;
typedef default_args<true, true>::arg2 forwarding_arg2;

}




template <class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct policy
{
private:



   static_assert(::boost::math::policies::detail::is_valid_policy<A1>::value, "::boost::math::policies::detail::is_valid_policy<A1>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A2>::value, "::boost::math::policies::detail::is_valid_policy<A2>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A3>::value, "::boost::math::policies::detail::is_valid_policy<A3>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A4>::value, "::boost::math::policies::detail::is_valid_policy<A4>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A5>::value, "::boost::math::policies::detail::is_valid_policy<A5>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A6>::value, "::boost::math::policies::detail::is_valid_policy<A6>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A7>::value, "::boost::math::policies::detail::is_valid_policy<A7>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A8>::value, "::boost::math::policies::detail::is_valid_policy<A8>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A9>::value, "::boost::math::policies::detail::is_valid_policy<A9>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A10>::value, "::boost::math::policies::detail::is_valid_policy<A10>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A11>::value, "::boost::math::policies::detail::is_valid_policy<A11>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A12>::value, "::boost::math::policies::detail::is_valid_policy<A12>::value");
   static_assert(::boost::math::policies::detail::is_valid_policy<A13>::value, "::boost::math::policies::detail::is_valid_policy<A13>::value");



   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;

public:
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, domain_error<> >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, pole_error<> >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, overflow_error<> >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, underflow_error<> >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, denorm_error<> >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, evaluation_error<> >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, rounding_error<> >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, indeterminate_result_error<> >::type indeterminate_result_error_type;
private:



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, digits2<> >::type bits_precision_type;
public:
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, promote_float<> >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, promote_double<> >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, discrete_quantile<> >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, assert_undefined<> >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, max_series_iterations<> >::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, max_root_iterations<> >::type max_root_iterations_type;
};





template <>
struct policy<default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<> promote_float_type;
   typedef promote_double<> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <>
struct policy<detail::forwarding_arg1, detail::forwarding_arg2, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>
{
public:
   typedef domain_error<> domain_error_type;
   typedef pole_error<> pole_error_type;
   typedef overflow_error<> overflow_error_type;
   typedef underflow_error<> underflow_error_type;
   typedef denorm_error<> denorm_error_type;
   typedef evaluation_error<> evaluation_error_type;
   typedef rounding_error<> rounding_error_type;
   typedef indeterminate_result_error<> indeterminate_result_error_type;

   typedef digits2<> precision_type;



   typedef promote_float<false> promote_float_type;
   typedef promote_double<false> promote_double_type;
   typedef discrete_quantile<> discrete_quantile_type;
   typedef assert_undefined<> assert_undefined_type;
   typedef max_series_iterations<> max_series_iterations_type;
   typedef max_root_iterations<> max_root_iterations_type;
};

template <class Policy,
          class A1 = default_policy,
          class A2 = default_policy,
          class A3 = default_policy,
          class A4 = default_policy,
          class A5 = default_policy,
          class A6 = default_policy,
          class A7 = default_policy,
          class A8 = default_policy,
          class A9 = default_policy,
          class A10 = default_policy,
          class A11 = default_policy,
          class A12 = default_policy,
          class A13 = default_policy>
struct normalise
{
private:
   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;
   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, typename Policy::domain_error_type >::type domain_error_type;
   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, typename Policy::pole_error_type >::type pole_error_type;
   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, typename Policy::overflow_error_type >::type overflow_error_type;
   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, typename Policy::underflow_error_type >::type underflow_error_type;
   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, typename Policy::denorm_error_type >::type denorm_error_type;
   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, typename Policy::evaluation_error_type >::type evaluation_error_type;
   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, typename Policy::rounding_error_type >::type rounding_error_type;
   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, typename Policy::indeterminate_result_error_type >::type indeterminate_result_error_type;



   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;
   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, typename Policy::precision_type >::type bits_precision_type;
   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;



   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, typename Policy::promote_float_type >::type promote_float_type;
   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, typename Policy::promote_double_type >::type promote_double_type;



   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, typename Policy::discrete_quantile_type >::type discrete_quantile_type;



   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, typename Policy::assert_undefined_type >::type assert_undefined_type;



   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, typename Policy::max_series_iterations_type>::type max_series_iterations_type;
   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, typename Policy::max_root_iterations_type>::type max_root_iterations_type;



   typedef mpl::vector<
      domain_error_type,
      pole_error_type,
      overflow_error_type,
      underflow_error_type,
      denorm_error_type,
      evaluation_error_type,
      rounding_error_type,
      indeterminate_result_error_type,
      precision_type,
      promote_float_type,
      promote_double_type,
      discrete_quantile_type,
      assert_undefined_type,
      max_series_iterations_type,
      max_root_iterations_type> result_list;



   typedef typename mpl::remove_if<result_list, detail::is_default_policy<mpl::_> >::type reduced_list;



   typedef typename detail::append_N<reduced_list, default_policy, (14 - ::boost::mpl::size<reduced_list>::value)>::type result_type;
public:
   typedef policy<
      typename mpl::at<result_type, mpl::int_<0> >::type,
      typename mpl::at<result_type, mpl::int_<1> >::type,
      typename mpl::at<result_type, mpl::int_<2> >::type,
      typename mpl::at<result_type, mpl::int_<3> >::type,
      typename mpl::at<result_type, mpl::int_<4> >::type,
      typename mpl::at<result_type, mpl::int_<5> >::type,
      typename mpl::at<result_type, mpl::int_<6> >::type,
      typename mpl::at<result_type, mpl::int_<7> >::type,
      typename mpl::at<result_type, mpl::int_<8> >::type,
      typename mpl::at<result_type, mpl::int_<9> >::type,
      typename mpl::at<result_type, mpl::int_<10> >::type,
      typename mpl::at<result_type, mpl::int_<11> >::type,
      typename mpl::at<result_type, mpl::int_<12> >::type > type;
};



template <>
struct normalise<policy<>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

template <>
struct normalise<policy<detail::forwarding_arg1, detail::forwarding_arg2>,
          promote_float<false>,
          promote_double<false>,
          discrete_quantile<>,
          assert_undefined<>,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy,
          default_policy>
{
   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;
};

inline 
# 647 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 647 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           policy<> make_policy() 
# 647 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                  noexcept

# 648 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{ return policy<>(); }

template <class A1>
inline 
# 651 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 651 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1>::type make_policy(const A1&) 
# 651 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                         noexcept

# 652 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1>::type result_type;
   return result_type();
}

template <class A1, class A2>
inline 
# 658 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 658 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2>::type make_policy(const A1&, const A2&) 
# 658 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                        noexcept

# 659 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3>
inline 
# 665 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 665 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3>::type make_policy(const A1&, const A2&, const A3&) 
# 665 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                       noexcept

# 666 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4>
inline 
# 672 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 672 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4>::type make_policy(const A1&, const A2&, const A3&, const A4&) 
# 672 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                      noexcept

# 673 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5>
inline 
# 679 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 679 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&) 
# 679 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                     noexcept

# 680 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6>
inline 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&) 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                    noexcept

# 687 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline 
# 693 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 693 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&) 
# 693 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                                   noexcept

# 694 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline 
# 700 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 700 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&) 
# 700 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                                                  noexcept

# 701 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline 
# 707 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 707 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&) 
# 707 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                                                                 noexcept

# 708 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline 
# 714 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 714 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&) 
# 714 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                                                                                  noexcept

# 715 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type result_type;
   return result_type();
}

template <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline 
# 721 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 721 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&, const A11&) 
# 721 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                                                                                                                                                                                   noexcept

# 722 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type result_type;
   return result_type();
}




template <class Real, class Policy>
struct evaluation
{
   typedef Real type;
};

template <class Policy>
struct evaluation<float, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_float_type, double, float>::type type;
};

template <class Policy>
struct evaluation<double, Policy>
{
   typedef typename mpl::if_<typename Policy::promote_double_type, long double, double>::type type;
};
# 797 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
template <class Real, class Policy>
struct precision
{
   static_assert((::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)), "(::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0))");

   typedef typename Policy::precision_type precision_type;
   typedef typename mpl::if_c<
      ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)),

      precision_type,
      typename mpl::if_c<
         ((::std::numeric_limits<Real>::digits <= precision_type::value)
         || (Policy::precision_type::value <= 0)),

         digits2< ::std::numeric_limits<Real>::digits>,

         precision_type
      >::type
   >::type type;
# 833 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
};
# 847 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
namespace detail{

template <class T, class Policy>
inline 
# 850 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 850 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           int digits_imp(mpl::true_ const&) 
# 850 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                             noexcept

# 851 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");



   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   return p_t::value;
}

template <class T, class Policy>
inline 
# 862 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 862 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           int digits_imp(mpl::false_ const&) 
# 862 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                              noexcept

# 863 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   return tools::digits<T>();
}

}

template <class T, class Policy>
inline 
# 870 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 870 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           int digits() 
# 870 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                            noexcept

# 871 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef mpl::bool_< std::numeric_limits<T>::is_specialized > tag_type;
   return detail::digits_imp<T, Policy>(tag_type());
}
template <class T, class Policy>
inline 
# 876 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 876 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           int digits_base10() 
# 876 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                                   noexcept

# 877 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   return boost::math::policies::digits<T, Policy>() * 301 / 1000L;
}

template <class Policy>
inline 
# 882 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 882 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           unsigned long get_max_series_iterations() 
# 882 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                     noexcept

# 883 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename Policy::max_series_iterations_type iter_type;
   return iter_type::value;
}

template <class Policy>
inline 
# 889 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 889 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           unsigned long get_max_root_iterations() 
# 889 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
                                                                   noexcept

# 890 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
{
   typedef typename Policy::max_root_iterations_type iter_type;
   return iter_type::value;
}

namespace detail{

template <class T, class Digits, class Small, class Default>
struct series_factor_calc
{
   static T get() noexcept(std::is_floating_point<T>::value)
   {
      return ldexp(T(1.0), 1 - Digits::value);
   }
};

template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::true_>
{
   static 
# 909 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
         constexpr 
# 909 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                              T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::true_, mpl::false_>
{
   static 
# 917 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
         constexpr 
# 917 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                              T get() noexcept(std::is_floating_point<T>::value)
   {
      return 1 / static_cast<T>(static_cast<boost::uintmax_t>(1u) << (Digits::value - 1));
   }
};
template <class T, class Digits>
struct series_factor_calc<T, Digits, mpl::false_, mpl::true_>
{
   static 
# 925 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
         constexpr 
# 925 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                              T get() noexcept(std::is_floating_point<T>::value)
   {
      return boost::math::tools::epsilon<T>();
   }
};

template <class T, class Policy>
inline 
# 932 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 932 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           T get_epsilon_imp(mpl::true_ const&) noexcept(std::is_floating_point<T>::value)
{

   static_assert(::std::numeric_limits<T>::is_specialized, "::std::numeric_limits<T>::is_specialized");
   static_assert(::std::numeric_limits<T>::radix == 2, "::std::numeric_limits<T>::radix == 2");




   typedef typename boost::math::policies::precision<T, Policy>::type p_t;
   typedef mpl::bool_<p_t::value <= std::numeric_limits<boost::uintmax_t>::digits> is_small_int;
   typedef mpl::bool_<p_t::value >= std::numeric_limits<T>::digits> is_default_value;
   return series_factor_calc<T, p_t, is_small_int, is_default_value>::get();
}

template <class T, class Policy>
inline 
# 948 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 948 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           T get_epsilon_imp(mpl::false_ const&) noexcept(std::is_floating_point<T>::value)
{
   return tools::epsilon<T>();
}

}

template <class T, class Policy>
inline 
# 956 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
      constexpr 
# 956 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
                           T get_epsilon() noexcept(std::is_floating_point<T>::value)
{
   typedef mpl::bool_< (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::radix == 2)) > tag_type;
   return detail::get_epsilon_imp<T, Policy>(tag_type());
}

namespace detail{

template <class A1,
          class A2,
          class A3,
          class A4,
          class A5,
          class A6,
          class A7,
          class A8,
          class A9,
          class A10,
          class A11>
char test_is_policy(const policy<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11>*);
double test_is_policy(...);

template <class P>
struct is_policy_imp
{
   
# 981 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
  static const 
# 981 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
  bool value = (sizeof(::boost::math::policies::detail::test_is_policy(static_cast<P*>(0))) == 1);
};

}

template <class P>
struct is_policy : public mpl::bool_< ::boost::math::policies::detail::is_policy_imp<P>::value> {};




template <class Policy>
struct constructor_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) || (domain_error_type::value == user_error) || (domain_error_type::value == errno_on_error),
      mpl::true_,
      mpl::false_>::type type;
};

template <class Policy>
struct method_error_check
{
   typedef typename Policy::domain_error_type domain_error_type;
   typedef typename mpl::if_c<
      (domain_error_type::value == throw_on_error) && (domain_error_type::value != user_error),
      mpl::false_,
      mpl::true_>::type type;
};



template <class Policy>
struct is_noexcept_error_policy
{
   typedef typename Policy::domain_error_type t1;
   typedef typename Policy::pole_error_type t2;
   typedef typename Policy::overflow_error_type t3;
   typedef typename Policy::underflow_error_type t4;
   typedef typename Policy::denorm_error_type t5;
   typedef typename Policy::evaluation_error_type t6;
   typedef typename Policy::rounding_error_type t7;
   typedef typename Policy::indeterminate_result_error_type t8;

   
# 1026 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp" 3
  static const 
# 1026 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/policies/policy.hpp"
  bool value = ((t1::value != throw_on_error) && (t1::value != user_error) && (t2::value != throw_on_error) && (t2::value != user_error) && (t3::value != throw_on_error) && (t3::value != user_error) && (t4::value != throw_on_error) && (t4::value != user_error) && (t5::value != throw_on_error) && (t5::value != user_error) && (t6::value != throw_on_error) && (t6::value != user_error) && (t7::value != throw_on_error) && (t7::value != user_error) && (t8::value != throw_on_error) && (t8::value != user_error))







                                                                     ;
};

}}}
# 30 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/no_tr1/complex.hpp" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/config/no_tr1/complex.hpp"
#include <complex>
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp" 2




# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/math_fwd.hpp"
namespace boost
{
   namespace math
   {


   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type
         beta(RT1 a, RT2 b);

   template <class RT1, class RT2, class A>
   typename tools::promote_args<RT1, RT2, A>::type
         beta(RT1 a, RT2 b, A x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         beta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         betac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac(RT1 a, RT2 b, RT3 x, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibeta_inv(T1 a, T2 b, T3 p, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inv(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_inva(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_invb(RT1 a, RT2 b, RT3 p, const Policy&);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ibetac_inv(T1 a, T2 b, T3 q, T4* py, const Policy& pol);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inv(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_inva(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibetac_invb(RT1 a, RT2 b, RT3 q, const Policy&);

   template <class RT1, class RT2, class RT3>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x);

   template <class RT1, class RT2, class RT3, class Policy>
   typename tools::promote_args<RT1, RT2, RT3>::type
         ibeta_derivative(RT1 a, RT2 b, RT3 x, const Policy& pol);


   template <class T, class Policy>
   T binomial_coefficient(unsigned n, unsigned k, const Policy& pol);
   template <class T>
   T binomial_coefficient(unsigned n, unsigned k);


   template <class RT>
   typename tools::promote_args<RT>::type erf(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erfc(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc(RT z, const Policy&);

   template <class RT>
   typename tools::promote_args<RT>::type erf_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erf_inv(RT z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type erfc_inv(RT z);
   template <class RT, class Policy>
   typename tools::promote_args<RT>::type erfc_inv(RT z, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, T x);
   template <class T>
   typename tools::promote_args<T>::type
          legendre_p_prime(int l, T x);


   template <class T, class Policy>
   inline std::vector<T> legendre_p_zeros(int l, const Policy& pol);

   template <class T>
   inline std::vector<T> legendre_p_zeros(int l);


   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_p(int l, T x, const Policy& pol);
   template <class T, class Policy>
   inline typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
      legendre_p_prime(int l, T x, const Policy& pol);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_q(unsigned l, T x);

   template <class T, class Policy>
   typename boost::enable_if_c<policies::is_policy<Policy>::value, typename tools::promote_args<T>::type>::type
         legendre_q(unsigned l, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         legendre_next(unsigned l, unsigned m, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
         legendre_p(int l, int m, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         laguerre_next(unsigned n, T1 x, T2 Ln, T3 Lnm1);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      laguerre_next(unsigned n, unsigned l, T1 x, T2 Pl, T3 Plm1);

   template <class T>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      laguerre(unsigned n, unsigned m, T x, const Policy& pol);

   template <class T1, class T2>
   struct laguerre_result
   {
      typedef typename mpl::if_<
         policies::is_policy<T2>,
         typename tools::promote_args<T1>::type,
         typename tools::promote_args<T2>::type
      >::type type;
   };

   template <class T1, class T2>
   typename laguerre_result<T1, T2>::type
      laguerre(unsigned n, T1 m, T2 x);

   template <class T>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type
      hermite(unsigned n, T x, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      hermite_next(unsigned n, T1 x, T2 Hn, T3 Hnm1);

   template<class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type chebyshev_next(T1 const & x, T2 const & Tn, T3 const & Tn_1);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_u(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_u(unsigned n, Real const & x);

   template <class Real, class Policy>
   typename tools::promote_args<Real>::type
      chebyshev_t_prime(unsigned n, Real const & x, const Policy&);
   template<class Real>
   typename tools::promote_args<Real>::type chebyshev_t_prime(unsigned n, Real const & x);

   template<class Real, class T2>
   Real chebyshev_clenshaw_recurrence(const Real* const c, size_t length, const T2& x);

   template <class T1, class T2>
   std::complex<typename tools::promote_args<T1, T2>::type>
         spherical_harmonic(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   std::complex<typename tools::promote_args<T1, T2>::type>
      spherical_harmonic(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_r(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
      spherical_harmonic_i(unsigned n, int m, T1 theta, T2 phi, const Policy& pol);


   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rf(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
         ellint_rd(T1 x, T2 y, T3 z, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         ellint_rc(T1 x, T2 y, const Policy& pol);

   template <class T1, class T2, class T3, class T4>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p);

   template <class T1, class T2, class T3, class T4, class Policy>
   typename tools::promote_args<T1, T2, T3, T4>::type
         ellint_rj(T1 x, T2 y, T3 z, T4 p, const Policy& pol);

   template <class T1, class T2, class T3>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type
      ellint_rg(T1 x, T2 y, T3 z, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_2(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_2(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_1(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_1(T1 k, T2 phi, const Policy& pol);

   template <typename T>
   typename tools::promote_args<T>::type ellint_d(T k);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type ellint_d(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type jacobi_zeta(T1 k, T2 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type heuman_lambda(T1 k, T2 phi, const Policy& pol);

   namespace detail{

   template <class T, class U, class V>
   struct ellint_3_result
   {
      typedef typename mpl::if_<
         policies::is_policy<V>,
         typename tools::promote_args<T, U>::type,
         typename tools::promote_args<T, U, V>::type
      >::type type;
   };

   }


   template <class T1, class T2, class T3>
   typename detail::ellint_3_result<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi);

   template <class T1, class T2, class T3, class Policy>
   typename tools::promote_args<T1, T2, T3>::type ellint_3(T1 k, T2 v, T3 phi, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type ellint_3(T1 k, T2 v);



   template <class RT>
   struct max_factorial;
   template <class RT>
   RT factorial(unsigned int);
   template <class RT, class Policy>
   RT factorial(unsigned int, const Policy& pol);
   template <class RT>
   RT unchecked_factorial(unsigned int );
   template <class RT>
   RT double_factorial(unsigned i);
   template <class RT, class Policy>
   RT double_factorial(unsigned i, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type falling_factorial(RT x, unsigned n, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type rising_factorial(RT x, int n, const Policy& pol);


   template <class RT>
   typename tools::promote_args<RT>::type tgamma(RT z);

   template <class RT>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type tgamma1pm1(RT z, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma(RT1 a, RT2 z, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT z, int* sign, const Policy& pol);

   template <class RT>
   typename tools::promote_args<RT>::type lgamma(RT x);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type lgamma(RT x, const Policy& pol);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type tgamma_lower(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_q(RT1 a, RT2 z, const Policy&);

   template <class RT1, class RT2>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z);

   template <class RT1, class RT2, class Policy>
   typename tools::promote_args<RT1, RT2>::type gamma_p(RT1 a, RT2 z, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_delta_ratio(T1 z, T2 delta, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type tgamma_ratio(T1 a, T2 b, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_derivative(T1 a, T2 x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_p_inva(T1 a, T2 p);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_p_inv(T1 a, T2 p, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inv(T1 a, T2 q, const Policy&);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type gamma_q_inva(T1 a, T2 q, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type digamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type digamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type trigamma(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type trigamma(T x, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type polygamma(int n, T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type polygamma(int n, T x, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         hypot(T1 x, T2 y, const Policy&);


   template <class RT>
   typename tools::promote_args<RT>::type cbrt(RT z);

   template <class RT, class Policy>
   typename tools::promote_args<RT>::type cbrt(RT z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1p(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1p(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type log1pmx(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type log1pmx(T, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type expm1(T);

   template <class T, class Policy>
   typename tools::promote_args<T>::type expm1(T, const Policy&);


   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z);

   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type
         powm1(const T1 a, const T2 z, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sqrt1pm1(const T& val, const Policy&);


   template <class T>
   typename tools::promote_args<T>::type sinc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinc_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sinhc_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sinhc_pi(T x, const Policy&);


   template<typename T>
   typename tools::promote_args<T>::type asinh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type asinh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type acosh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type acosh(T x, const Policy&);

   template<typename T>
   typename tools::promote_args<T>::type atanh(T x);

   template<typename T, class Policy>
   typename tools::promote_args<T>::type atanh(T x, const Policy&);

   namespace detail{

      typedef mpl::int_<0> bessel_no_int_tag;
      typedef mpl::int_<1> bessel_maybe_int_tag;
      typedef mpl::int_<2> bessel_int_tag;

      template <class T1, class T2, class Policy>
      struct bessel_traits
      {
         typedef typename mpl::if_<
            is_integral<T1>,
            typename tools::promote_args<T2>::type,
            typename tools::promote_args<T1, T2>::type
         >::type result_type;

         typedef typename policies::precision<result_type, Policy>::type precision_type;

         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<64> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag;
         typedef typename mpl::if_<
            mpl::or_<
               mpl::less_equal<precision_type, mpl::int_<0> >,
               mpl::greater<precision_type, mpl::int_<113> > >,
            bessel_no_int_tag,
            typename mpl::if_<
               is_integral<T1>,
               bessel_int_tag,
               bessel_maybe_int_tag
            >::type
         >::type optimisation_tag128;
      };
   }


   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_j_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_j_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_bessel_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_bessel_prime(unsigned v, T x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_i_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_i_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_bessel_k_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_bessel_k_prime(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann(T1 v, T2 x, const Policy& pol);
   template <class T1, class T2, class Policy>
   typename detail::bessel_traits<T1, T2, Policy>::result_type cyl_neumann_prime(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann(T1 v, T2 x);
   template <class T1, class T2>
   typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type cyl_neumann_prime(T1 v, T2 x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann(unsigned v, T x, const Policy& pol);
   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type sph_neumann_prime(unsigned v, T x, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann(unsigned v, T x);
   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type sph_neumann_prime(unsigned v, T x);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_bessel_j_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_bessel_j_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_bessel_j_zero(T v,
                          int start_index,
                          unsigned number_of_zeros,
                          OutputIterator out_it,
                          const Policy&);

   template <class T, class Policy>
   typename detail::bessel_traits<T, T, Policy>::result_type cyl_neumann_zero(T v, int m, const Policy& pol);

   template <class T>
   typename detail::bessel_traits<T, T, policies::policy<> >::result_type cyl_neumann_zero(T v, int m);

   template <class T, class OutputIterator>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it);

   template <class T, class OutputIterator, class Policy>
   OutputIterator cyl_neumann_zero(T v,
                         int start_index,
                         unsigned number_of_zeros,
                         OutputIterator out_it,
                         const Policy&);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> cyl_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> cyl_hankel_2(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_1(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_1(T1 v, T2 x);

   template <class T1, class T2, class Policy>
   std::complex<typename detail::bessel_traits<T1, T2, Policy>::result_type> sph_hankel_2(T1 v, T2 x, const Policy& pol);

   template <class T1, class T2>
   std::complex<typename detail::bessel_traits<T1, T2, policies::policy<> >::result_type> sph_hankel_2(T1 v, T2 x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_ai_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_ai_prime(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type airy_bi_prime(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type airy_bi_prime(T x);

   template <class T>
   T airy_ai_zero(int m);
   template <class T, class Policy>
   T airy_ai_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_ai_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T>
   T airy_bi_zero(int m);
   template <class T, class Policy>
   T airy_bi_zero(int m, const Policy&);

   template <class OutputIterator>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it);
   template <class OutputIterator, class Policy>
   OutputIterator airy_bi_zero(
                     int start_index,
                     unsigned number_of_zeros,
                     OutputIterator out_it,
                     const Policy&);

   template <class T, class Policy>
   typename tools::promote_args<T>::type sin_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type sin_pi(T x);

   template <class T, class Policy>
   typename tools::promote_args<T>::type cos_pi(T x, const Policy&);

   template <class T>
   typename tools::promote_args<T>::type cos_pi(T x);

   template <class T>
   int fpclassify (T t);

   template <class T>
   bool isfinite (T z);

   template <class T>
   bool isinf (T t);

   template <class T>
   bool isnan (T t);

   template <class T>
   bool isnormal (T t);

   template<class T>
   int signbit (T x);

   template <class T>
   int sign (const T& z);

   template <class T, class U>
   typename tools::promote_args_permissive<T, U>::type copysign (const T& x, const U& y);

   template <class T>
   typename tools::promote_args_permissive<T>::type changesign (const T& z);


   namespace detail{

   template <class T, class U>
   struct expint_result
   {
      typedef typename mpl::if_<
         policies::is_policy<U>,
         typename tools::promote_args<T>::type,
         typename tools::promote_args<U>::type
      >::type type;
   };

   }

   template <class T, class Policy>
   typename tools::promote_args<T>::type expint(unsigned n, T z, const Policy&);

   template <class T, class U>
   typename detail::expint_result<T, U>::type expint(T const z, U const u);

   template <class T>
   typename tools::promote_args<T>::type expint(T z);


   template <class T, class Policy>
   typename tools::promote_args<T>::type zeta(T s, const Policy&);


   template <class T1, class T2, class Policy>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a, const Policy& pol);

   template <class T1, class T2>
   typename tools::promote_args<T1, T2>::type owens_t(T1 h, T2 a);


   template <class T, class U, class V, class Policy>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn, V* pdn, const Policy&);

   template <class T, class U, class V>
   typename tools::promote_args<T, U, V>::type jacobi_elliptic(T k, U theta, V* pcn = 0, V* pdn = 0);

   template <class U, class T, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta, const Policy& pol);

   template <class U, class T>
   typename tools::promote_args<T, U>::type jacobi_sn(U k, T theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dn(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_dc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ns(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_ds(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_nd(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_sc(T k, U theta);

   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta, const Policy& pol);

   template <class T, class U>
   typename tools::promote_args<T, U>::type jacobi_cs(T k, U theta);


   template <class T>
   typename tools::promote_args<T>::type zeta(T s);


   template <int N, typename T, class Policy>
   typename tools::promote_args<T>::type pow(T base, const Policy& policy);

   template <int N, typename T>
   typename tools::promote_args<T>::type pow(T base);


   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type nextafter(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_next(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_next(const T&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_prior(const T&, const Policy&);
   template <class T>
   typename tools::promote_args<T>::type float_prior(const T&);
   template <class T, class U, class Policy>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&, const Policy&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type float_distance(const T&, const U&);
   template <class T, class Policy>
   typename tools::promote_args<T>::type float_advance(T val, int distance, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type float_advance(const T& val, int distance);

   template <class T, class Policy>
   typename tools::promote_args<T>::type ulp(const T& val, const Policy& pol);
   template <class T>
   typename tools::promote_args<T>::type ulp(const T& val);

   template <class T, class U>
   typename tools::promote_args<T, U>::type relative_difference(const T&, const U&);
   template <class T, class U>
   typename tools::promote_args<T, U>::type epsilon_difference(const T&, const U&);

   template<class T>
   constexpr T unchecked_bernoulli_b2n(const std::size_t n);
   template <class T, class Policy>
   T bernoulli_b2n(const int i, const Policy &pol);
   template <class T>
   T bernoulli_b2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator bernoulli_b2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);
   template <class T, class Policy>
   T tangent_t2n(const int i, const Policy &pol);
   template <class T>
   T tangent_t2n(const int i);
   template <class T, class OutputIterator, class Policy>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it,
                                       const Policy& pol);
   template <class T, class OutputIterator>
   OutputIterator tangent_t2n(const int start_index,
                                       const unsigned number_of_bernoullis_b2n,
                                       OutputIterator out_it);


   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_w0_prime(T z);
   template <class T, class Policy>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z, const Policy& pol);
   template <class T>
   typename boost::math::tools::promote_args<T>::type lambert_wm1_prime(T z);




    }
}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
#include <cstring>

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp" 1
# 58 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/assert.hpp"
extern "C" {
#include <assert.h>
}
# 26 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 27 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h" 2

# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/_prefix.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/_prefix.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/detail/_cassert.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/detail/_cassert.h"
#include <cassert>
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/_prefix.h" 2
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h" 2


# 1 "/scratch/products/gcc/v8_2_0/Linux64bit+3.10-2.17/lib/gcc/x86_64-pc-linux-gnu/8.2.0/include/stddef.h" 1 3 4
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h" 2
# 61 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/library/c/gnu.h"

# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h" 1
# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/ios.h" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/ios.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/ios.h" 2
# 51 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/ios.h"

# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h" 2
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h"

# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h" 1
# 65 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/macos.h"

# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 52 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 11 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 1
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 2
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 2
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 2
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 2
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 2
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 53 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 54 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h" 1
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/bsdi.h"

# 95 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h" 1
# 50 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/dragonfly.h"

# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h" 1
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/free.h"

# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h" 1
# 251 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/open.h"

# 98 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h" 1
# 84 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd/net.h"

# 99 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/bsd.h" 2



# 16 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/android.h" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/android.h"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/make.h" 1
# 13 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/android.h" 2
# 48 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/os/android.h"

# 17 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h" 2
# 194 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/predef/other/endian.h"










# 28 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 2
# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"

# 81 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
namespace boost {
namespace math {
namespace detail {
# 92 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
struct native_tag {};
template <bool has_limits>
struct generic_tag {};
struct ieee_tag {};
struct ieee_copy_all_bits_tag : public ieee_tag {};
struct ieee_copy_leading_bits_tag : public ieee_tag {};
# 125 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
struct unknown_precision{};
struct single_precision {};
struct double_precision {};
struct extended_double_precision {};



template<class T> struct fp_traits_native
{
    typedef native_tag method;
};



template<class T, class U> struct fp_traits_non_native
{

   typedef generic_tag<std::numeric_limits<T>::is_specialized> method;



};
# 177 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<> struct fp_traits_non_native<float, single_precision>
{
    typedef ieee_copy_all_bits_tag method;

    
# 181 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 181 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t sign = 0x80000000u;
    
# 182 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 182 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t exponent = 0x7f800000;
    
# 183 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 183 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t flag = 0x00000000;
    
# 184 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 184 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t significand = 0x007fffff;

    typedef uint32_t bits;
    static void get_bits(float x, uint32_t& a) { std::memcpy(&a, &x, 4); }
    static void set_bits(float& x, uint32_t a) { std::memcpy(&x, &a, 4); }
};
# 232 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<> struct fp_traits_non_native<double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = ((uint64_t)0x80000000u) << 32;
    static const uint64_t exponent = ((uint64_t)0x7ff00000) << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = (((uint64_t)0x000fffff) << 32) + ((uint64_t)0xffffffffu);

    typedef uint64_t bits;
    static void get_bits(double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
# 292 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<> struct fp_traits_non_native<long double, double_precision>
{
    typedef ieee_copy_all_bits_tag method;

    static const uint64_t sign = (uint64_t)0x80000000u << 32;
    static const uint64_t exponent = (uint64_t)0x7ff00000 << 32;
    static const uint64_t flag = 0;
    static const uint64_t significand
        = ((uint64_t)0x000fffff << 32) + (uint64_t)0xffffffffu;

    typedef uint64_t bits;
    static void get_bits(long double x, uint64_t& a) { std::memcpy(&a, &x, 8); }
    static void set_bits(long double& x, uint64_t a) { std::memcpy(&x, &a, 8); }
};
# 318 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<>
struct fp_traits_non_native<long double, extended_double_precision>
{
    typedef ieee_copy_leading_bits_tag method;

    
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 323 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t sign = 0x80000000u;
    
# 324 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 324 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t exponent = 0x7fff0000;
    
# 325 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 325 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t flag = 0x00008000;
    
# 326 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
   static const 
# 326 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
   uint32_t significand = 0x00007fff;

    typedef uint32_t bits;

    static void get_bits(long double x, uint32_t& a)
    {
        std::memcpy(&a, reinterpret_cast<const unsigned char*>(&x) + 6, 4);
    }

    static void set_bits(long double& x, uint32_t a)
    {
        std::memcpy(reinterpret_cast<unsigned char*>(&x) + 6, &a, 4);
    }
};
# 490 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<int n, bool fp> struct size_to_precision
{
   typedef unknown_precision type;
};

template<> struct size_to_precision<4, true>
{
    typedef single_precision type;
};

template<> struct size_to_precision<8, true>
{
    typedef double_precision type;
};

template<> struct size_to_precision<10, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<12, true>
{
    typedef extended_double_precision type;
};

template<> struct size_to_precision<16, true>
{
    typedef extended_double_precision type;
};






template <class T>
struct select_native
{
    typedef 
# 528 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
           typename 
# 528 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
                                  size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;
    typedef fp_traits_non_native<T, precision> type;
};
template<>
struct select_native<float>
{
    typedef fp_traits_native<float> type;
};
template<>
struct select_native<double>
{
    typedef fp_traits_native<double> type;
};
template<>
struct select_native<long double>
{
    typedef fp_traits_native<long double> type;
};
# 564 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
template<class T> struct fp_traits
{
    typedef 
# 566 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp" 3
           typename 
# 566 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/detail/fp_traits.hpp"
                                  size_to_precision<sizeof(T), ::boost::is_floating_point<T>::value>::type precision;

    typedef typename select_native<T>::type type;



    typedef fp_traits_non_native<T, precision> sign_change_type;
};



}
}
}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 2

namespace boost{ namespace math{

namespace detail {




    template<class T>
    inline int signbit_impl(T x, native_tag const&)
    {
        return (std::signbit)(x) ? 1 : 0;
    }





    template<class T>
    inline int signbit_impl(T x, generic_tag<true> const&)
    {
        return x < 0;
    }

    template<class T>
    inline int signbit_impl(T x, generic_tag<false> const&)
    {
        return x < 0;
    }
# 67 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
    template<class T>
    inline int signbit_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef 
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
               typename 
# 70 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                                      fp_traits<T>::type traits;

        
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
       typename 
# 72 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        return a & traits::sign ? 1 : 0;
    }

    template<class T>
    inline int signbit_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
               typename 
# 80 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                                      fp_traits<T>::type traits;

        
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
       typename 
# 82 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                              traits::bits a;
        traits::get_bits(x,a);

        return a & traits::sign ? 1 : 0;
    }






    template<class T>
    inline T (changesign_impl)(T x, generic_tag<true> const&)
    {
        return -x;
    }

    template<class T>
    inline T (changesign_impl)(T x, generic_tag<false> const&)
    {
        return -x;
    }
# 126 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
    template<class T>
    inline T changesign_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef 
# 129 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
               typename 
# 129 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                                      fp_traits<T>::sign_change_type traits;

        
# 131 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
       typename 
# 131 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }

    template<class T>
    inline T (changesign_impl)(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef 
# 141 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
               typename 
# 141 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                                      fp_traits<T>::sign_change_type traits;

        
# 143 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp" 3
       typename 
# 143 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/sign.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a ^= traits::sign;
        traits::set_bits(x,a);
        return x;
    }


}

template<class T> int (signbit)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;
   return detail::signbit_impl(static_cast<result_type>(x), method());
}

template <class T>
inline int sign (const T& z)
{
   return (z == 0) ? 0 : (boost::math::signbit)(z) ? -1 : 1;
}

template <class T> typename tools::promote_args_permissive<T>::type (changesign)(const T& x)
{
   typedef typename detail::fp_traits<T>::sign_change_type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type result_type;

   return detail::changesign_impl(static_cast<result_type>(x), method());
}

template <class T, class U>
inline typename tools::promote_args_permissive<T, U>::type
   copysign (const T& x, const U& y)
{
   using std::abs; using std::acos; using std::cos; using std::fmod; using std::modf; using std::tan; using std::asin; using std::cosh; using std::frexp; using std::pow; using std::tanh; using std::atan; using std::exp; using std::ldexp; using std::sin; using std::atan2; using std::fabs; using std::log; using std::sinh; using std::ceil; using std::floor; using std::log10; using std::sqrt; using boost::math::round; using boost::math::iround; using boost::math::lround; using boost::math::trunc; using boost::math::itrunc; using boost::math::ltrunc; using boost::math::modf;
   typedef typename tools::promote_args_permissive<T, U>::type result_type;
   return (boost::math::signbit)(static_cast<result_type>(x)) != (boost::math::signbit)(static_cast<result_type>(y))
      ? (boost::math::changesign)(static_cast<result_type>(x)) : static_cast<result_type>(x);
}

}
}
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 1
# 14 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
#include <math.h>


# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp" 1
# 15 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp"
namespace boost{ namespace math
{
  namespace tools
  {
    template <class To, class T>
    inline 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp" 3
          constexpr 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp"
                               To real_cast(T t) 
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp" 3
                                                 noexcept((
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp"
                                                 (std::is_floating_point<T>::value) && (std::is_floating_point<To>::value)
# 20 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp" 3
                                                 ))
    
# 21 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/tools/real_cast.hpp"
   {
       return static_cast<To>(t);
    }
  }
}
}
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 2
# 96 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
namespace boost{






namespace math_detail{






template <class T>
inline bool is_nan_helper(T t, const boost::true_type&)
{






   return (::std:: fpclassify(t) == (int)
# 119 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                                                        0
# 119 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                                              );

}





template <class T>
inline bool is_nan_helper(T, const boost::false_type&)
{
   return false;
}
# 145 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}

namespace math{

namespace detail{


template <class T>
inline int fpclassify_imp (T t, const native_tag&)
{
   return (std::fpclassify)(t);
}


template <class T>
inline int fpclassify_imp (T t, const generic_tag<true>&)
{
   ;



   if(::boost::math_detail::is_nan_helper(t, ::boost::is_floating_point<T>()))
      return 
# 167 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
            0
# 167 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                  ;
# 176 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
   T at = (t < T(0)) ? -t : t;







   if(at <= (std::numeric_limits<T>::max)())
   {
      if(at >= (std::numeric_limits<T>::min)())
         return 
# 187 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
               4
# 187 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                        ;
      return (at != 0) ? 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                        3 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                     : 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                                       2
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                              ;
   }
   else if(at > (std::numeric_limits<T>::max)())
      return 
# 191 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
            1
# 191 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                       ;
   return 
# 192 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
         0
# 192 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
               ;
}

template <class T>
inline int fpclassify_imp (T t, const generic_tag<false>&)
{
# 206 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
   ;

   return t == 0 ? 
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                  2 
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                          : 
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                            4
# 208 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                     ;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_all_bits_tag)
{
   typedef 
# 214 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
          typename 
# 214 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                 fp_traits<T>::type traits;

   ;

   
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
  typename 
# 218 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                         traits::bits a;
   traits::get_bits(x,a);
   ;
   a &= traits::exponent | traits::flag | traits::significand;
   ;
   ;

   if(a <= traits::significand) {
      if(a == 0)
         return 
# 227 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
               2
# 227 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                      ;
      else
         return 
# 229 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
               3
# 229 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                           ;
   }

   if(a < traits::exponent) return 
# 232 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                                  4
# 232 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                           ;

   a &= traits::significand;
   if(a == 0) return 
# 235 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                    1
# 235 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                               ;

   return 
# 237 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
         0
# 237 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
               ;
}

template<class T>
int fpclassify_imp (T x, ieee_copy_leading_bits_tag)
{
   typedef 
# 243 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
          typename 
# 243 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                 fp_traits<T>::type traits;

   ;

   
# 247 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
  typename 
# 247 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                         traits::bits a;
   traits::get_bits(x,a);
   a &= traits::exponent | traits::flag | traits::significand;

   if(a <= traits::significand) {
      if(x == 0)
         return 
# 253 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
               2
# 253 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                      ;
      else
         return 
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
               3
# 255 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                           ;
   }

   if(a < traits::exponent) return 
# 258 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                                  4
# 258 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                           ;

   a &= traits::significand;
   traits::set_bits(x,a);
   if(x == 0) return 
# 262 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
                    1
# 262 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                               ;

   return 
# 264 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3 4
         0
# 264 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
               ;
}
# 274 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}

template <class T>
inline int fpclassify (T t)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;
   typedef typename tools::promote_args_permissive<T>::type value_type;





   return detail::fpclassify_imp(static_cast<value_type>(t), method());

}
# 308 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
namespace detail {


    template<class T>
    inline bool isfinite_impl(T x, native_tag const&)
    {
        return (std::isfinite)(x);
    }


    template<class T>
    inline bool isfinite_impl(T x, generic_tag<true> const&)
    {
        return x >= -(std::numeric_limits<T>::max)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isfinite_impl(T x, generic_tag<false> const&)
    {




       (void)x;
       return true;
    }

    template<class T>
    inline bool isfinite_impl(T x, ieee_tag const&)
    {
        typedef 
# 339 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 339 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      detail::fp_traits<T>::type traits;
        
# 340 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 340 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent;
        return a != traits::exponent;
    }
# 353 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}

template<class T>
inline bool (isfinite)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isfinite_impl(static_cast<value_type>(x), method());
}
# 379 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
namespace detail {


    template<class T>
    inline bool isnormal_impl(T x, native_tag const&)
    {
        return (std::isnormal)(x);
    }


    template<class T>
    inline bool isnormal_impl(T x, generic_tag<true> const&)
    {
        if(x < 0) x = -x;
        return x >= (std::numeric_limits<T>::min)()
            && x <= (std::numeric_limits<T>::max)();
    }

    template<class T>
    inline bool isnormal_impl(T x, generic_tag<false> const&)
    {




       return !(x == 0);
    }

    template<class T>
    inline bool isnormal_impl(T x, ieee_tag const&)
    {
        typedef 
# 410 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 410 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      detail::fp_traits<T>::type traits;
        
# 411 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 411 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::flag;
        return (a != 0) && (a < traits::exponent);
    }
# 424 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}

template<class T>
inline bool (isnormal)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isnormal_impl(static_cast<value_type>(x), method());
}
# 450 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
namespace detail {


    template<class T>
    inline bool isinf_impl(T x, native_tag const&)
    {
        return (std::isinf)(x);
    }


    template<class T>
    inline bool isinf_impl(T x, generic_tag<true> const&)
    {
        (void)x;
        return std::numeric_limits<T>::has_infinity
            && ( x == std::numeric_limits<T>::infinity()
                 || x == -std::numeric_limits<T>::infinity());
    }

    template<class T>
    inline bool isinf_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef 
# 483 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 483 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      fp_traits<T>::type traits;

        
# 485 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 485 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a == traits::exponent;
    }

    template<class T>
    inline bool isinf_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef 
# 494 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 494 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      fp_traits<T>::type traits;

        
# 496 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 496 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        if(a != traits::exponent)
            return false;

        traits::set_bits(x,0);
        return x == 0;
    }
# 513 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}

template<class T>
inline bool (isinf)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   typedef typename tools::promote_args_permissive<T>::type value_type;
   return detail::isinf_impl(static_cast<value_type>(x), method());
}
# 546 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
namespace detail {


    template<class T>
    inline bool isnan_impl(T x, native_tag const&)
    {
        return (std::isnan)(x);
    }


    template<class T>
    inline bool isnan_impl(T x, generic_tag<true> const&)
    {
        return std::numeric_limits<T>::has_infinity
            ? !(x <= std::numeric_limits<T>::infinity())
            : x != x;
    }

    template<class T>
    inline bool isnan_impl(T x, generic_tag<false> const&)
    {




        (void)x;
        return false;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_all_bits_tag const&)
    {
        typedef 
# 578 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 578 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      fp_traits<T>::type traits;

        
# 580 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 580 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);
        a &= traits::exponent | traits::significand;
        return a > traits::exponent;
    }

    template<class T>
    inline bool isnan_impl(T x, ieee_copy_leading_bits_tag const&)
    {
        typedef 
# 589 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
               typename 
# 589 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                                      fp_traits<T>::type traits;

        
# 591 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp" 3
       typename 
# 591 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
                              traits::bits a;
        traits::get_bits(x,a);

        a &= traits::exponent | traits::significand;
        if(a < traits::exponent)
            return false;

        a &= traits::significand;
        traits::set_bits(x,a);
        return x != 0;
    }

}

template<class T>
inline bool (isnan)(T x)
{
   typedef typename detail::fp_traits<T>::type traits;
   typedef typename traits::method method;

   return detail::isnan_impl(x, method());
}
# 636 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/math/special_functions/fpclassify.hpp"
}
}
# 36 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 2



namespace boost {
    namespace detail
    {
        template <class CharT>
        bool lc_iequal(const CharT* val, const CharT* lcase, const CharT* ucase, unsigned int len) 
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                                                  noexcept 
# 43 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                                                 {
            for( unsigned int i=0; i < len; ++i ) {
                if ( val[i] != lcase[i] && val[i] != ucase[i] ) return false;
            }

            return true;
        }


        template <class CharT, class T>
        inline bool parse_inf_nan_impl(const CharT* begin, const CharT* end, T& value
            , const CharT* lc_NAN, const CharT* lc_nan
            , const CharT* lc_INFINITY, const CharT* lc_infinity
            , const CharT opening_brace, const CharT closing_brace) 
# 56 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                   noexcept
        
# 57 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
       {
            using namespace std;
            if (begin == end) return false;
            const CharT minus = lcast_char_constants<CharT>::minus;
            const CharT plus = lcast_char_constants<CharT>::plus;
            const int inifinity_size = 8;


            bool const has_minus = (*begin == minus);
            if (has_minus || *begin == plus) {
                ++ begin;
            }

            if (end - begin < 3) return false;
            if (lc_iequal(begin, lc_nan, lc_NAN, 3)) {
                begin += 3;
                if (end != begin) {


                    if (end - begin < 2) return false;
                    -- end;
                    if (*begin != opening_brace || *end != closing_brace) return false;
                }

                if( !has_minus ) value = std::numeric_limits<T>::quiet_NaN();
                else value = (boost::math::changesign) (std::numeric_limits<T>::quiet_NaN());
                return true;
            } else if (
                (
                  end - begin == 3
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, 3)
                )
                ||
                (
                  end - begin == inifinity_size
                  && lc_iequal(begin, lc_infinity, lc_INFINITY, inifinity_size)
                )
             )
            {
                if( !has_minus ) value = std::numeric_limits<T>::infinity();
                else value = (boost::math::changesign) (std::numeric_limits<T>::infinity());
                return true;
            }

            return false;
        }

        template <class CharT, class T>
        bool put_inf_nan_impl(CharT* begin, CharT*& end, const T& value
                         , const CharT* lc_nan
                         , const CharT* lc_infinity) 
# 107 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                    noexcept
        
# 108 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
       {
            using namespace std;
            const CharT minus = lcast_char_constants<CharT>::minus;
            if ((boost::math::isnan)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_nan, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            } else if ((boost::math::isinf)(value)) {
                if ((boost::math::signbit)(value)) {
                    *begin = minus;
                    ++ begin;
                }

                memcpy(begin, lc_infinity, 3 * sizeof(CharT));
                end = begin + 3;
                return true;
            }

            return false;
        }



        template <class T>
        bool parse_inf_nan(const wchar_t* begin, const wchar_t* end, T& value) 
# 137 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                              noexcept 
# 137 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                             {
            return parse_inf_nan_impl(begin, end, value
                               , L"NAN", L"nan"
                               , L"INFINITY", L"infinity"
                               , L'(', L')');
        }

        template <class T>
        bool put_inf_nan(wchar_t* begin, wchar_t*& end, const T& value) 
# 145 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                       noexcept 
# 145 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                      {
            return put_inf_nan_impl(begin, end, value, L"nan", L"infinity");
        }



        template <class T>
        bool parse_inf_nan(const char16_t* begin, const char16_t* end, T& value) 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                                noexcept 
# 152 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                               {
            return parse_inf_nan_impl(begin, end, value
                               , u"NAN", u"nan"
                               , u"INFINITY", u"infinity"
                               , u'(', u')');
        }

        template <class T>
        bool put_inf_nan(char16_t* begin, char16_t*& end, const T& value) 
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                         noexcept 
# 160 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                        {
            return put_inf_nan_impl(begin, end, value, u"nan", u"infinity");
        }


        template <class T>
        bool parse_inf_nan(const char32_t* begin, const char32_t* end, T& value) 
# 166 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                                noexcept 
# 166 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                               {
            return parse_inf_nan_impl(begin, end, value
                               , U"NAN", U"nan"
                               , U"INFINITY", U"infinity"
                               , U'(', U')');
        }

        template <class T>
        bool put_inf_nan(char32_t* begin, char32_t*& end, const T& value) 
# 174 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                         noexcept 
# 174 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                        {
            return put_inf_nan_impl(begin, end, value, U"nan", U"infinity");
        }


        template <class CharT, class T>
        bool parse_inf_nan(const CharT* begin, const CharT* end, T& value) 
# 180 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                          noexcept 
# 180 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                         {
            return parse_inf_nan_impl(begin, end, value
                               , "NAN", "nan"
                               , "INFINITY", "infinity"
                               , '(', ')');
        }

        template <class CharT, class T>
        bool put_inf_nan(CharT* begin, CharT*& end, const T& value) 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp" 3
                                                                   noexcept 
# 188 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/inf_nan.hpp"
                                                                                  {
            return put_inf_nan_impl(begin, end, value, "nan", "infinity");
        }
    }
}
# 64 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 77 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_fwd.hpp" 1
# 12 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_fwd.hpp"
#include <climits>




# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 18 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_fwd.hpp" 2


namespace boost
{







     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
# 42 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_fwd.hpp"
template < class T >
    class integer_traits;

template < >
    class integer_traits< bool >;

template < >
    class integer_traits< char >;

template < >
    class integer_traits< signed char >;

template < >
    class integer_traits< unsigned char >;


template < >
    class integer_traits< wchar_t >;


template < >
    class integer_traits< short >;

template < >
    class integer_traits< unsigned short >;

template < >
    class integer_traits< int >;

template < >
    class integer_traits< unsigned int >;

template < >
    class integer_traits< long >;

template < >
    class integer_traits< unsigned long >;


template < >
class integer_traits< ::boost::long_long_type>;

template < >
class integer_traits< ::boost::ulong_long_type >;
# 97 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer_fwd.hpp"
template < typename LeastInt >
    struct int_fast_t;

template< int Bits >
    struct int_t;

template< int Bits >
    struct uint_t;


    template< boost::long_long_type MaxValue >



    struct int_max_value_t;


  template< boost::long_long_type MinValue >



    struct int_min_value_t;


  template< boost::ulong_long_type MaxValue >



    struct uint_value_t;




template < std::size_t Bit >
    struct high_bit_mask_t;

template < std::size_t Bits >
    struct low_bits_mask_t;

template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;



template <static_log2_argument_type Value >
    struct static_log2;

template <> struct static_log2<0u>;




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;


namespace integer
{





     typedef boost::uintmax_t static_gcd_type;


template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_gcd;
template < static_gcd_type Value1, static_gcd_type Value2 >
    struct static_lcm;




template < typename IntegerType >
    class gcd_evaluator;
template < typename IntegerType >
    class lcm_evaluator;

}

}
# 19 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 2



# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/cstdint.hpp" 1
# 23 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 2
# 34 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
       
# 35 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3



# 37 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
namespace boost
{





  template< typename LeastInt >
  struct int_fast_t
  {
     typedef LeastInt fast;
     typedef fast type;
  };

  namespace detail{


  template< int Category > struct int_least_helper {};
  template< int Category > struct uint_least_helper {};





  template<> struct int_least_helper<1> { typedef boost::long_long_type least; };



  template<> struct int_least_helper<2> { typedef long least; };
  template<> struct int_least_helper<3> { typedef int least; };
  template<> struct int_least_helper<4> { typedef short least; };
  template<> struct int_least_helper<5> { typedef signed char least; };

  template<> struct uint_least_helper<1> { typedef boost::ulong_long_type least; };



  template<> struct uint_least_helper<2> { typedef unsigned long least; };
  template<> struct uint_least_helper<3> { typedef unsigned int least; };
  template<> struct uint_least_helper<4> { typedef unsigned short least; };
  template<> struct uint_least_helper<5> { typedef unsigned char least; };

  template <int Bits>
  struct exact_signed_base_helper{};
  template <int Bits>
  struct exact_unsigned_base_helper{};

  template <> struct exact_signed_base_helper<sizeof(signed char)* 8> { typedef signed char exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned char)* 8> { typedef unsigned char exact; };

  template <> struct exact_signed_base_helper<sizeof(short)* 8> { typedef short exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned short)* 8> { typedef unsigned short exact; };


  template <> struct exact_signed_base_helper<sizeof(int)* 8> { typedef int exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned int)* 8> { typedef unsigned int exact; };



  template <> struct exact_signed_base_helper<sizeof(long)* 8> { typedef long exact; };
  template <> struct exact_unsigned_base_helper<sizeof(unsigned long)* 8> { typedef unsigned long exact; };
# 109 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
  }




  template< int Bits >
  struct int_t : public boost::detail::exact_signed_base_helper<Bits>
  {
      
# 117 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
     static_assert(
# 117 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
     Bits <= (int)(sizeof(boost::intmax_t) * 8), "No suitable signed integer type with the requested number of bits is available."
# 117 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
     )
                                                                                           
# 118 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
                                                                                          ;
      typedef typename boost::detail::int_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits-1 <= ::std::numeric_limits<long>::digits) +
          (Bits-1 <= ::std::numeric_limits<int>::digits) +
          (Bits-1 <= ::std::numeric_limits<short>::digits) +
          (Bits-1 <= ::std::numeric_limits<signed char>::digits)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< int Bits >
  struct uint_t : public boost::detail::exact_unsigned_base_helper<Bits>
  {
     
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
    static_assert(
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
    Bits <= (int)(sizeof(boost::uintmax_t) * 8), "No suitable unsigned integer type with the requested number of bits is available."
# 138 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp"
    )
                                                                                             
# 139 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
                                                                                            ;
# 150 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
      typedef typename boost::detail::uint_least_helper
        <

          (Bits <= (int)(sizeof(boost::long_long_type) * 8)) +



          (Bits <= ::std::numeric_limits<unsigned long>::digits) +
          (Bits <= ::std::numeric_limits<unsigned int>::digits) +
          (Bits <= ::std::numeric_limits<unsigned short>::digits) +
          (Bits <= ::std::numeric_limits<unsigned char>::digits)
        >::least least;

      typedef typename int_fast_t<least>::type fast;

  };





  template< boost::long_long_type MaxValue >



  struct int_max_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::long_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<long>::const_max) +
          (MaxValue <= ::boost::integer_traits<int>::const_max) +
          (MaxValue <= ::boost::integer_traits<short>::const_max) +
          (MaxValue <= ::boost::integer_traits<signed char>::const_max)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };


  template< boost::long_long_type MinValue >



  struct int_min_value_t
  {
      typedef typename boost::detail::int_least_helper
        <

          (MinValue >= ::boost::integer_traits<boost::long_long_type>::const_min) +



          (MinValue >= ::boost::integer_traits<long>::const_min) +
          (MinValue >= ::boost::integer_traits<int>::const_min) +
          (MinValue >= ::boost::integer_traits<short>::const_min) +
          (MinValue >= ::boost::integer_traits<signed char>::const_min)
        >::least least;
      typedef typename int_fast_t<least>::type fast;
  };



  template< boost::ulong_long_type MaxValue >



  struct uint_value_t
  {
# 243 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/integer.hpp" 3
      typedef typename boost::detail::uint_least_helper
        <

          (MaxValue <= ::boost::integer_traits<boost::ulong_long_type>::const_max) +



          (MaxValue <= ::boost::integer_traits<unsigned long>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned int>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned short>::const_max) +
          (MaxValue <= ::boost::integer_traits<unsigned char>::const_max)
        >::least least;

      typedef typename int_fast_t<least>::type fast;
  };


}
# 78 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2
# 1 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/basic_pointerbuf.hpp" 1
# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/basic_pointerbuf.hpp"

# 24 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/detail/basic_pointerbuf.hpp"
namespace boost { namespace detail {





template <class charT, class BufferT >
class basic_pointerbuf : public BufferT {
protected:
   typedef BufferT base_type;
   typedef basic_pointerbuf<charT, BufferT> this_type;
   typedef typename base_type::int_type int_type;
   typedef typename base_type::char_type char_type;
   typedef typename base_type::pos_type pos_type;
   typedef ::std::streamsize streamsize;
   typedef typename base_type::off_type off_type;

public:
   basic_pointerbuf() : base_type() { this_type::setbuf(0, 0); }
   const charT* getnext() { return this->gptr(); }


    using base_type::pptr;
    using base_type::pbase;





protected:




   inline base_type* setbuf(char_type* s, streamsize n);
   inline typename this_type::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);
   inline typename this_type::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);

private:
   basic_pointerbuf& operator=(const basic_pointerbuf&);
   basic_pointerbuf(const basic_pointerbuf&);
};

template<class charT, class BufferT>
BufferT*
basic_pointerbuf<charT, BufferT>::setbuf(char_type* s, streamsize n)
{
   this->setg(s, s, s + n);
   return this;
}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
{
   typedef typename boost::int_t<sizeof(way) * 8>::least cast_type;

   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   std::ptrdiff_t size = this->egptr() - this->eback();
   std::ptrdiff_t pos = this->gptr() - this->eback();
   charT* g = this->eback();
   switch(static_cast<cast_type>(way))
   {
   case ::std::ios_base::beg:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + off, g + size);
      break;
   case ::std::ios_base::end:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + size - off, g + size);
      break;
   case ::std::ios_base::cur:
   {
      std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
      if((newpos < 0) || (newpos > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + newpos, g + size);
      break;
   }
   default: ;
   }




   return static_cast<pos_type>(this->gptr() - this->eback());



}

template<class charT, class BufferT>
typename basic_pointerbuf<charT, BufferT>::pos_type
basic_pointerbuf<charT, BufferT>::seekpos(pos_type sp, ::std::ios_base::openmode which)
{
   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   off_type size = static_cast<off_type>(this->egptr() - this->eback());
   charT* g = this->eback();
   if(off_type(sp) <= size)
   {
      this->setg(g, g + off_type(sp), g + size);
   }
   return pos_type(off_type(-1));
}

}}
# 79 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 2


#include <cwchar>


namespace boost {

    namespace detail
    {


        template <class BufferType, class CharT>
        class basic_unlockedbuf : public basic_pointerbuf<CharT, BufferType> {
        public:
           typedef basic_pointerbuf<CharT, BufferType> base_type;
           typedef 
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                  typename 
# 94 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                         base_type::streamsize streamsize;


            using base_type::pptr;
            using base_type::pbase;
            using base_type::setbuf;





        };
    }

    namespace detail
    {
        struct do_not_construct_out_buffer_t{};
        struct do_not_construct_out_stream_t{
            do_not_construct_out_stream_t(do_not_construct_out_buffer_t*){}
        };

        template <class CharT, class Traits>
        struct out_stream_helper_trait {
# 125 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
            typedef std::basic_ostream<CharT, Traits> out_stream_t;
            typedef basic_unlockedbuf<std::basic_stringbuf<CharT, Traits>, CharT> stringbuffer_t;
            typedef basic_unlockedbuf<std::basic_streambuf<CharT, Traits>, CharT> buffer_t;

        };
    }

    namespace detail
    {
        template< class CharT
                , class Traits
                , bool RequiresStringbuffer
                , std::size_t CharacterBufferSize
                >
        class lexical_istream_limited_src: boost::noncopyable {
            typedef 
# 140 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                   typename 
# 140 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                          boost::conditional<
                RequiresStringbuffer,
                
# 142 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
               typename 
# 142 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                      out_stream_helper_trait<CharT, Traits>::out_stream_t,
                do_not_construct_out_stream_t
            >::type deduced_out_stream_t;

            typedef 
# 146 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                   typename 
# 146 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                          boost::conditional<
                RequiresStringbuffer,
                
# 148 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
               typename 
# 148 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                      out_stream_helper_trait<CharT, Traits>::stringbuffer_t,
                do_not_construct_out_buffer_t
            >::type deduced_out_buffer_t;

            deduced_out_buffer_t out_buffer;
            deduced_out_stream_t out_stream;
            CharT buffer[CharacterBufferSize];



            const CharT* start;
            const CharT* finish;

        public:
            lexical_istream_limited_src() 
# 162 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                         noexcept
              
# 163 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
             : out_buffer()
              , out_stream(&out_buffer)
              , start(buffer)
              , finish(buffer + CharacterBufferSize)
            {}

            const CharT* cbegin() const 
# 169 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                       noexcept 
# 169 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                      {
                return start;
            }

            const CharT* cend() const 
# 173 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                     noexcept 
# 173 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                    {
                return finish;
            }

        private:

            bool shl_char(CharT ch) 
# 179 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                   noexcept 
# 179 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                  {
                Traits::assign(buffer[0], ch);
                finish = start + 1;
                return true;
            }


            template <class T>
            bool shl_char(T ch) {
                static_assert(( sizeof(T) <= sizeof(CharT)) , "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead")

                                                 ;

                std::locale loc;
                CharT const w = 
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                               std::use_facet< 
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                               std::ctype<CharT> 
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                               >(
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                               loc
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                               )
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                      .widen(ch);



                Traits::assign(buffer[0], w);
                finish = start + 1;
                return true;
            }


            bool shl_char_array(CharT const* str_value) 
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                       noexcept 
# 203 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                      {
                start = str_value;
                finish = start + Traits::length(str_value);
                return true;
            }

            template <class T>
            bool shl_char_array(T const* str_value) {
                static_assert(( sizeof(T) <= sizeof(CharT)), "boost::lexical_cast does not support narrowing of char types." "Use boost::locale instead")

                                                 ;
                return shl_input_streamable(str_value);
            }

            bool shl_char_array_limited(CharT const* str, std::size_t max_size) 
# 217 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                               noexcept 
# 217 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                              {
                start = str;
                finish = std::find(start, start + max_size, Traits::to_char_type(0));
                return true;
            }

            template<typename InputStreamable>
            bool shl_input_streamable(InputStreamable& input) {







                out_stream.exceptions(std::ios::badbit);
                try {

                bool const result = !(out_stream << input).fail();
                const deduced_out_buffer_t* const p = static_cast<deduced_out_buffer_t*>(
                    out_stream.rdbuf()
                );
                start = p->pbase();
                finish = p->pptr();
                return result;

                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template <class T>
            inline bool shl_unsigned(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                start = lcast_put_unsigned<Traits, T, CharT>(n, tmp_finish).convert();
                finish = tmp_finish;
                return true;
            }

            template <class T>
            inline bool shl_signed(const T n) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                typedef 
# 260 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                       typename 
# 260 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                              boost::make_unsigned<T>::type utype;
                CharT* tmp_start = lcast_put_unsigned<Traits, utype, CharT>(lcast_to_unsigned(n), tmp_finish).convert();
                if (n < 0) {
                    --tmp_start;
                    CharT const minus = lcast_char_constants<CharT>::minus;
                    Traits::assign(*tmp_start, minus);
                }
                start = tmp_start;
                finish = tmp_finish;
                return true;
            }

            template <class T, class SomeCharT>
            bool shl_real_type(const T& val, SomeCharT* ) {
                lcast_set_precision(out_stream, &val);
                return shl_input_streamable(val);
            }

            bool shl_real_type(float val, char* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<float>()), val_as_double);
                return finish > start;
            }

            bool shl_real_type(double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*g", static_cast<int>(boost::detail::lcast_get_precision<double>()), val);
                return finish > start;
            }


            bool shl_real_type(long double val, char* begin) {
                using namespace std;
                finish = start +



                    sprintf(begin,

                    "%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double>()), val );
                return finish > start;
            }




            bool shl_real_type(float val, wchar_t* begin) {
                using namespace std;
                const double val_as_double = val;
                finish = start + swprintf(begin, CharacterBufferSize,
                                       L"%.*g",
                                       static_cast<int>(boost::detail::lcast_get_precision<float >()),
                                       val_as_double );
                return finish > start;
            }

            bool shl_real_type(double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*g", static_cast<int>(boost::detail::lcast_get_precision<double >()), val );
                return finish > start;
            }

            bool shl_real_type(long double val, wchar_t* begin) {
                using namespace std;
                finish = start + swprintf(begin, CharacterBufferSize,
                                          L"%.*Lg", static_cast<int>(boost::detail::lcast_get_precision<long double >()), val );
                return finish > start;
            }

            template <class T>
            bool shl_real(T val) {
                CharT* tmp_finish = buffer + CharacterBufferSize;
                if (put_inf_nan(buffer, tmp_finish, val)) {
                    finish = tmp_finish;
                    return true;
                }

                return shl_real_type(val, static_cast<CharT*>(buffer));
            }


        public:
            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str) 
# 357 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                             noexcept 
# 357 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                            {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            template<class Alloc>
            bool operator<<(boost::container::basic_string<CharT,Traits,Alloc> const& str) 
# 364 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                                          noexcept 
# 364 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                                         {
                start = str.data();
                finish = start + str.length();
                return true;
            }

            bool operator<<(bool value) 
# 370 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                       noexcept 
# 370 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                      {
                CharT const czero = lcast_char_constants<CharT>::zero;
                Traits::assign(buffer[0], Traits::to_char_type(czero + value));
                finish = start + 1;
                return true;
            }

            template <class C>
            
# 378 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
           typename 
# 378 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                  boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(const iterator_range<C*>& rng) 
# 379 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                     noexcept 
# 379 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                    {
                return (*this) << iterator_range<const C*>(rng.begin(), rng.end());
            }

            bool operator<<(const iterator_range<const CharT*>& rng) 
# 383 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                    noexcept 
# 383 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                   {
                start = rng.begin();
                finish = rng.end();
                return true;
            }

            bool operator<<(const iterator_range<const signed char*>& rng) 
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                          noexcept 
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                         {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(const iterator_range<const unsigned char*>& rng) 
# 396 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                            noexcept 
# 396 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                           {
                return (*this) << iterator_range<const char*>(
                    reinterpret_cast<const char*>(rng.begin()),
                    reinterpret_cast<const char*>(rng.end())
                );
            }

            bool operator<<(char ch) { return shl_char(ch); }
            bool operator<<(unsigned char ch) { return ((*this) << static_cast<char>(ch)); }
            bool operator<<(signed char ch) { return ((*this) << static_cast<char>(ch)); }

            bool operator<<(wchar_t const* str) { return shl_char_array(str); }
            bool operator<<(wchar_t * str) { return shl_char_array(str); }

            bool operator<<(wchar_t ch) { return shl_char(ch); }



            bool operator<<(char16_t ch) { return shl_char(ch); }
            bool operator<<(char16_t * str) { return shl_char_array(str); }
            bool operator<<(char16_t const * str) { return shl_char_array(str); }


            bool operator<<(char32_t ch) { return shl_char(ch); }
            bool operator<<(char32_t * str) { return shl_char_array(str); }
            bool operator<<(char32_t const * str) { return shl_char_array(str); }

            bool operator<<(unsigned char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(unsigned char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(signed char const* ch) { return ((*this) << reinterpret_cast<char const*>(ch)); }
            bool operator<<(signed char * ch) { return ((*this) << reinterpret_cast<char *>(ch)); }
            bool operator<<(char const* str_value) { return shl_char_array(str_value); }
            bool operator<<(char* str_value) { return shl_char_array(str_value); }
            bool operator<<(short n) { return shl_signed(n); }
            bool operator<<(int n) { return shl_signed(n); }
            bool operator<<(long n) { return shl_signed(n); }
            bool operator<<(unsigned short n) { return shl_unsigned(n); }
            bool operator<<(unsigned int n) { return shl_unsigned(n); }
            bool operator<<(unsigned long n) { return shl_unsigned(n); }


            bool operator<<(boost::ulong_long_type n) { return shl_unsigned(n); }
            bool operator<<(boost::long_long_type n) { return shl_signed(n); }






            bool operator<<(const boost::uint128_type& n) { return shl_unsigned(n); }
            bool operator<<(const boost::int128_type& n) { return shl_signed(n); }

            bool operator<<(float val) { return shl_real(val); }
            bool operator<<(double val) { return shl_real(val); }
            bool operator<<(long double val) {

                return shl_real(val);



            }


            template <class C, std::size_t N>
            
# 460 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
           typename 
# 460 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                  boost::disable_if<boost::is_const<C>, bool>::type
            operator<<(boost::array<C, N> const& input) 
# 461 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                       noexcept 
# 461 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                      {
                static_assert((sizeof(boost::array<const C, N>) == sizeof(boost::array<C, N>)), "boost::array<C, N> and boost::array<const C, N> must have exactly the same layout.")


                 ;
                return ((*this) << reinterpret_cast<boost::array<const C, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const CharT, N> const& input) 
# 470 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                      noexcept 
# 470 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                     {
                return shl_char_array_limited(input.data(), N);
            }

            template <std::size_t N>
            bool operator<<(boost::array<const unsigned char, N> const& input) 
# 475 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                              noexcept 
# 475 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                             {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }

            template <std::size_t N>
            bool operator<<(boost::array<const signed char, N> const& input) 
# 480 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                            noexcept 
# 480 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                           {
                return ((*this) << reinterpret_cast<boost::array<const char, N> const& >(input));
            }



            template <class C, std::size_t N>
            bool operator<<(std::array<C, N> const& input) 
# 487 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                          noexcept 
# 487 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                         {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array and boost::array must have exactly the same layout. " "Bug in implementation of std::array or boost::array.")



                 ;
                return ((*this) << reinterpret_cast<boost::array<C, N> const& >(input));
            }

            template <class InStreamable>
            bool operator<<(const InStreamable& input) { return shl_input_streamable(input); }
        };


        template <class CharT, class Traits>
        class lexical_ostream_limited_src: boost::noncopyable {

            const CharT* start;
            const CharT* const finish;

        public:
            lexical_ostream_limited_src(const CharT* begin, const CharT* end) 
# 508 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                             noexcept
              
# 509 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
             : start(begin)
              , finish(end)
            {}


        private:
            template <typename Type>
            bool shr_unsigned(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool const succeed = lcast_ret_unsigned<Traits, Type, CharT>(output, start, finish).convert();

                if (has_minus) {
                    output = static_cast<Type>(0u - output);
                }

                return succeed;
            }

            template <typename Type>
            bool shr_signed(Type& output) {
                if (start == finish) return false;
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                typedef 
# 541 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                       typename 
# 541 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                              make_unsigned<Type>::type utype;
                utype out_tmp = 0;
                bool const has_minus = Traits::eq(minus, *start);


                if (has_minus || Traits::eq(plus, *start)) {
                    ++start;
                }

                bool succeed = lcast_ret_unsigned<Traits, utype, CharT>(out_tmp, start, finish).convert();
                if (has_minus) {
                    utype const comp_val = (static_cast<utype>(1) << std::numeric_limits<Type>::digits);
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(0u - out_tmp);
                } else {
                    utype const comp_val = static_cast<utype>((std::numeric_limits<Type>::max)());
                    succeed = succeed && out_tmp<=comp_val;
                    output = static_cast<Type>(out_tmp);
                }
                return succeed;
            }

            template<typename InputStreamable>
            bool shr_using_base_class(InputStreamable& output)
            {
                static_assert((!boost::is_pointer<InputStreamable>::value), "boost::lexical_cast can not convert to pointers")


                 ;
# 581 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                typedef 
# 581 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                       typename 
# 581 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                              out_stream_helper_trait<CharT, Traits>::buffer_t buffer_t;
                buffer_t buf;


                buf.setbuf(const_cast<CharT*>(start), static_cast<typename buffer_t::streamsize>(finish - start));



                std::basic_istream<CharT, Traits> stream(&buf);




                stream.exceptions(std::ios::badbit);
                try {

                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable*>(0));

                return (stream >> output)
                    && (stream.get() == Traits::eof());


                } catch (const ::std::ios_base::failure& ) {
                    return false;
                }

            }

            template<class T>
            inline bool shr_xchar(T& output) 
# 611 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                            noexcept 
# 611 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                           {
                static_assert(( sizeof(CharT) == sizeof(T) ), "boost::lexical_cast does not support narrowing of character types." "Use boost::locale instead")

                                                 ;
                bool const ok = (finish - start == 1);
                if (ok) {
                    CharT out;
                    Traits::assign(out, *start);
                    output = static_cast<T>(out);
                }
                return ok;
            }

            template <std::size_t N, class ArrayT>
            bool shr_std_array(ArrayT& output) 
# 625 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                              noexcept 
# 625 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                             {
                using namespace std;
                const std::size_t size = static_cast<std::size_t>(finish - start);
                if (size > N - 1) {
                    return false;
                }

                memcpy(&output[0], start, size * sizeof(CharT));
                output[size] = Traits::to_char_type(0);
                return true;
            }


        public:
            bool operator>>(unsigned short& output) { return shr_unsigned(output); }
            bool operator>>(unsigned int& output) { return shr_unsigned(output); }
            bool operator>>(unsigned long int& output) { return shr_unsigned(output); }
            bool operator>>(short& output) { return shr_signed(output); }
            bool operator>>(int& output) { return shr_signed(output); }
            bool operator>>(long int& output) { return shr_signed(output); }

            bool operator>>(boost::ulong_long_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::long_long_type& output) { return shr_signed(output); }






            bool operator>>(boost::uint128_type& output) { return shr_unsigned(output); }
            bool operator>>(boost::int128_type& output) { return shr_signed(output); }


            bool operator>>(char& output) { return shr_xchar(output); }
            bool operator>>(unsigned char& output) { return shr_xchar(output); }
            bool operator>>(signed char& output) { return shr_xchar(output); }

            bool operator>>(wchar_t& output) { return shr_xchar(output); }


            bool operator>>(char16_t& output) { return shr_xchar(output); }


            bool operator>>(char32_t& output) { return shr_xchar(output); }

            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template<class Alloc>
            bool operator>>(boost::container::basic_string<CharT,Traits,Alloc>& str) {
                str.assign(start, finish); return true;
            }

            template <std::size_t N>
            bool operator>>(boost::array<CharT, N>& output) 
# 681 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                           noexcept 
# 681 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                          {
                return shr_std_array<N>(output);
            }

            template <std::size_t N>
            bool operator>>(boost::array<unsigned char, N>& output) 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                   noexcept 
# 686 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                  {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }

            template <std::size_t N>
            bool operator>>(boost::array<signed char, N>& output) 
# 691 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                                 noexcept 
# 691 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                                {
                return ((*this) >> reinterpret_cast<boost::array<char, N>& >(output));
            }


            template <class C, std::size_t N>
            bool operator>>(std::array<C, N>& output) 
# 697 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                                     noexcept 
# 697 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                                    {
                static_assert((sizeof(std::array<C, N>) == sizeof(boost::array<C, N>)), "std::array<C, N> and boost::array<C, N> must have exactly the same layout.")


                 ;
                return ((*this) >> reinterpret_cast<boost::array<C, N>& >(output));
            }


            bool operator>>(bool& output) 
# 706 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp" 3
                                         noexcept 
# 706 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical_streams.hpp"
                                                        {
                output = false;

                if (start == finish) return false;
                CharT const zero = lcast_char_constants<CharT>::zero;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const minus = lcast_char_constants<CharT>::minus;

                const CharT* const dec_finish = finish - 1;
                output = Traits::eq(*dec_finish, zero + 1);
                if (!output && !Traits::eq(*dec_finish, zero)) {
                    return false;
                }

                if (start == dec_finish) return true;


                if (Traits::eq(plus, *start) || (Traits::eq(minus, *start) && !output)) {
                    ++ start;
                }


                while (start != dec_finish) {
                    if (!Traits::eq(zero, *start)) {
                        return false;
                    }

                    ++ start;
                }

                return true;
            }

        private:

            template <class T>
            bool float_types_converter_internal(T& output) {
                if (parse_inf_nan(start, finish, output)) return true;
                bool const return_value = shr_using_base_class(output);







                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const capital_e = lcast_char_constants<CharT>::capital_e;
                CharT const lowercase_e = lcast_char_constants<CharT>::lowercase_e;
                if ( return_value &&
                     (
                        Traits::eq(*(finish-1), lowercase_e)
                        || Traits::eq(*(finish-1), capital_e)
                        || Traits::eq(*(finish-1), minus)
                        || Traits::eq(*(finish-1), plus)
                     )
                ) return false;

                return return_value;
            }

        public:
            bool operator>>(float& output) { return float_types_converter_internal(output); }
            bool operator>>(double& output) { return float_types_converter_internal(output); }
            bool operator>>(long double& output) { return float_types_converter_internal(output); }



            template <typename InputStreamable>
            bool operator>>(InputStreamable& output) {
                return shr_using_base_class(output);
            }
        };
    }
}
# 55 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 2

namespace boost {

    namespace detail
    {

        template < class Char >
        struct normalize_single_byte_char
        {
            typedef Char type;
        };

        template <>
        struct normalize_single_byte_char< signed char >
        {
            typedef char type;
        };

        template <>
        struct normalize_single_byte_char< unsigned char >
        {
            typedef char type;
        };
    }

    namespace detail
    {


        template < class T > struct deduce_character_type_later {};
    }

    namespace detail
    {



        template < typename Type >
        struct stream_char_common: public boost::conditional<
            boost::detail::is_character< Type >::value,
            Type,
            boost::detail::deduce_character_type_later< Type >
        > {};

        template < typename Char >
        struct stream_char_common< Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< Char* >
        > {};

        template < typename Char >
        struct stream_char_common< const Char* >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< const Char* >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< Char* > >
        > {};

        template < typename Char >
        struct stream_char_common< boost::iterator_range< const Char* > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::iterator_range< const Char* > >
        > {};

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< std::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < class Char, class Traits, class Alloc >
        struct stream_char_common< boost::container::basic_string< Char, Traits, Alloc > >
        {
            typedef Char type;
        };

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< boost::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< boost::array< const Char, N > >
        > {};


        template < typename Char, std::size_t N >
        struct stream_char_common< std::array<Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< Char, N > >
        > {};

        template < typename Char, std::size_t N >
        struct stream_char_common< std::array< const Char, N > >: public boost::conditional<
            boost::detail::is_character< Char >::value,
            Char,
            boost::detail::deduce_character_type_later< std::array< const Char, N > >
        > {};



        template <> struct stream_char_common< boost::int128_type >: public boost::type_identity< char > {};
        template <> struct stream_char_common< boost::uint128_type >: public boost::type_identity< char > {};
# 181 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
    }

    namespace detail
    {





        template < class Char >
        struct deduce_source_char_impl
        {
            typedef 
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 193 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::detail::normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_source_char_impl< deduce_character_type_later< T > >
        {
            typedef boost::has_left_shift< std::basic_ostream< char >, T > result_t;






            typedef 
# 206 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 206 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_left_shift< std::basic_ostream< type >, T >::value), "Source type is neither std::ostream`able nor std::wostream`able")
                                                                                  ;

        };
    }

    namespace detail
    {





        template < class Char >
        struct deduce_target_char_impl
        {
            typedef 
# 226 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 226 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          normalize_single_byte_char< Char >::type type;
        };

        template < class T >
        struct deduce_target_char_impl< deduce_character_type_later<T> >
        {
            typedef boost::has_right_shift<std::basic_istream<char>, T > result_t;






            typedef 
# 239 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 239 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::conditional<
                result_t::value, char, wchar_t
            >::type type;

            static_assert((result_t::value || boost::has_right_shift<std::basic_istream<wchar_t>, T >::value), "Target type is neither std::istream`able nor std::wistream`able")
                                                                                  ;

        };
    }

    namespace detail
    {
# 266 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
        template < class T >
        struct deduce_target_char
        {
            typedef 
# 269 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 269 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          stream_char_common< T >::type stage1_type;
            typedef 
# 270 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 270 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          deduce_target_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };

        template < class T >
        struct deduce_source_char
        {
            typedef 
# 278 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 278 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          stream_char_common< T >::type stage1_type;
            typedef 
# 279 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 279 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          deduce_source_char_impl< stage1_type >::type stage2_type;

            typedef stage2_type type;
        };
    }

    namespace detail
    {


        template < class Char, class T >
        struct extract_char_traits
                : boost::false_type
        {
            typedef std::char_traits< Char > trait_t;
        };

        template < class Char, class Traits, class Alloc >
        struct extract_char_traits< Char, std::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };

        template < class Char, class Traits, class Alloc>
        struct extract_char_traits< Char, boost::container::basic_string< Char, Traits, Alloc > >
            : boost::true_type
        {
            typedef Traits trait_t;
        };
    }

    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };

        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };
    }

    namespace detail
    {

        template< class Source,
                  class Enable = void
                >
        struct lcast_src_length
        {
            
# 334 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
           static const 
# 334 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
           std::size_t value = 1;
        };
# 350 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
        template <class Source>
        struct lcast_src_length<
                    Source, 
# 352 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                           typename 
# 352 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                                  boost::enable_if<boost::is_integral<Source> >::type
                >
        {

            
# 356 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
           static const 
# 356 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
           std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2



               ;




        };
# 377 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
        template<class Source>
        struct lcast_src_length<
                Source, 
# 379 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                       typename 
# 379 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                              boost::enable_if<boost::is_float<Source> >::type
            >
        {


            static_assert(std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L, "std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L")


                 ;

            
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
           static const 
# 389 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
           std::size_t value = 5 + lcast_precision<Source>::value + 6

                 ;



        };
    }

    namespace detail
    {
        template <class Source, class Target>
        struct lexical_cast_stream_traits {
            typedef 
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 402 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::detail::array_to_pointer_decay<Source>::type src;
            typedef 
# 403 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 403 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::remove_cv<src>::type no_cv_src;

            typedef boost::detail::deduce_source_char<no_cv_src> deduce_src_char_metafunc;
            typedef 
# 406 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 406 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          deduce_src_char_metafunc::type src_char_t;
            typedef 
# 407 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 407 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::detail::deduce_target_char<Target>::type target_char_t;

            typedef 
# 409 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 409 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::detail::widest_char<
                target_char_t, src_char_t
            >::type char_type;
# 424 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
            typedef 
# 424 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 424 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          boost::conditional<
                boost::detail::extract_char_traits<char_type, Target>::value,
                
# 426 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 426 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      boost::detail::extract_char_traits<char_type, Target>,
                
# 427 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 427 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      boost::detail::extract_char_traits<char_type, no_cv_src>
            >::type::trait_t traits;

            typedef boost::integral_constant<
              bool,
              boost::is_same<char, src_char_t>::value &&
                (sizeof(char) != sizeof(target_char_t)) &&
                (!(boost::detail::is_character<no_cv_src>::value))
             > is_string_widening_required_t;

            typedef boost::integral_constant<
              bool,
             !(boost::is_integral<no_cv_src>::value ||
                  boost::detail::is_character<
                    
# 441 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
                   typename 
# 441 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                          deduce_src_char_metafunc::stage1_type
                  >::value
              )
             > is_source_input_not_optimized_t;



            
# 448 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
           static const 
# 448 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
           bool requires_stringbuf = (is_string_widening_required_t::value || is_source_input_not_optimized_t::value)

             ;

            typedef boost::detail::lcast_src_length<no_cv_src> len_t;
        };
    }

    namespace detail
    {
        template<typename Target, typename Source>
        struct lexical_converter_impl
        {
            typedef lexical_cast_stream_traits<Source, Target> stream_trait;

            typedef detail::lexical_istream_limited_src<
                
# 464 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 464 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      stream_trait::char_type,
                
# 465 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 465 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      stream_trait::traits,
                stream_trait::requires_stringbuf,
                stream_trait::len_t::value + 1
            > i_interpreter_type;

            typedef detail::lexical_ostream_limited_src<
                
# 471 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 471 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      stream_trait::char_type,
                
# 472 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp" 3
               typename 
# 472 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/detail/converter_lexical.hpp"
                                      stream_trait::traits
            > o_interpreter_type;

            static inline bool try_convert(const Source& arg, Target& result) {
                i_interpreter_type i_interpreter;


                if (!(i_interpreter.operator <<(arg)))
                    return false;

                o_interpreter_type out(i_interpreter.cbegin(), i_interpreter.cend());


                if(!(out.operator >>(result)))
                    return false;

                return true;
            }
        };
    }

}
# 45 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 2




namespace boost {
    namespace detail
    {
        template<typename T>
        struct is_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_stdstring< std::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};



        template<typename T>
        struct is_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_booststring< boost::container::basic_string<CharT, Traits, Alloc> >
            : boost::true_type
        {};

        template<typename Target, typename Source>
        struct is_arithmetic_and_not_xchars
        {
            typedef boost::integral_constant<
                bool,
                !(boost::detail::is_character<Target>::value) &&
                    !(boost::detail::is_character<Source>::value) &&
                    boost::is_arithmetic<Source>::value &&
                    boost::is_arithmetic<Target>::value
                > type;

            
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 3
           static const 
# 85 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
           bool value = ( type::value )

              ;
        };





        template<typename Target, typename Source>
        struct is_xchar_to_xchar
        {
            typedef boost::integral_constant<
                bool,
                sizeof(Source) == sizeof(Target) &&
                     sizeof(Source) == sizeof(char) &&
                     boost::detail::is_character<Target>::value &&
                     boost::detail::is_character<Source>::value
                > type;

            
# 105 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 3
           static const 
# 105 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
           bool value = ( type::value )

              ;
        };

        template<typename Target, typename Source>
        struct is_char_array_to_stdstring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};



        template<typename Target, typename Source>
        struct is_char_array_to_booststring
            : boost::false_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, CharT* >
            : boost::true_type
        {};

        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_booststring< boost::container::basic_string<CharT, Traits, Alloc>, const CharT* >
            : boost::true_type
        {};

        template <typename Target, typename Source>
        struct copy_converter_impl
        {



            template <class T>
            static inline bool try_convert(T&& arg, Target& result) {
                result = static_cast<T&&>(arg);
                return true;
            }






        };
    }

    namespace conversion { namespace detail {

        template <typename Target, typename Source>
        inline bool try_lexical_convert(const Source& arg, Target& result)
        {
            typedef 
# 167 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 3
                   typename 
# 167 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
                                          boost::detail::array_to_pointer_decay<Source>::type src;

            typedef boost::integral_constant<
                bool,
                boost::detail::is_xchar_to_xchar<Target, src >::value ||
                boost::detail::is_char_array_to_stdstring<Target, src >::value ||
                boost::detail::is_char_array_to_booststring<Target, src >::value ||
                (
                     boost::is_same<Target, src >::value &&
                     (boost::detail::is_stdstring<Target >::value || boost::detail::is_booststring<Target >::value)
                ) ||
                (
                     boost::is_same<Target, src >::value &&
                     boost::detail::is_character<Target >::value
                )
            > shall_we_copy_t;

            typedef boost::detail::is_arithmetic_and_not_xchars<Target, src >
                shall_we_copy_with_dynamic_check_t;



            typedef 
# 189 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 3
                   typename 
# 189 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
                                          boost::conditional<
                shall_we_copy_t::value,
                boost::type_identity<boost::detail::copy_converter_impl<Target, src > >,
                boost::conditional<
                     shall_we_copy_with_dynamic_check_t::value,
                     boost::detail::dynamic_num_converter_impl<Target, src >,
                     boost::detail::lexical_converter_impl<Target, src >
                >
            >::type caster_type_lazy;

            typedef 
# 199 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp" 3
                   typename 
# 199 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast/try_lexical_convert.hpp"
                                          caster_type_lazy::type caster_type;

            return caster_type::try_convert(arg, result);
        }

        template <typename Target, typename CharacterT>
        inline bool try_lexical_convert(const CharacterT* chars, std::size_t count, Target& result)
        {
            static_assert(boost::detail::is_character<CharacterT>::value, "This overload of try_lexical_convert is meant to be used only with arrays of characters.")


             ;
            return ::boost::conversion::detail::try_lexical_convert(
                ::boost::iterator_range<const CharacterT*>(chars, chars + count), result
            );
        }

    }}

    namespace conversion {

        using ::boost::conversion::detail::try_lexical_convert;
    }

}




#pragma GCC diagnostic pop
# 33 "/products/boost/v1_70_0/Linux64bit+3.10-2.17-e19-debug/include/boost/lexical_cast.hpp" 2

namespace boost
{
    template <typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        Target result = Target();

        if (!boost::conversion::detail::try_lexical_convert(arg, result)) {
            boost::conversion::detail::throw_bad_cast<Source, Target>();
        }

        return result;
    }

    template <typename Target>
    inline Target lexical_cast(const char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const unsigned char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const unsigned char*>(chars, chars + count)
        );
    }

    template <typename Target>
    inline Target lexical_cast(const signed char* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const signed char*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const wchar_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const wchar_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char16_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char16_t*>(chars, chars + count)
        );
    }


    template <typename Target>
    inline Target lexical_cast(const char32_t* chars, std::size_t count)
    {
        return ::boost::lexical_cast<Target>(
            ::boost::iterator_range<const char32_t*>(chars, chars + count)
        );
    }


}
# 4 "bad.h" 2
